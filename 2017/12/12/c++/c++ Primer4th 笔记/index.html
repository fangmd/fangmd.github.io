<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="c++,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="第一章 快速入门 C++ 基本要素：内置类型，库类型，类类型，变量，表达式，语句和函数 如何编译和运行程序  编写简单的 C++ 程序123int main()&amp;#123;	return 0;&amp;#125;  main 函数作为 c++ 程序的入口函数 main 函数是唯一被操作系统显式调用的函数  函数4元素：返回类型，函数名，圆括号内的形参表，函数体 编译与执行程序 编译器：CNU 编译器／微软">
<meta name="keywords" content="c++">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ Primer4th 笔记">
<meta property="og:url" content="http://yoursite.com/2017/12/12/c++/c++ Primer4th 笔记/index.html">
<meta property="og:site_name" content="Double">
<meta property="og:description" content="第一章 快速入门 C++ 基本要素：内置类型，库类型，类类型，变量，表达式，语句和函数 如何编译和运行程序  编写简单的 C++ 程序123int main()&amp;#123;	return 0;&amp;#125;  main 函数作为 c++ 程序的入口函数 main 函数是唯一被操作系统显式调用的函数  函数4元素：返回类型，函数名，圆括号内的形参表，函数体 编译与执行程序 编译器：CNU 编译器／微软">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-08-12T14:50:57.365Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c++ Primer4th 笔记">
<meta name="twitter:description" content="第一章 快速入门 C++ 基本要素：内置类型，库类型，类类型，变量，表达式，语句和函数 如何编译和运行程序  编写简单的 C++ 程序123int main()&amp;#123;	return 0;&amp;#125;  main 函数作为 c++ 程序的入口函数 main 函数是唯一被操作系统显式调用的函数  函数4元素：返回类型，函数名，圆括号内的形参表，函数体 编译与执行程序 编译器：CNU 编译器／微软">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/12/c++/c++ Primer4th 笔记/">





  <title>c++ Primer4th 笔记 | Double</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Double</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/12/c++/c++ Primer4th 笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">c++ Primer4th 笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-12T13:18:12+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章-快速入门"><a href="#第一章-快速入门" class="headerlink" title="第一章 快速入门"></a>第一章 快速入门</h1><ul>
<li>C++ 基本要素：内置类型，库类型，类类型，变量，表达式，语句和函数</li>
<li>如何编译和运行程序</li>
</ul>
<h2 id="编写简单的-C-程序"><a href="#编写简单的-C-程序" class="headerlink" title="编写简单的 C++ 程序"></a>编写简单的 C++ 程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main 函数作为 c++ 程序的入口函数</li>
<li>main 函数是唯一被操作系统显式调用的函数</li>
</ul>
<p>函数4元素：返回类型，函数名，圆括号内的形参表，函数体</p>
<p><strong>编译与执行程序</strong></p>
<p>编译器：CNU 编译器／微软编译器</p>
<a id="more"></a>
<p><strong>编译到运行完整流程：</strong></p>
<p><code>hello.cpp</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!1111"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译生成文件：<code>a.out</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp</span><br></pre></td></tr></table></figure>
<p>执行程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>
<h2 id="初窥输入／输出"><a href="#初窥输入／输出" class="headerlink" title="初窥输入／输出"></a>初窥输入／输出</h2><h3 id="标准输入与输出对象"><a href="#标准输入与输出对象" class="headerlink" title="标准输入与输出对象"></a>标准输入与输出对象</h3><p>标准库的 4 个 IO 对象：</p>
<ul>
<li>cin (see-in): 标准输入</li>
<li>cout (see-out): 标准输出</li>
<li>cerr(see-err): 标准错误</li>
<li>clog(see-log): log</li>
</ul>
<h3 id="一个使用-IO-库的程序"><a href="#一个使用-IO-库的程序" class="headerlink" title="一个使用 IO 库的程序"></a>一个使用 IO 库的程序</h3><ol>
<li>写入到流</li>
</ol>
<p>输入操作符（&lt;&lt;）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>endl: 操纵符（manipulator），将它写入输出流时，具有输出换行的效果，并刷行与设备相关联的缓冲区（buffer).</p>
<ol start="2">
<li>使用标准库中的名字</li>
</ol>
<p>添加 命名空间（namespace），可以直接使用 cout</p>
<ol start="3">
<li>读入流</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; v1 &gt;&gt; v2</span><br><span class="line"></span><br><span class="line">// equal to</span><br><span class="line"></span><br><span class="line">std::cin &gt;&gt; v1;</span><br><span class="line">std::cin &gt;&gt; v2;</span><br></pre></td></tr></table></figure>
<h2 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h2><p>comment</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* comments */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注释不可以嵌套</li>
</ul>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>, val = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(val &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">		sum += val;</span><br><span class="line">		++ val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum of 1 to 10 inclusive is"</span></span><br><span class="line">				&lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; += val)&#123;</span><br><span class="line">	sum += val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1, v2;</span><br><span class="line"><span class="keyword">int</span> lower, upper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(v1 &lt;= v2)&#123;</span><br><span class="line">	lower = v1;</span><br><span class="line">	upper = v2;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	lower = v2;</span><br><span class="line">	upper = v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读入未知数目的输入"><a href="#读入未知数目的输入" class="headerlink" title="读入未知数目的输入"></a>读入未知数目的输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>, value;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)&#123;</span><br><span class="line">		sum += value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum is"</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后结束：mac-os <code>ctrl-d</code>, windows: <code>ctrl + z</code></p>
<h2 id="类的简介"><a href="#类的简介" class="headerlink" title="类的简介"></a>类的简介</h2><p>class type</p>
<h3 id="Sales-item-类（不看）"><a href="#Sales-item-类（不看）" class="headerlink" title="Sales_item 类（不看）"></a>Sales_item 类（不看）</h3><p>存储 ISBN书 的销售册数，销售收入和平均售价。</p>
<h3 id="初窥成员函数-（不看）"><a href="#初窥成员函数-（不看）" class="headerlink" title="初窥成员函数 （不看）"></a>初窥成员函数 （不看）</h3><h2 id="C-程序"><a href="#C-程序" class="headerlink" title="C++ 程序"></a>C++ 程序</h2><h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><ul>
<li>bool</li>
<li>char    8</li>
<li>wchar_t    16</li>
<li>short    16</li>
<li>int     16</li>
<li>long     32</li>
<li>float      6    </li>
<li>double    10</li>
<li>long double     10    </li>
</ul>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>signed:</p>
<ul>
<li>int </li>
<li>short</li>
<li>long</li>
</ul>
<p>unsigned: </p>
<ul>
<li>usigned long </li>
<li>usigned int</li>
</ul>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><p>literal constant</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p><strong>左值和右值：</strong></p>
<ul>
<li>左值 lvalue: 左值可以出现在赋值语句的左边或右边</li>
<li>右值 rvalue：右值只能出现在赋值语句的右边</li>
</ul>
<p>变量是左值。</p>
<h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>标识符 identifier：变量名，由字母，数字，下划线组成，必须由字母或下划线开头，区分大小写。</p>
<h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><p>类型说明符 type specifier</p>
<ol>
<li>初始化</li>
</ol>
<p>复制初始化 copy-initialization <code>int ival = 1024;</code></p>
<p>直接初始化 direct-initialization <code>int ival(1024);</code></p>
<h3 id="变量初始化规则"><a href="#变量初始化规则" class="headerlink" title="变量初始化规则"></a>变量初始化规则</h3><ol>
<li>内置类型变量的初始化</li>
</ol>
<p>内置类型变量是否自动初始化取决于变量定义的位置。</p>
<ul>
<li>函数体外的变量都初始化为 0</li>
<li>函数体内的变量不会自动初始化</li>
</ul>
<ol start="2">
<li>类类型变量的初始化</li>
</ol>
<p>默认构造函数 default constructor</p>
<h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><ul>
<li>定义 definition: 用于为变量分配存储空间，可以为变量指定初始值</li>
<li>声明 declaration: 用于向程序表明变量的类型和名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int i; // declares but does not define i</span><br><span class="line"></span><br><span class="line">int i;	// declares and defines i</span><br></pre></td></tr></table></figure>
<p>只声明不会分配内存空间，如果声明的同时定义就会分配内存空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern double pi = 3.1416;	// definition</span><br></pre></td></tr></table></figure>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>scope</p>
<ul>
<li>global scope: 全局作用域</li>
<li>local scope: 局部作用域</li>
<li>statement scope: 语句作用域</li>
</ul>
<h3 id="在变量使用处定义变量"><a href="#在变量使用处定义变量" class="headerlink" title="在变量使用处定义变量"></a>在变量使用处定义变量</h3><blockquote>
<p>通常把一个对象定义在它首次使用的地方是很好的方法</p>
</blockquote>
<h2 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h2><p>const: 把一个对象转化成一个常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512;</span><br></pre></td></tr></table></figure>
<p>const 对象默认为文件的局部变量</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>reference</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ival = 1024;</span><br><span class="line">int &amp;refVal = ival;</span><br><span class="line">int &amp;refVal2;</span><br><span class="line">int &amp;refVal3 = 10;</span><br></pre></td></tr></table></figure>
<ol>
<li>引用是别名</li>
</ol>
<p>引用只是它绑定的对象的另一个名字，作用在引用上的所有操作事实上都作用在该引用绑定的对象上。</p>
<ol start="2">
<li>const 引用</li>
</ol>
<p>const 对象的引用只能是 const 引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int ival = 1024;</span><br><span class="line">const int &amp;refVal = ival;	// is ok</span><br><span class="line">int &amp;ref2 = ival;	// is wrong</span><br></pre></td></tr></table></figure>
<h2 id="typedfe-名字"><a href="#typedfe-名字" class="headerlink" title="typedfe 名字"></a>typedfe 名字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;</span><br></pre></td></tr></table></figure>
<p>wages 类型代表 double.</p>
<p>目的：</p>
<ol>
<li>为了隐藏特定类型的实现，强调使用类型的目的。</li>
<li>简化复杂的类型定义，使其更易理解</li>
<li>允许一种类型用于多个目的，同时使得每次使用该类型的目的明确</li>
</ol>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ol>
<li>define</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> open_modes&#123; input, output, append&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// input = 0, output = 1, append = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> open_modes&#123; input = <span class="number">1</span>, output, append&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// input = 1, output = 2, append = 3</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>枚举成员是常量</p>
</li>
<li><p>每个 enum 都定义一种唯一的类型</p>
</li>
</ol>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line">		<span class="keyword">unsigned</span> units_sold;</span><br><span class="line">		<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>使用 struct 关键字</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_item</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold;</span><br><span class="line">	<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct 与 class 区别：struct 修饰的类 成员默认访问级别都是 public.</p>
<blockquote>
<p>struct 成员为 public, class 成员为 private.</p>
</blockquote>
<h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>一般类的定义都会放在 header file 中。</p>
<h3 id="设计自己的头文件"><a href="#设计自己的头文件" class="headerlink" title="设计自己的头文件"></a>设计自己的头文件</h3><ol>
<li>头文件用于声明而不是定义</li>
<li>一些 const 对象定义在头文件中</li>
</ol>
<h3 id="预处理器的简单介绍"><a href="#预处理器的简单介绍" class="headerlink" title="预处理器的简单介绍"></a>预处理器的简单介绍</h3><p><code>#include</code> 属于 C++预处理器 的一部分</p>
<ol>
<li><p>头文件经常需要其他头文件</p>
<p> 使用 头文件保护符（header guard)，避免类和对象多次被定义</p>
</li>
<li>避免多重包含</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITERM_H</span><br><span class="line">#define SALESITEM_H</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><code>#ifndef SALESITERM_H</code> 检测 SALESITERM_H 是否已经被定义，如果已经被定义就不会执行下面的代码了。</p>
<ol start="3">
<li>使用自定义的头文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;standard_header&gt;</span><br><span class="line">#include &quot;my_file.h&quot;</span><br></pre></td></tr></table></figure>
<h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><h2 id="命名空间的-using-声明"><a href="#命名空间的-using-声明" class="headerlink" title="命名空间的 using 声明"></a>命名空间的 using 声明</h2><p>一次，只能引入一个名字，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace::name</span><br></pre></td></tr></table></figure>
<ol>
<li>每个名字都需要一个 using 声明</li>
</ol>
<h2 id="标准库-string-类型"><a href="#标准库-string-类型" class="headerlink" title="标准库 string 类型"></a>标准库 string 类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using std::string</span><br></pre></td></tr></table></figure>
<h3 id="string-对象的定义和初始化"><a href="#string-对象的定义和初始化" class="headerlink" title="string 对象的定义和初始化"></a>string 对象的定义和初始化</h3><p>初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">stirng s2(s1);</span><br><span class="line">sting s3(&quot;value&quot;);</span><br><span class="line">string s4(n, &apos;c&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="string-对象的读写"><a href="#string-对象的读写" class="headerlink" title="string 对象的读写"></a>string 对象的读写</h3><h3 id="string-对象的操作"><a href="#string-对象的操作" class="headerlink" title="string 对象的操作"></a>string 对象的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s.empty() ： retrun true/false</span><br><span class="line">s.size()</span><br><span class="line">s[n]</span><br><span class="line">s1 + s2</span><br><span class="line">s1 = s2</span><br><span class="line">v1 == v2</span><br><span class="line">!=, &lt;, &lt;=</span><br><span class="line">&gt; 和 &gt;=</span><br></pre></td></tr></table></figure>
<h3 id="string-对象中字符的处理"><a href="#string-对象中字符的处理" class="headerlink" title="string 对象中字符的处理"></a>string 对象中字符的处理</h3><p>单个字符的处理，<code>#include &lt;cctype&gt;</code> 中有大量的处理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isalnum(c)	判断是否是字母或者数字</span><br><span class="line">isalpha(c)	如果c是字母，返回 true</span><br><span class="line">iscntrl(c)	如果c是控制字符，返回 true</span><br><span class="line">isdigit(c)	如果c是数字，则为true</span><br><span class="line"></span><br><span class="line">isspace(c)</span><br><span class="line">isupper(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tolower(c)</span><br><span class="line">toupper(c)</span><br></pre></td></tr></table></figure>
<h2 id="标准库-vector-类型"><a href="#标准库-vector-类型" class="headerlink" title="标准库 vector 类型"></a>标准库 vector 类型</h2><p>vector 集合，容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">using std::vector;</span><br></pre></td></tr></table></figure>
<h3 id="vector-对象的定义和初始化"><a href="#vector-对象的定义和初始化" class="headerlink" title="vector 对象的定义和初始化"></a>vector 对象的定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;</span><br><span class="line">vector&lt;T&gt; v2(v1);</span><br><span class="line">vector&lt;T&gt; v3(n, i);</span><br><span class="line">vector&lt;T&gt; v4(n)</span><br></pre></td></tr></table></figure>
<h3 id="vector-对象的操作"><a href="#vector-对象的操作" class="headerlink" title="vector 对象的操作"></a>vector 对象的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v.empty()</span><br><span class="line">v.size()	</span><br><span class="line">v.push_back(t)	在v末尾增加一个值为 t 的元素</span><br><span class="line">v[n]</span><br><span class="line">v1 = v2</span><br><span class="line">v1 == v2</span><br><span class="line">!=, &lt;=, &gt;, &gt;=</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>vector 的下标操作：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix)&#123;</span><br><span class="line">	ivec[ix] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意这里使用的是 <code>!=</code></li>
</ul>
<h2 id="迭代器简介"><a href="#迭代器简介" class="headerlink" title="迭代器简介"></a>迭代器简介</h2><p>iterator</p>
<ol>
<li>容器的 iterator 类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator iter;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>begin and end operator</li>
</ol>
<p>begin: 返回指向第一个元素的迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator iter = ivec.being();</span><br></pre></td></tr></table></figure>
<p>end：返回指向最后一个元素的迭代器。</p>
<ol start="3">
<li>迭代器指向的移动</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*iter = 0 : 使用 解引用操作符 来访问迭代器所指向的元素</span><br><span class="line">++iter：指向第二个元素</span><br><span class="line">--iter：指向前一个元素</span><br></pre></td></tr></table></figure>
<p>使用索引遍历集合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.size(); ++ix)&#123;</span><br><span class="line">	ivec[ix] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环遍历，将每个元素都赋值为 0</p>
<p>使用迭代器遍历集合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = ivec.being(); iter != ivec.end(); ++iter)&#123;</span><br><span class="line">	*iter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理完成最后一个元素后，iter再增加1，就会与 end 操作的返回值相等。</p>
<ol start="4">
<li>只读迭代器 const_iterator</li>
</ol>
<ol start="5">
<li>迭代器算数操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;:: iterator mid = vi.begin() + vi.size()/2;</span><br></pre></td></tr></table></figure>
<h2 id="标准库-bitset-类型"><a href="#标准库-bitset-类型" class="headerlink" title="标准库 bitset 类型"></a>标准库 bitset 类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bitset&gt;</span><br><span class="line">using std::bitset</span><br></pre></td></tr></table></figure>
<p>二进制位的有序集合</p>
<h3 id="bitset-对象的定义和初始化"><a href="#bitset-对象的定义和初始化" class="headerlink" title="bitset 对象的定义和初始化"></a>bitset 对象的定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;32&gt; bitvec; 	// 32 bits, all zero</span><br></pre></td></tr></table></figure>
<h3 id="bitset-对象上的操作"><a href="#bitset-对象上的操作" class="headerlink" title="bitset 对象上的操作"></a>bitset 对象上的操作</h3><h1 id="第四章-数组和指针"><a href="#第四章-数组和指针" class="headerlink" title="第四章 数组和指针"></a>第四章 数组和指针</h1><p>C++ 语言提供了两种类似 verctor 和 迭代器类型 和低级复合类型 – 数组和指针。</p>
<blockquote>
<p>尽量使用 vector和迭代器类型</p>
</blockquote>
<p>数组长度固定。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义和初始化"><a href="#数组的定义和初始化" class="headerlink" title="数组的定义和初始化"></a>数组的定义和初始化</h3><p>数组定义的时候必须指定 维数(长度)，并且 维数 必须是常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const unsigned buf_size = 512, max_files = 20;</span><br><span class="line">int staff_size = 27;</span><br><span class="line">const unsigned sz = get_size();</span><br><span class="line"></span><br><span class="line">char input_buffer[buf_size];	// ok</span><br><span class="line">string fileTable[max_files + 1]	// ok</span><br><span class="line">double salaries[staff_size];	// error</span><br><span class="line">int test_scores[get_size()];	// error</span><br><span class="line">int value[sz];	// error size not known until run time</span><br></pre></td></tr></table></figure>
<ol>
<li>显示初始化数组元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> array_size = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ia[array_size] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ia2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在函数体外的定义的内置数组，其元素均初始化为 0</li>
<li>在函数体内定义的内置数组，其元素无初始化</li>
<li>如果元素为类类型，不管数组在哪里定义 都会使用默认构造函数进行初始化；如果该类没有默认初始化函数，必须为该数组的元素提供显式初始化。</li>
</ul>
<p>显示初始化数组的时候不需要制定数组的维数(长度)值。</p>
<ul>
<li>指定长度 必须 大于等于 初始化的显示元素个数。</li>
</ul>
<ol start="2">
<li><p>特殊的字符数组</p>
</li>
<li><p>不允许数组直接复制和赋值</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">int</span> ia2[]&#123;ia&#125;; <span class="comment">// error 复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ia3[<span class="number">3</span>];</span><br><span class="line">ia3 = ia;	<span class="comment">// error 赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>使用下标操作, vector 使用 <code>vector::size_type</code> 作为下标， 数组下标类型是 <code>size_t</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> ix = <span class="number">0</span>; ix != <span class="number">10</span>; ++ix)&#123;</span><br><span class="line">	ia[ix] = ix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针的引入"><a href="#指针的引入" class="headerlink" title="指针的引入"></a>指针的引入</h2><p>解引用操作符 dereference operator: <code>*</code></p>
<h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><p>指针保存的是另一个对象的地址。</p>
<p>去地址符号 address-of：<code>&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> *sp = &amp;s;</span><br></pre></td></tr></table></figure>
<p>第二条语句：定义了一个指向 string 类型的指针 sp，初始化 sp 指向 对象s，<code>*</code>操作符表示 sp 是一个指针变量，&amp;s 取地址。</p>
<h3 id="指针的定义和初始化"><a href="#指针的定义和初始化" class="headerlink" title="指针的定义和初始化"></a>指针的定义和初始化</h3><ol>
<li>指针变量的定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pvec</span><br><span class="line"><span class="keyword">int</span> *op1, *ip2;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>另一种声明指针的风格</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>* ps;	<span class="comment">// legal but can be misleading</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>指针可能的取值</li>
</ol>
<p>指针的三种状态：</p>
<ul>
<li>保存一个特定对象的地址</li>
<li>指向某个对象后面的另一个对象</li>
<li>0 值，不指向任何对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="number">0</span>;	<span class="comment">// pi initialized to address no object</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = &amp;ival; <span class="comment">// pi2 initialized to address of ival</span></span><br><span class="line"><span class="keyword">int</span>  *pi3;	<span class="comment">// ok 没有初始化的指针，</span></span><br><span class="line"></span><br><span class="line">pi = pi2;</span><br><span class="line">pi2 = <span class="number">0</span>; <span class="comment">// pi2 now address no object</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>避免使用未初始化的指针</p>
</li>
<li><p>void 指针：可以指向任何类型</p>
</li>
</ol>
<h3 id="指针的操作"><a href="#指针的操作" class="headerlink" title="指针的操作"></a>指针的操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> *sp = &amp;s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *sp; <span class="comment">// prints hello world</span></span><br><span class="line"></span><br><span class="line">*sp = <span class="string">"goodbye"</span>	<span class="comment">// 修改 s 的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"some value"</span>;</span><br><span class="line">sp = &amp;s2;	<span class="comment">// sp 指向 s2</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>指向指针的指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itn ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival;</span><br><span class="line"><span class="keyword">int</span> **ppi = &amp;pi;</span><br></pre></td></tr></table></figure>
<h3 id="使用指针访问数组元素"><a href="#使用指针访问数组元素" class="headerlink" title="使用指针访问数组元素"></a>使用指针访问数组元素</h3><p>指针和数组密切相关，在表达式中使用数组名的时候，名字会自动转换为指向数组第一个元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ip = ia;	<span class="comment">// ip points to ia[0]</span></span><br><span class="line"></span><br><span class="line">ip = &amp;ia[<span class="number">4</span>];	<span class="comment">// ip points to last element in ia</span></span><br></pre></td></tr></table></figure>
<ol>
<li>指针算数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip = ia;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ip2 = ip + <span class="number">4</span>; 	<span class="comment">//ok: ip2 points to ia[4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ptrdiff_t</span> n = ip2 - ip1;	<span class="comment">// ok, distance between the pointers</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>指针是数组的迭代器</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = ivec.begin(); iter != ivec.end(); ++iter)&#123;</span><br><span class="line">	*iter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针和-const-限定符"><a href="#指针和-const-限定符" class="headerlink" title="指针和 const 限定符"></a>指针和 const 限定符</h3><ol>
<li>指向 const 对象的指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr;</span><br><span class="line"></span><br><span class="line">*cptr = <span class="number">42</span>;	<span class="comment">// error: *cptr migth be const, 不能通过 cptr 修改其所指对象的值</span></span><br></pre></td></tr></table></figure>
<p>不能把一个 const 对象的地址赋给一个普通的对象指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;	<span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;	<span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>const 指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNum;</span><br></pre></td></tr></table></figure>
<h2 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C 风格字符串"></a>C 风格字符串</h2><blockquote>
<p>C++ 支持 c 风格的字符串，但是不应该在 C++ 中使用这个类型，容易出错。</p>
</blockquote>
<h3 id="创建动态数组"><a href="#创建动态数组" class="headerlink" title="创建动态数组"></a>创建动态数组</h3><h3 id="新旧代码的兼容"><a href="#新旧代码的兼容" class="headerlink" title="新旧代码的兼容"></a>新旧代码的兼容</h3><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><h1 id="第五章-表达式"><a href="#第五章-表达式" class="headerlink" title="第五章 表达式"></a>第五章 表达式</h1><p>表达式由 多个操作数和操作符 而成。</p>
<h2 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+, -, *, /, %</span><br></pre></td></tr></table></figure>
<h2 id="关系操作符和逻辑操作符"><a href="#关系操作符和逻辑操作符" class="headerlink" title="关系操作符和逻辑操作符"></a>关系操作符和逻辑操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! &lt; &lt;= &gt; &gt; &gt;= == != &amp;&amp; ||</span><br></pre></td></tr></table></figure>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ &lt;&lt; &gt;&gt; &amp; ^ |</span><br></pre></td></tr></table></figure>
<h3 id="bitset-对象或整型值的使用"><a href="#bitset-对象或整型值的使用" class="headerlink" title="bitset 对象或整型值的使用"></a>bitset 对象或整型值的使用</h3><h3 id="将移位操作符用于-IO"><a href="#将移位操作符用于-IO" class="headerlink" title="将移位操作符用于 IO"></a>将移位操作符用于 IO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;hi&quot; &lt;&lt; &quot; there&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=</span><br></pre></td></tr></table></figure>
<h3 id="赋值操作的右结合性"><a href="#赋值操作的右结合性" class="headerlink" title="赋值操作的右结合性"></a>赋值操作的右结合性</h3><h3 id="赋值操作具有低优先级"><a href="#赋值操作具有低优先级" class="headerlink" title="赋值操作具有低优先级"></a>赋值操作具有低优先级</h3><h3 id="复合赋值操作符"><a href="#复合赋值操作符" class="headerlink" title="复合赋值操作符"></a>复合赋值操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+= -= *= /= </span><br><span class="line">&lt;&lt;= &gt;&gt;= &amp;= ^= |=</span><br></pre></td></tr></table></figure>
<h2 id="自增和自减操作符"><a href="#自增和自减操作符" class="headerlink" title="自增和自减操作符"></a>自增和自减操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">++i</span><br><span class="line">i++</span><br><span class="line"></span><br><span class="line">--i</span><br><span class="line"></span><br><span class="line">i--</span><br></pre></td></tr></table></figure>
<h2 id="箭头操作符"><a href="#箭头操作符" class="headerlink" title="箭头操作符"></a>箭头操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;</span><br></pre></td></tr></table></figure>
<h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>唯一的 三元操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure>
<h2 id="sizeof-操作符"><a href="#sizeof-操作符" class="headerlink" title="sizeof 操作符"></a>sizeof 操作符</h2><p>返回一个对象或类型名的长度，返回值类型为 size_t.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof(type name);</span><br><span class="line">sizeof(expr);</span><br><span class="line">sizeof expr;</span><br></pre></td></tr></table></figure>
<h2 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h2><h2 id="复合表达式的求值"><a href="#复合表达式的求值" class="headerlink" title="复合表达式的求值"></a>复合表达式的求值</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><h3 id="结合性"><a href="#结合性" class="headerlink" title="结合性"></a>结合性</h3><h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><h2 id="new-和-delete-表达式"><a href="#new-和-delete-表达式" class="headerlink" title="new 和 delete 表达式"></a>new 和 delete 表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"dwareves"</span>;</span><br><span class="line"><span class="keyword">double</span> *pd = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> str;	<span class="comment">// error: str is not a dynamic object</span></span><br><span class="line"><span class="keyword">delete</span> pi;	<span class="comment">// error pi refers to a local</span></span><br><span class="line"><span class="keyword">delete</span> pd;	<span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果指针指向不是用 new 分配的内存地址，则在该指针上使用 delete 是不合法的。</p>
</blockquote>
<ol start="6">
<li>delete 之后，重设指针的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete p;</span><br></pre></td></tr></table></figure>
<p>删除指针后，该指针变成悬垂指针(dangling pointer)</p>
<ol start="7">
<li>const 对象的动态分配和回收</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="何时发生隐式类型转换"><a href="#何时发生隐式类型转换" class="headerlink" title="何时发生隐式类型转换"></a>何时发生隐式类型转换</h3><ol>
<li>混合类型的表达式中</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"></span><br><span class="line">ival &gt;= dval	<span class="comment">// ival converted to double</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用作条件的表达式转换为 bool 类型</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line"><span class="keyword">if</span>(ival)	<span class="comment">// ival converted to bool</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>用一表达式初始化某个变量，或者将一表达式赋值给某个变量，该表达式被转换成该变量的类型；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">3.24</span>;	<span class="comment">// 3.14 converted to int</span></span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line">ip = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><p>类型提升</p>
<h3 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h3><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><h3 id="何时需要强制类型转换"><a href="#何时需要强制类型转换" class="headerlink" title="何时需要强制类型转换"></a>何时需要强制类型转换</h3><h3 id="命名的强制类型转换"><a href="#命名的强制类型转换" class="headerlink" title="命名的强制类型转换"></a>命名的强制类型转换</h3><h3 id="旧式强制类型转换"><a href="#旧式强制类型转换" class="headerlink" title="旧式强制类型转换"></a>旧式强制类型转换</h3><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><p>大多数语句以分号结束。</p>
<p>空语句：在有些地方语法上需要一个语句，但是逻辑上并不需要。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != sought)&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h2><h2 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h2><h2 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h2><h2 id="if-语句-1"><a href="#if-语句-1" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><h3 id="使用-switch"><a href="#使用-switch" class="headerlink" title="使用 switch"></a>使用 switch</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch-中的控制流"><a href="#switch-中的控制流" class="headerlink" title="switch 中的控制流"></a>switch 中的控制流</h3><p>c++ 中 switch 语句具有穿透性，需要添加 break</p>
<h3 id="default-标号"><a href="#default-标号" class="headerlink" title="default 标号"></a>default 标号</h3><h3 id="switch-表达式与-case-标号"><a href="#switch-表达式与-case-标号" class="headerlink" title="switch 表达式与 case 标号"></a>switch 表达式与 case 标号</h3><h3 id="switch-内部的变量定义"><a href="#switch-内部的变量定义" class="headerlink" title="switch 内部的变量定义"></a>switch 内部的变量定义</h3><h2 id="while-语句-1"><a href="#while-语句-1" class="headerlink" title="while 语句"></a>while 语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement; condition; expression)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="省略-for-语句头的某些部分"><a href="#省略-for-语句头的某些部分" class="headerlink" title="省略 for 语句头的某些部分"></a>省略 for 语句头的某些部分</h3><h3 id="for-语句头中的多个定义"><a href="#for-语句头中的多个定义" class="headerlink" title="for 语句头中的多个定义"></a>for 语句头中的多个定义</h3><h2 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do while 语句"></a>do while 语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="keyword">int</span> foo == get_foo());</span><br></pre></td></tr></table></figure>
<h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>跳出最近的循环</p>
<h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p>跳出本次循环，继续下次循环</p>
<h2 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin:</span><br><span class="line"><span class="keyword">int</span> sz = get_size();</span><br><span class="line"><span class="keyword">if</span>(sz &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">goto</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="try-快和异常处理"><a href="#try-快和异常处理" class="headerlink" title="try 快和异常处理"></a>try 快和异常处理</h2><h3 id="throw-表达式"><a href="#throw-表达式" class="headerlink" title="throw 表达式"></a>throw 表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> runtime_error(<span class="string">"....."</span>)</span><br></pre></td></tr></table></figure>
<h3 id="try-块"><a href="#try-块" class="headerlink" title="try 块"></a>try 块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (exception-specifier)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exception</span><br><span class="line"></span><br><span class="line">runtime_error</span><br><span class="line">range_error</span><br><span class="line">overflow_error</span><br></pre></td></tr></table></figure>
<h2 id="使用预处理器进行调试"><a href="#使用预处理器进行调试" class="headerlink" title="使用预处理器进行调试"></a>使用预处理器进行调试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">	<span class="built_in">cerr</span> &lt;&lt; <span class="string">"starting main"</span>	&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p> 函数由函数名以及一组操作数类型唯一地表示。</p>
<p> 形参</p>
<p> 函数体</p>
<p> 返回类型</p>
<ol>
<li>函数调用的时候</li>
</ol>
<p>主调函数（calling function）的执行被挂起，被调函数（called function）开始执行。</p>
<ol start="2">
<li>函数体是一个作用域</li>
</ol>
<p>局部变量（local variable）</p>
<h3 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h3><h3 id="函数形参表"><a href="#函数形参表" class="headerlink" title="函数形参表"></a>函数形参表</h3><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="非引用形参"><a href="#非引用形参" class="headerlink" title="非引用形参"></a>非引用形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(v2)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = v2;</span><br><span class="line">		v2 = v1 % v2;</span><br><span class="line">		v1 = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcd(i, j)</span><br></pre></td></tr></table></figure>
<p>i, j 的值不会受到函数执行而改变。</p>
<ol>
<li>指针形参</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span></span>&#123;</span><br><span class="line">	*ip = <span class="number">0</span>;	<span class="comment">// 可以更改 ip 指针指向的值</span></span><br><span class="line">	ip = <span class="number">0</span>;	<span class="comment">// 不能改变 ip 指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 避免改变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">// *p 只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>const 形参数</li>
</ol>
<h3 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	v1 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector-和-其他容器类型-的形参"><a href="#vector-和-其他容器类型-的形参" class="headerlink" title="vector 和 其他容器类型 的形参"></a>vector 和 其他容器类型 的形参</h3><h3 id="数组-形参"><a href="#数组-形参" class="headerlink" title="数组 形参"></a>数组 形参</h3><h3 id="传递给函数的数组的处理"><a href="#传递给函数的数组的处理" class="headerlink" title="传递给函数的数组的处理"></a>传递给函数的数组的处理</h3><h3 id="main：-处理命令行选项"><a href="#main：-处理命令行选项" class="headerlink" title="main： 处理命令行选项"></a>main： 处理命令行选项</h3><h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><h2 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h2><h3 id="没有返回值的函数"><a href="#没有返回值的函数" class="headerlink" title="没有返回值的函数"></a>没有返回值的函数</h3><h3 id="具有返回值的函数"><a href="#具有返回值的函数" class="headerlink" title="具有返回值的函数"></a>具有返回值的函数</h3><ol>
<li>main 的返回值</li>
</ol>
<p>0: 表示程序运行成功</p>
<p>非0: 表示程序运行有问题</p>
<ol start="2">
<li>返回非引用类型</li>
</ol>
<p>临时对象 temporary object</p>
<ol start="3">
<li><p>返回引用</p>
</li>
<li><p>千万不要返回局部对象的引用</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">manip</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> ret = s;</span><br><span class="line">	<span class="keyword">return</span> ret;	<span class="comment">// wrong: returing reference to a local object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>千万不要返回指向局部对象的指针</li>
</ol>
<p>局部对象被释放后，执政变成了 悬垂指针</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(val &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> factorial(val - <span class="number">1</span>) * val;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数的声明可以和函数的定义分离；一个函数只能定义一次，但是可以声明多次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在头文件提供函数的声明。</p>
<h2 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h2><h3 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h3><p>自动对象：当定义它的函数被调用的时才存在的对象</p>
<h3 id="静态局部对象"><a href="#静态局部对象" class="headerlink" title="静态局部对象"></a>静态局部对象</h3><p>static 局部对象：延长对象的声明周期</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">count_calls</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> +=ctr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;  i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序依次输出 1 到 10 整数。</span></span><br></pre></td></tr></table></figure>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &lt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为这样的小操作定义一个函数的优点：</p>
<ol>
<li>阅读和理解函数比读一条表达式要轻松</li>
<li>方便修改，修改函数比修改所有的表达式要简单</li>
<li>函数可以重用</li>
</ol>
<p>缺点：</p>
<ol>
<li>慢</li>
</ol>
<p>内联函数可以避免上面的缺点，编译的时候会自动拆解函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; shortString(s1, s2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时会展开：</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>内联函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &lt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联机制适用于优化小，只有几行并且经常调用的函数。</p>
<p><strong>内联函数放入头文件</strong></p>
<p>内联函数的定义对编译器而言必须是可见。</p>
<h2 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">same_isbn</span><span class="params">(<span class="keyword">const</span> Sales_item &amp;rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> isbn == rhs.isbn;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line">		<span class="keyword">unsigned</span> unis_sold;</span><br><span class="line">		<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义成员函数的函数体"><a href="#定义成员函数的函数体" class="headerlink" title="定义成员函数的函数体"></a>定义成员函数的函数体</h3><ol>
<li><p>成员函数含有额外的，隐含的形参数</p>
</li>
<li><p>this 指针的引入<br> 每个成员函数都有一个额外的，隐含的形参 this。</p>
</li>
<li><p>const 成员函数的引入</p>
</li>
</ol>
<h3 id="在类外定义成员函数"><a href="#在类外定义成员函数" class="headerlink" title="在类外定义成员函数"></a>在类外定义成员函数</h3><p>在类的定义外面定义成员函数必须指明它们是类的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_item::avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(units_sold)&#123;</span><br><span class="line">		<span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写-Sales-item-类的构造函数"><a href="#编写-Sales-item-类的构造函数" class="headerlink" title="编写 Sales_item 类的构造函数"></a>编写 Sales_item 类的构造函数</h3><ol>
<li><p>构造函数是特殊的成员函数<br> 构造函数和类同名，没有返回值<br> 默认构造函数</p>
</li>
<li><p>构造函数的定义</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">same_isbn</span><span class="params">(<span class="keyword">const</span> Sales_item &amp;rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> isbn == rhs.isbn;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Sales_item():units_sold(<span class="number">0</span>), revenue(<span class="number">0.0</span>)&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line">		<span class="keyword">unsigned</span> unis_sold;</span><br><span class="line">		<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>构造函数的初始化列表</li>
</ol>
<h3 id="类代码文件的组织"><a href="#类代码文件的组织" class="headerlink" title="类代码文件的组织"></a>类代码文件的组织</h3><p>类 Sales_item 放在名为 Sales_item.h 文件中定义。</p>
<p>成员函数的定义在 Sales_item.cc 文件中。</p>
<h2 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h2><h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><h3 id="函数匹配与实参转换"><a href="#函数匹配与实参转换" class="headerlink" title="函数匹配与实参转换"></a>函数匹配与实参转换</h3><h3 id="重载确定的三个步骤"><a href="#重载确定的三个步骤" class="headerlink" title="重载确定的三个步骤"></a>重载确定的三个步骤</h3><h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><h1 id="第八章-标准-IO-库"><a href="#第八章-标准-IO-库" class="headerlink" title="第八章 标准 IO 库"></a>第八章 标准 IO 库</h1><h2 id="面向对象的标准库"><a href="#面向对象的标准库" class="headerlink" title="面向对象的标准库"></a>面向对象的标准库</h2><p>IO 标准库类型和头文件</p>
<ul>
<li>iostream：istream，ostream，iostream</li>
<li>fstream：ifstream，ofstream，fstream</li>
<li>sstream：istringstream，stringstream</li>
</ul>
<ol>
<li>国际字符的支持</li>
</ol>
<p><code>wchar_t</code> 类型</p>
<ol start="2">
<li>IO 对象不可复制或赋值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;	<span class="comment">// error, cannot assign stream objects</span></span><br></pre></td></tr></table></figure>
<h2 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h2><p>IO 标准库的条件状态：</p>
<ul>
<li>strm::iostate</li>
<li>strm::badbit</li>
<li>strm::failbit</li>
<li>strm::eofbit</li>
<li>s.eof()</li>
<li>s.fail()</li>
<li>s.bad()</li>
<li>s.good()</li>
<li>s.clear()</li>
<li>s.clear(flag)</li>
<li>s.setstate(flag)</li>
<li>s.rdstate()</li>
</ul>
<h2 id="输出缓冲区的管理"><a href="#输出缓冲区的管理" class="headerlink" title="输出缓冲区的管理"></a>输出缓冲区的管理</h2><p>每个 IO 对象管理一个缓存区，用于存储程序读写的数据，缓冲区刷新触发条件：</p>
<ol>
<li>程序结束。main 函数结束</li>
<li>缓存区满的时候</li>
<li>使用操纵符显式刷新缓冲区，比如：endl</li>
<li>在每次输出操作执行完成后，用 unitbuf 操纵符设置流的内部状态，从而清空缓冲区</li>
<li>输出流与输入流关联(tie)的时候，在读输入流时将刷新关联的输出缓冲区</li>
</ol>
<p><strong>输出缓冲区的刷新</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;hi&quot; &lt;&lt; flush;	// flushes the buffer</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;hi&quot; &lt;&lt; ends;	// inserts a null, flushes the buffer</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;hi&quot; &lt;&lt; endl;	// inserts a newline, then flushes the buffer</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>unitbuf</li>
</ol>
<p>刷行所有输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf &lt;&lt; &quot;first&quot; &lt;&lt; &quot; second&quot; &lt;&lt; nounitbuf</span><br><span class="line"></span><br><span class="line">// equals</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;first&quot; &lt;&lt; flush &lt;&lt; &quot; second&quot; &lt;&lt; flush;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果程序奔溃，则不会刷新缓冲区</p>
</blockquote>
<ol start="3">
<li>将输入和输出绑定在一起</li>
</ol>
<h2 id="文件的输入和输出"><a href="#文件的输入和输出" class="headerlink" title="文件的输入和输出"></a>文件的输入和输出</h2><h3 id="文件流对象的使用"><a href="#文件流对象的使用" class="headerlink" title="文件流对象的使用"></a>文件流对象的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct an ifstream and bind it to the file named ifile</span></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(ifile.c.str())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ofstream output file object write file named ofile</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(ofile.c_str())</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>检查文件是否打开成功</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!infile)&#123;</span><br><span class="line">	<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error: unable to open input file:"</span></span><br><span class="line">		&lt;&lt; ifile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(outfile) 	// ok, to use outfile</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将文件流与新文件重新捆绑</li>
</ol>
<p>fstream 对象打开就会与指定文件关联，如果要与另一个文件关联，需要先关闭之前的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"in"</span>)</span></span>;</span><br><span class="line">infile.close();</span><br><span class="line">infile.open(<span class="string">"next"</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>清除文件流的状态</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ifstream input;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it != files.end())&#123;</span><br><span class="line">	intput.open(it -&gt; c_str());	<span class="comment">// open file</span></span><br><span class="line">	<span class="keyword">if</span>(!input)&#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(intput &gt;&gt; s)&#123;</span><br><span class="line">		process(s);</span><br><span class="line">	&#125;</span><br><span class="line">	input.close();</span><br><span class="line">	input.clear();	<span class="comment">// reset state to ok</span></span><br><span class="line">	++it;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><ul>
<li>in</li>
<li>out</li>
<li>app</li>
<li>ate</li>
<li>trunc</li>
<li>binary</li>
</ul>
<h3 id="一个打开并检查输入文件的程序"><a href="#一个打开并检查输入文件的程序" class="headerlink" title="一个打开并检查输入文件的程序"></a>一个打开并检查输入文件的程序</h3><h2 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h2><h1 id="第-9-章-顺序容器"><a href="#第-9-章-顺序容器" class="headerlink" title="第 9 章 顺序容器"></a>第 9 章 顺序容器</h1><p>顺序容器：</p>
<ul>
<li>vector</li>
<li>list</li>
<li>deque (double-ended queue)</li>
</ul>
<p>顺序容器适配器：</p>
<ul>
<li>stack: LIFO</li>
<li>queue: FIFO</li>
<li>priority_queue: 有优先管理的队列</li>
</ul>
<h2 id="顺序容器的定义"><a href="#顺序容器的定义" class="headerlink" title="顺序容器的定义"></a>顺序容器的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist;</span><br><span class="line"><span class="built_in">deque</span>&lt;Sales_item&gt; items;</span><br></pre></td></tr></table></figure>
<h3 id="容器元素的初始化"><a href="#容器元素的初始化" class="headerlink" title="容器元素的初始化"></a>容器元素的初始化</h3><ol>
<li>容器初始化的时候可以使用另一个相同类型的容器副本</li>
<li>初始化为一段元素的副本</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist</span><span class="params">(svec.begin(), svec.end())</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>分配和初始化指定数目的元素</li>
</ol>
<h3 id="容器内元素的类型约束"><a href="#容器内元素的类型约束" class="headerlink" title="容器内元素的类型约束"></a>容器内元素的类型约束</h3><h2 id="迭代器和迭代器范围"><a href="#迭代器和迭代器范围" class="headerlink" title="迭代器和迭代器范围"></a>迭代器和迭代器范围</h2><p>常用迭代器运算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*iter 	返回迭代器 iter 所指向的元素的引用</span><br><span class="line">iter -&gt; mem	, (*iter).mem</span><br><span class="line">++iter</span><br><span class="line">iter++</span><br><span class="line">--iter</span><br><span class="line">iter--</span><br><span class="line">iter1 == iter2</span><br><span class="line">iter1 != iter2</span><br></pre></td></tr></table></figure>
<h3 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h3><p>c++ 使用一对迭代器标记迭代器范围（iterator range）</p>
<p>包头不包尾</p>
<p>[first, end)</p>
<p><strong>使用左闭合区间的变成意义：</strong></p>
<ul>
<li>当 first, last 相等时，迭代器范围为空</li>
<li>当 first, last 不相等, 迭代器范围内至少有一个元素，可以通过下面的代码写循环</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">	+=first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使迭代器失效的容器操作"><a href="#使迭代器失效的容器操作" class="headerlink" title="使迭代器失效的容器操作"></a>使迭代器失效的容器操作</h3><h2 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h2><h3 id="容器定义的类型别名"><a href="#容器定义的类型别名" class="headerlink" title="容器定义的类型别名"></a>容器定义的类型别名</h3><ul>
<li>size_type</li>
<li>iterator</li>
<li>const_iterator</li>
<li>reverse_iterator</li>
<li>const_reverse_iterator</li>
<li>difference_type</li>
<li>value_type</li>
<li>reference</li>
<li>const_reference</li>
</ul>
<h3 id="begin-和-end-成员"><a href="#begin-和-end-成员" class="headerlink" title="begin 和 end 成员"></a>begin 和 end 成员</h3><p>begin and end 指向容器内的第一个元素和最后一个元素的下一位置的迭代器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c.begin()</span><br><span class="line"></span><br><span class="line">c.end()</span><br><span class="line"></span><br><span class="line">c.rbegin(): 返回一个逆序迭代器，它指向容器 c 的最后一个元素</span><br><span class="line"></span><br><span class="line">c.rend(): 返回一个逆序迭代器，它指向容器 c 的第一个元素的前面的位置</span><br></pre></td></tr></table></figure>
<h3 id="在顺序容器中添加元素"><a href="#在顺序容器中添加元素" class="headerlink" title="在顺序容器中添加元素"></a>在顺序容器中添加元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c.push_back(t)</span><br><span class="line">c.push_front(t)</span><br><span class="line"></span><br><span class="line">// 下面只适用于 list, deque</span><br><span class="line">c.insert(p, t)</span><br><span class="line">c.insert(p, n, t)</span><br><span class="line">c.insert(p, b, e)</span><br></pre></td></tr></table></figure>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ivec1: 1 3</span><br><span class="line">ivec2: 0 2 4</span><br><span class="line"></span><br><span class="line">ivec1 &gt; ivec2 // 第一个元素就能比较出大小</span><br></pre></td></tr></table></figure>
<h3 id="容器大小的操作"><a href="#容器大小的操作" class="headerlink" title="容器大小的操作"></a>容器大小的操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c.size()</span><br><span class="line"></span><br><span class="line">c.max_size()</span><br><span class="line"></span><br><span class="line">c.empty()</span><br><span class="line"></span><br><span class="line">c.resize(n)</span><br><span class="line"></span><br><span class="line">c.resize(n, t)</span><br></pre></td></tr></table></figure>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.back()</span><br><span class="line">c.front()</span><br><span class="line"></span><br><span class="line">// 下面两个适用于 vector deque</span><br><span class="line">c[n]</span><br><span class="line">c.at(n)</span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.erase(p)</span><br><span class="line">c.erase(b, e)</span><br><span class="line">c.clear()</span><br><span class="line">c.pop_back()</span><br><span class="line">c.pop_front()</span><br></pre></td></tr></table></figure>
<h3 id="赋值与-swap"><a href="#赋值与-swap" class="headerlink" title="赋值与 swap"></a>赋值与 swap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2	删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1. c1 和 c2 的类型必须相同</span><br><span class="line"></span><br><span class="line">c1.swap(c2) 交换内容</span><br><span class="line"></span><br><span class="line">c.assign(b, e)</span><br><span class="line">c.assign(n, t)	将容器 c 重新设置为存储 n 个值为 t 的元素</span><br></pre></td></tr></table></figure>
<h2 id="vector-容器的自增长"><a href="#vector-容器的自增长" class="headerlink" title="vector 容器的自增长"></a>vector 容器的自增长</h2><p>vector 容器的元素以连续的方式存储元素。（数组数据结构）</p>
<p><strong>capacity, reserve 成员</strong>：capacity 操作获取在容器需要分配更多存储空间之前能够存储的元素总数，而 reserve 操作则告诉 vector 容器应该预留多少个元素的存储空间。</p>
<blockquote>
<p>每当 vector 容器不得不分配新的存储空间时，以加倍当前容量的分配策略实现重新分配。</p>
</blockquote>
<h2 id="容器的选用"><a href="#容器的选用" class="headerlink" title="容器的选用"></a>容器的选用</h2><p>list 容器：内存区域不连续，允许向前和向后遍历元素。插入和删除效率高，不支持随机访问，访问某个元素必须遍历所有相关元素。</p>
<p>vector：除了尾部外，其他位置插入／删除数据都需要移动其他数据效率低，内存区域连续</p>
<p>deque：从两端插入和删除元素都很快，但是在中间插入和删除元素效率低。</p>
<h2 id="再谈-string-类型"><a href="#再谈-string-类型" class="headerlink" title="再谈 string 类型"></a>再谈 string 类型</h2><h3 id="构造-string-对象的其他方法"><a href="#构造-string-对象的其他方法" class="headerlink" title="构造 string 对象的其他方法"></a>构造 string 对象的其他方法</h3><h3 id="修改-string-对象的其他方法"><a href="#修改-string-对象的其他方法" class="headerlink" title="修改 string 对象的其他方法"></a>修改 string 对象的其他方法</h3><h3 id="只适用于-string-类型的操作"><a href="#只适用于-string-类型的操作" class="headerlink" title="只适用于 string 类型的操作"></a>只适用于 string 类型的操作</h3><h3 id="string-类型的查找操作"><a href="#string-类型的查找操作" class="headerlink" title="string 类型的查找操作"></a>string 类型的查找操作</h3><h3 id="string-对象的比较"><a href="#string-对象的比较" class="headerlink" title="string 对象的比较"></a>string 对象的比较</h3><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><ul>
<li>queue</li>
<li>priority_queue</li>
<li>stack</li>
</ul>
<p>适配器：一个事物转化成另一个事物的机制。</p>
<p>适配器通用的操作和类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_type</span><br><span class="line"></span><br><span class="line">value_type</span><br><span class="line"></span><br><span class="line">container_type</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">A a(c);</span><br><span class="line"></span><br><span class="line">关系操作符</span><br></pre></td></tr></table></figure>
<h3 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h3><p>栈容器适配器支持的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.empty()</span><br><span class="line">s.size()</span><br><span class="line">s.pop()</span><br><span class="line">s.top()</span><br><span class="line">s.push(item)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;::size_type stk_size = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; intStack;	<span class="comment">// empty stack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fill up the stack</span></span><br><span class="line"><span class="keyword">int</span> ix = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(intStack.size() != stk_size)&#123;</span><br><span class="line">	intStack.push(ix++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> error_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// look at each value and pop it off the stack</span></span><br><span class="line"><span class="keyword">while</span>(intStack.empty == <span class="literal">false</span>)&#123;</span><br><span class="line">	<span class="keyword">int</span> value = intStack.top();</span><br><span class="line">	<span class="comment">// read the top element of the stack</span></span><br><span class="line">	<span class="keyword">if</span>(value != --ix)&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">"oops! expected"</span> &lt;&lt; ix</span><br><span class="line">			&lt;&lt; <span class="string">"received "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span><span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		++error_cnt;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	intStack.pop();	// op the top element, and repeat</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cout &lt;&lt; "</span>Our program ran with <span class="string">"</span></span><br><span class="line"><span class="string">	&lt;&lt; error_cnt &lt;&lt; "</span> errors!<span class="string">" &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>
<h3 id="队列和优先级队列"><a href="#队列和优先级队列" class="headerlink" title="队列和优先级队列"></a>队列和优先级队列</h3><p>队列和优先级队列支持的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">q.empty()</span><br><span class="line">q.size()</span><br><span class="line">q.pop()</span><br><span class="line">q.push(item)</span><br><span class="line"></span><br><span class="line">q.front()	// 只适用于队列</span><br><span class="line">q.back()	// 只适用于队列</span><br><span class="line"></span><br><span class="line">q.top()	// 只适用于优先级队列</span><br></pre></td></tr></table></figure>
<h1 id="第十章-关联容器"><a href="#第十章-关联容器" class="headerlink" title="第十章 关联容器"></a>第十章 关联容器</h1><p>associative container</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map 	关联数组，元素通过键来存储和读取</span><br><span class="line">set 	大小可变的集合，支持通过键实现快速读取</span><br><span class="line">multimap 	支持同一个键多次出现的 map</span><br><span class="line">multiset	支持同一个键多次出现的 set</span><br></pre></td></tr></table></figure>
<h2 id="引言：pair-类型"><a href="#引言：pair-类型" class="headerlink" title="引言：pair 类型"></a>引言：pair 类型</h2><p>pair 类型，在 utility 头文件中定义</p>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p>关联容器不能通过容器大小来定义，因为这样的话就无法知道键所对应的值是什么了。</p>
<h2 id="map-类型"><a href="#map-类型" class="headerlink" title="map 类型"></a>map 类型</h2><h3 id="map-对象的定义"><a href="#map-对象的定义" class="headerlink" title="map 对象的定义"></a>map 对象的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;	<span class="comment">// empty map from string to int</span></span><br></pre></td></tr></table></figure>
<p>map 构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;k, v&gt; m;</span><br><span class="line">map&lt;k, v&gt; m(m2);</span><br><span class="line">map&lt;k, v&gt; m(b, e);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实际应用中，键类型必须定义 &lt; 操作符，而且该操作符应能“正确地工作”，这点很重要</p>
</blockquote>
<h3 id="map-定义的类型"><a href="#map-定义的类型" class="headerlink" title="map 定义的类型"></a>map 定义的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;K, V&gt;::key_type	</span><br><span class="line">map&lt;K, V&gt;::mapped_type</span><br><span class="line">map&lt;K, V&gt;::value_type</span><br></pre></td></tr></table></figure>
<ol>
<li>map 迭代器进行解引用将产生 pair 类型的对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator map_it = word_count.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// *map_it is a reference to a pair&lt;const string, int&gt; object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;seconds;</span><br><span class="line"></span><br><span class="line">map_it-&gt;first = <span class="string">"new Key"</span>;	<span class="comment">// error:key is const</span></span><br><span class="line">++map_it-&gt;second;	<span class="comment">// ok cahnge value</span></span><br></pre></td></tr></table></figure>
<p>pair 对象，first 成员存放键，为 const，second 存放值。</p>
<h3 id="给-map-添加元素"><a href="#给-map-添加元素" class="headerlink" title="给 map 添加元素"></a>给 map 添加元素</h3><ul>
<li>insert</li>
<li>先用下标操作符获取元素，通过给元素赋值</li>
</ul>
<h3 id="使用下标访问-map-对象"><a href="#使用下标访问-map-对象" class="headerlink" title="使用下标访问 map 对象"></a>使用下标访问 map 对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"></span><br><span class="line">word_count[<span class="string">"Anna"</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>下标行为的编程意义</li>
</ol>
<p>如果下标表示的键在容器中不存在，就会添加新元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)&#123;</span><br><span class="line">	++word_count[word];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-insert-的使用"><a href="#map-insert-的使用" class="headerlink" title="map::insert 的使用"></a>map::insert 的使用</h3><h3 id="查找并读取-map-中的元素"><a href="#查找并读取-map-中的元素" class="headerlink" title="查找并读取 map 中的元素"></a>查找并读取 map 中的元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"><span class="keyword">int</span> occurs = word_count[<span class="string">"foobar"</span>]</span><br></pre></td></tr></table></figure>
<p>上面这种方式，如果 <code>footbar</code> 键不存在就会创建新的元素返回 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.count(k) 	返回 m 中 k 的出现次数</span><br><span class="line">m.find(k)	如果 m 容器中存在 k 索引的元素，则返回指向该元素的迭代器。如果不存在就返回超出末端迭代器。</span><br></pre></td></tr></table></figure>
<ol>
<li>检查 键 是否存在</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(word_count.couint(<span class="string">"foobar"</span>))&#123;</span><br><span class="line">	occurs = word.count[<span class="string">"foobar"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>读取元素而又不插入该元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = word_count.find(<span class="string">"foobar"</span>);</span><br><span class="line"><span class="keyword">if</span>(it != word_count.end())&#123;</span><br><span class="line">	occurs = it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从-map-对象中删除元素"><a href="#从-map-对象中删除元素" class="headerlink" title="从 map 对象中删除元素"></a>从 map 对象中删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.erase(k)</span><br><span class="line">m.erase(p)</span><br><span class="line">m.erase(b, e)</span><br></pre></td></tr></table></figure>
<h3 id="map-对象的迭代遍历"><a href="#map-对象的迭代遍历" class="headerlink" title="map 对象的迭代遍历"></a>map 对象的迭代遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator map_it = word_count.begin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(map_it != word_count.end())&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; map_it-&gt;first &lt;&lt; <span class="string">" occurs "</span></span><br><span class="line">		&lt;&lt; map_it-&gt;second &lt;&lt; <span class="string">" times "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	++map_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词转换-map-对象"><a href="#单词转换-map-对象" class="headerlink" title="单词转换 map 对象"></a>单词转换 map 对象</h3><h2 id="set-类型"><a href="#set-类型" class="headerlink" title="set 类型"></a>set 类型</h2><h3 id="set-容器的定义和使用"><a href="#set-容器的定义和使用" class="headerlink" title="set 容器的定义和使用"></a>set 容器的定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; set1;</span><br><span class="line">set1.insert(<span class="string">"the"</span>);</span><br><span class="line"></span><br><span class="line">set1.insert(svec,begin, svec.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">// query</span></span><br><span class="line">iset.find(<span class="number">1</span>)</span><br><span class="line">iset.count(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator set_it = iset.find(<span class="number">1</span>);</span><br><span class="line">*set_it = <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建-单词排除-集"><a href="#创建-单词排除-集" class="headerlink" title="创建 单词排除 集"></a>创建 单词排除 集</h3><h2 id="multimap-和-multiset-类型"><a href="#multimap-和-multiset-类型" class="headerlink" title="multimap 和 multiset 类型"></a>multimap 和 multiset 类型</h2><h3 id="元素的添加和删除"><a href="#元素的添加和删除" class="headerlink" title="元素的添加和删除"></a>元素的添加和删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authors is multimap</span></span><br><span class="line">authors.insert(make_pair(</span><br><span class="line">	<span class="built_in">string</span>(<span class="string">"barth, John"</span>),</span><br><span class="line">	<span class="built_in">string</span>(<span class="string">"Sot-Weed Factor"</span>)</span><br><span class="line">	));</span><br><span class="line"></span><br><span class="line">authors.insert(make_pair(</span><br><span class="line">	<span class="built_in">string</span>(<span class="string">"barth, John"</span>),</span><br><span class="line">	<span class="built_in">string</span>(<span class="string">"Sot-Weed Factor"</span>)</span><br><span class="line">	));	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;size_type cnt = authors.erase(search_item);</span><br></pre></td></tr></table></figure>
<h3 id="在-myltimap-和-multiset-中查找元素"><a href="#在-myltimap-和-multiset-中查找元素" class="headerlink" title="在 myltimap 和 multiset 中查找元素"></a>在 myltimap 和 multiset 中查找元素</h3><h2 id="容器的综合应用：文本查询程序"><a href="#容器的综合应用：文本查询程序" class="headerlink" title="容器的综合应用：文本查询程序"></a>容器的综合应用：文本查询程序</h2><h3 id="查询程序的设计"><a href="#查询程序的设计" class="headerlink" title="查询程序的设计"></a>查询程序的设计</h3><h3 id="TextQuery-类"><a href="#TextQuery-类" class="headerlink" title="TextQuery 类"></a>TextQuery 类</h3><h3 id="TextQuery-类的使用"><a href="#TextQuery-类的使用" class="headerlink" title="TextQuery 类的使用"></a>TextQuery 类的使用</h3><h3 id="编写成员函数"><a href="#编写成员函数" class="headerlink" title="编写成员函数"></a>编写成员函数</h3><h1 id="第十一章-泛型算法"><a href="#第十一章-泛型算法" class="headerlink" title="第十一章 泛型算法"></a>第十一章 泛型算法</h1><p>标准库只提供了容器的基本操作。</p>
<p>排序，取最大值，取最小值等复杂操作需要，泛型算法</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>算法如何工作</li>
</ol>
<p>每个泛型算法的实现都独立于单独的容器。</p>
<ol start="2">
<li><p>标准算法固有地独立于类型</p>
</li>
<li><p>迭代器将算法和容器绑定起来</p>
</li>
</ol>
<h2 id="初窥算法"><a href="#初窥算法" class="headerlink" title="初窥算法"></a>初窥算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><h3 id="对容器元素重新排列的算法"><a href="#对容器元素重新排列的算法" class="headerlink" title="对容器元素重新排列的算法"></a>对容器元素重新排列的算法</h3><h2 id="在谈迭代器"><a href="#在谈迭代器" class="headerlink" title="在谈迭代器"></a>在谈迭代器</h2><h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><h3 id="iostream-迭代器"><a href="#iostream-迭代器" class="headerlink" title="iostream 迭代器"></a>iostream 迭代器</h3><h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><h3 id="const-迭代器"><a href="#const-迭代器" class="headerlink" title="const 迭代器"></a>const 迭代器</h3><h3 id="五种迭代器"><a href="#五种迭代器" class="headerlink" title="五种迭代器"></a>五种迭代器</h3><h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><h3 id="算法的形参模式"><a href="#算法的形参模式" class="headerlink" title="算法的形参模式"></a>算法的形参模式</h3><h3 id="算法的命名规范"><a href="#算法的命名规范" class="headerlink" title="算法的命名规范"></a>算法的命名规范</h3><h2 id="容器特有算法"><a href="#容器特有算法" class="headerlink" title="容器特有算法"></a>容器特有算法</h2><h1 id="第十二章-类"><a href="#第十二章-类" class="headerlink" title="第十二章 类"></a>第十二章 类</h1><p>c++ 中，用类来定义自己的 抽象数据类型（abstract data type）。</p>
<p>三个新特征：</p>
<ul>
<li>友元</li>
<li>可变成员</li>
<li>静态成员</li>
</ul>
<h2 id="类的定义和声明"><a href="#类的定义和声明" class="headerlink" title="类的定义和声明"></a>类的定义和声明</h2><h3 id="类定义：扼要重述"><a href="#类定义：扼要重述" class="headerlink" title="类定义：扼要重述"></a>类定义：扼要重述</h3><h3 id="数据抽象和封装"><a href="#数据抽象和封装" class="headerlink" title="数据抽象和封装"></a>数据抽象和封装</h3><ol>
<li>访问标号实施抽象和封装</li>
</ol>
<h3 id="关于类定义的更多内容"><a href="#关于类定义的更多内容" class="headerlink" title="关于类定义的更多内容"></a>关于类定义的更多内容</h3><ol>
<li>同一类型的多个数据成员</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> constents;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span>::size_type cursor;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span>::size_type height, width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用类型别名来简化类</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">		index cursor;</span><br><span class="line">		index hegiht, width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>成员函数可被重载</li>
<li>定义重载成员函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type index;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> contens[cursor]&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">(index ht, index wd)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">		index cursor;</span><br><span class="line">		index height, width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类声明和类定义"><a href="#类声明和类定义" class="headerlink" title="类声明和类定义"></a>类声明和类定义</h3><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><h2 id="隐含的-this-指针"><a href="#隐含的-this-指针" class="headerlink" title="隐含的 this 指针"></a>隐含的 this 指针</h2><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ol>
<li>使用类的成员</li>
</ol>
<p>在类作用域之外，成员只能通过对象或指针分别使用成员访问操作符 <code>.</code> 或 <code>-&gt;</code> 来访问。</p>
<p>另一些直接通过类使用作用域操作符 <code>::</code> 来访问。</p>
<ol start="2">
<li>作用域与成员定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_item::avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(units_sold)&#123;</span><br><span class="line">		<span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全限定名 <code>Sales_item::avg_price</code> 来指出这是类 Sales_item 作用域中的 avg_price 成员的定义。</p>
<ol start="4">
<li>函数返回类型不一定在类作用域中</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type index;</span><br><span class="line">		<span class="function">index <span class="title">get_cursor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen::index <span class="title">Screen::get_cursor</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的返回值类型必须使用 完全限定名。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h3><h3 id="默认实参予构造函数"><a href="#默认实参予构造函数" class="headerlink" title="默认实参予构造函数"></a>默认实参予构造函数</h3><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><h3 id="隐式类类型转换"><a href="#隐式类类型转换" class="headerlink" title="隐式类类型转换"></a>隐式类类型转换</h3><h3 id="类成员的显式初始化"><a href="#类成员的显式初始化" class="headerlink" title="类成员的显式初始化"></a>类成员的显式初始化</h3><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h2 id="static-类成员"><a href="#static-类成员" class="headerlink" title="static 类成员"></a>static 类成员</h2><p>类静态成员</p>
<ol start="2">
<li>定义 static 成员</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">applyint</span><span class="params">()</span></span>&#123;</span><br><span class="line">			amount += amount * interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> owner;</span><br><span class="line">		<span class="keyword">double</span> amount;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用 static 成员</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> rate;</span><br><span class="line">rate = ac1.rate();</span><br><span class="line">rate = ac2-&gt;rate();</span><br><span class="line">rate = Account:;rate();</span><br></pre></td></tr></table></figure>
<h3 id="static-成员函数"><a href="#static-成员函数" class="headerlink" title="static 成员函数"></a>static 成员函数</h3><p>Account 类中有 rate 的 static 成员函数，在类外部定义 static 成员时 无须重复指定 static 保留字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Account::rate</span><span class="params">(<span class="keyword">double</span> newRate)</span></span>&#123;</span><br><span class="line">	interestRate = newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="static-数据成员"><a href="#static-数据成员" class="headerlink" title="static 数据成员"></a>static 数据成员</h3><h1 id="第十三章-复制控制"><a href="#第十三章-复制控制" class="headerlink" title="第十三章 复制控制"></a>第十三章 复制控制</h1><p>复制构造函数：copy constructor, 是一种特殊的构造函数，具有单一形参，该参数时对该类类型的引用。</p>
<p>析构函数: destructor，当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。析构函数可用于释放对象时构造或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非 static 数据成员的析构函数。</p>
<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>只有单个形参，而且该形参是对本类类型对象的引用（常用 const 修饰），这样的构造函数称为 复制构造函数。</p>
<p>作用：</p>
<ul>
<li>根据另一个同类型的对象显示或隐式初始化一个对象</li>
<li>复制一个对象，将它作为实参传给一个函数</li>
<li>从函数返回时复制一个对象</li>
<li>初始化顺序容器中的元素</li>
<li>根据元素初始化式时列表初始化数组元素</li>
</ul>
<ol>
<li>对象的定义形式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-9999"</span>;	<span class="comment">// copy-initialization</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">" ."</span>)</span></span>;	<span class="comment">// direct-initialization</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>形参与返回值</p>
</li>
<li><p>初始化容器元素</p>
</li>
</ol>
<h3 id="合成的复制构造函数"><a href="#合成的复制构造函数" class="headerlink" title="合成的复制构造函数"></a>合成的复制构造函数</h3><h3 id="定义自己的复制构造函数"><a href="#定义自己的复制构造函数" class="headerlink" title="定义自己的复制构造函数"></a>定义自己的复制构造函数</h3><h3 id="禁止复制"><a href="#禁止复制" class="headerlink" title="禁止复制"></a>禁止复制</h3><h2 id="赋值操作符-1"><a href="#赋值操作符-1" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><h2 id="消息处理示例"><a href="#消息处理示例" class="headerlink" title="消息处理示例"></a>消息处理示例</h2><h2 id="管理指针成员"><a href="#管理指针成员" class="headerlink" title="管理指针成员"></a>管理指针成员</h2><h3 id="定义智能指针类"><a href="#定义智能指针类" class="headerlink" title="定义智能指针类"></a>定义智能指针类</h3><h3 id="定义值型类"><a href="#定义值型类" class="headerlink" title="定义值型类"></a>定义值型类</h3><h1 id="第十四章-重载操作符与转换"><a href="#第十四章-重载操作符与转换" class="headerlink" title="第十四章 重载操作符与转换"></a>第十四章 重载操作符与转换</h1><p>442</p>
<h1 id="第十五章-面向对象编程"><a href="#第十五章-面向对象编程" class="headerlink" title="第十五章 面向对象编程"></a>第十五章 面向对象编程</h1><h2 id="面向对象编程：概述"><a href="#面向对象编程：概述" class="headerlink" title="面向对象编程：概述"></a>面向对象编程：概述</h2><p>面向对象编程的关键思想是 多态性</p>
<ol>
<li>继承</li>
<li>动态绑定</li>
</ol>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item_base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Item_base(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book = <span class="string">""</span>,</span><br><span class="line">			<span class="keyword">double</span> sales_price = <span class="number">0.0</span>):</span><br><span class="line">				isbn(book), price(sales_price)&#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">book</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> isbn;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n * price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>基类成员函数</li>
</ol>
<p><code>virtual</code> 保留字表示启用动态绑定</p>
<blockquote>
<p>基类将派生类需要重新定义的任意函数定义为虚函数</p>
</blockquote>
<ol start="2">
<li>访问控制和继承</li>
</ol>
<h3 id="protected-成员"><a href="#protected-成员" class="headerlink" title="protected 成员"></a>protected 成员</h3><h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><ol>
<li>定义派生类</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_item</span>:</span> <span class="keyword">public</span> Item_base&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty;</span><br><span class="line">	<span class="keyword">double</span> discount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>派生类和虚函数</li>
<li>派生类对象包含基类对象作为子对象</li>
<li>派生类中的函数可以使用基类的成员</li>
</ol>
<h3 id="virtual-与其他成员函数"><a href="#virtual-与其他成员函数" class="headerlink" title="virtual 与其他成员函数"></a>virtual 与其他成员函数</h3><h3 id="公用，私有和受保护的继承"><a href="#公用，私有和受保护的继承" class="headerlink" title="公用，私有和受保护的继承"></a>公用，私有和受保护的继承</h3><h3 id="友元关系与继承"><a href="#友元关系与继承" class="headerlink" title="友元关系与继承"></a>友元关系与继承</h3><p>基类或派生类可以使其他类或函数成为友元。</p>
<blockquote>
<p>友元关系不能继承</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">	fridend <span class="class"><span class="keyword">class</span> <span class="title">Frnd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frnd</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">men</span><span class="params">(Base b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b.i;	<span class="comment">// ok</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">men</span><span class="params">(D1 d)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d.i;	<span class="comment">// error: friendship does not inherit</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><h2 id="转换与继承"><a href="#转换与继承" class="headerlink" title="转换与继承"></a>转换与继承</h2><h3 id="派生类到基类的转换"><a href="#派生类到基类的转换" class="headerlink" title="派生类到基类的转换"></a>派生类到基类的转换</h3><p>如果有一个派生类型的对象，则可以使用它的地址对基类类型的指针进行赋值或初始化。</p>
<ol>
<li><p>引用转换不同于转换对象</p>
</li>
<li><p>用派生类对象对基类对象进行初始化或赋值</p>
</li>
<li><p>派生类到基类转换的可访问性</p>
</li>
</ol>
<h3 id="基类到派生类的转换"><a href="#基类到派生类的转换" class="headerlink" title="基类到派生类的转换"></a>基类到派生类的转换</h3><h2 id="构造函数和复制控制"><a href="#构造函数和复制控制" class="headerlink" title="构造函数和复制控制"></a>构造函数和复制控制</h2><h3 id="基类构造函数和复制控制"><a href="#基类构造函数和复制控制" class="headerlink" title="基类构造函数和复制控制"></a>基类构造函数和复制控制</h3><h3 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h3><h3 id="复制控制和继承"><a href="#复制控制和继承" class="headerlink" title="复制控制和继承"></a>复制控制和继承</h3><ol>
<li>定义派生类复制构造函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> <span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived(<span class="keyword">const</span> Derived&amp; d):</span><br><span class="line">		Base(d)&#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><h3 id="构造函数和析构函数中的虚函数"><a href="#构造函数和析构函数中的虚函数" class="headerlink" title="构造函数和析构函数中的虚函数"></a>构造函数和析构函数中的虚函数</h3><h2 id="继承情况下的类作用域"><a href="#继承情况下的类作用域" class="headerlink" title="继承情况下的类作用域"></a>继承情况下的类作用域</h2><p>每个类都保持着自己的作用域，在该作用域中定义了成员的名字。</p>
<p>在继承情况下，派生类的作用域嵌套在基类作用域中。</p>
<h3 id="名字查找在编译时发生"><a href="#名字查找在编译时发生" class="headerlink" title="名字查找在编译时发生"></a>名字查找在编译时发生</h3><h3 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h3><blockquote>
<p>与基类成员名相同的派生类成员将屏蔽对基类成员的直接访问。</p>
</blockquote>
<h3 id="作用域与成员函数"><a href="#作用域与成员函数" class="headerlink" title="作用域与成员函数"></a>作用域与成员函数</h3><h3 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> D1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>D1 中 fcn 没有重定义 Base 中的虚函数 fcn，相反它屏蔽了基类的 fcn。结果 D1 有两个名为 fcn 的函数。</p>
<p>D2 重定义了它继承的两个函数，它重定义了 Base 中定义的 fcn 的原始版本并重定义了 D1 中定义的非虚版本。</p>
<p><strong>通过基类调用被屏蔽的虚函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line"></span><br><span class="line">bp1-&gt;fcn();	<span class="comment">// ok Base::fcn</span></span><br><span class="line">bp2-&gt;fcn();	<span class="comment">// ok Base::fcn</span></span><br><span class="line">bp3-&gt;fcn();	<span class="comment">// ok D2::fcn</span></span><br></pre></td></tr></table></figure>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>在函数形参表后面写上 =0 指定纯虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_item</span>:</span> <span class="keyword">public</span> Item_base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将函数定义为存虚能够说明。该函数为后代类型提供了可以覆盖的接口，但是这个类中的版本绝不会调用。</p>
<p>用户不能创建 Disc_item 类型的对象。（类似 java 中的抽象类）</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;Item_base&gt; basker;</span><br><span class="line">Item_base base;</span><br><span class="line">Buld_item bulk;</span><br><span class="line"></span><br><span class="line">basket.insert(base);</span><br><span class="line">basket.insert(bulk);	<span class="comment">// ok, but bulk sliced down to its base part</span></span><br></pre></td></tr></table></figure>
<h2 id="句柄类与继承"><a href="#句柄类与继承" class="headerlink" title="句柄类与继承"></a>句柄类与继承</h2><p>c++ 中不能使用对象支持面向对象编程，必须使用指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prices</span><span class="params">(Item_base object, <span class="keyword">const</span> Item_base *pointer, <span class="keyword">const</span> Item_base &amp;reference)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// which version of net_price is called is determined at run time</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pointer-&gt;net_price(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; reference.net_price(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// always invokes Item_base::net_price</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; object.net_price(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 pointer 和 reference 进行的调用在运行时根据它们所绑定对象的动态类型而确定。</p>
<p>使用指针或引用会加重类用户的负担。</p>
<p>定义包装（cover）类</p>
<p>句柄（handle）类</p>
<h3 id="指针型句柄"><a href="#指针型句柄" class="headerlink" title="指针型句柄"></a>指针型句柄</h3><h3 id="复制未知类型"><a href="#复制未知类型" class="headerlink" title="复制未知类型"></a>复制未知类型</h3><h3 id="句柄的使用"><a href="#句柄的使用" class="headerlink" title="句柄的使用"></a>句柄的使用</h3><h2 id="再谈文本查询示例"><a href="#再谈文本查询示例" class="headerlink" title="再谈文本查询示例"></a>再谈文本查询示例</h2><h3 id="面向对象的解决方案"><a href="#面向对象的解决方案" class="headerlink" title="面向对象的解决方案"></a>面向对象的解决方案</h3><h3 id="值型句柄"><a href="#值型句柄" class="headerlink" title="值型句柄"></a>值型句柄</h3><h3 id="Query-base-类"><a href="#Query-base-类" class="headerlink" title="Query_base 类"></a>Query_base 类</h3><h3 id="Query-句柄类"><a href="#Query-句柄类" class="headerlink" title="Query 句柄类"></a>Query 句柄类</h3><h3 id="派生类-1"><a href="#派生类-1" class="headerlink" title="派生类"></a>派生类</h3><h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval 函数"></a>eval 函数</h3><h1 id="第十六章-模版与泛型编程"><a href="#第十六章-模版与泛型编程" class="headerlink" title="第十六章 模版与泛型编程"></a>第十六章 模版与泛型编程</h1><h2 id="模版定义"><a href="#模版定义" class="headerlink" title="模版定义"></a>模版定义</h2><h3 id="定义函数模版"><a href="#定义函数模版" class="headerlink" title="定义函数模版"></a>定义函数模版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义类模版"><a href="#定义类模版" class="headerlink" title="定义类模版"></a>定义类模版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt; <span class="title">class</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Queue();</span><br><span class="line">	<span class="function">Type &amp;<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> type &amp;<span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Type &amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>模版形参作用域</li>
<li>使用模版形参名字的限制</li>
<li>模版声明</li>
</ol>
<h3 id="模版类型形参"><a href="#模版类型形参" class="headerlink" title="模版类型形参"></a>模版类型形参</h3><ol>
<li>typename 与 class 的区别</li>
</ol>
<p>在函数模版形参表中，关键字 typename 和 class 具有相同的含义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt; <span class="title">calc</span>(<span class="title">const</span> <span class="title">T</span>&amp;, <span class="title">const</span> <span class="title">U</span>&amp;);</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在模版定义内部指定类型</li>
</ol>
<h3 id="编写泛型程序"><a href="#编写泛型程序" class="headerlink" title="编写泛型程序"></a>编写泛型程序</h3><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><ol>
<li>类的实例化</li>
</ol>
<p>当编写 <code>Queue&lt;int&gt; qi</code>时，编译器自动chuangj <code>Queue&lt;int&gt;</code> 的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">Queue</span>&lt;int&gt;&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Queue();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> &amp;<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类模版的每次实例化都会产生一个独立的类类型。</p>
</blockquote>
<ol start="2">
<li>类模版形参是必须的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue qs;	<span class="comment">// error: which template instantiation?</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>函数模版实例化</li>
</ol>
<h3 id="模版实参推断"><a href="#模版实参推断" class="headerlink" title="模版实参推断"></a>模版实参推断</h3><ol>
<li>多个类型形参的实参必须完全匹配</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面模版在使用的时候 v1 和 v2 的类型必须一样。</p>
<ol start="2">
<li>类型形参的实参的受限转换</li>
</ol>
<p>v1 和 v2 之前只要可以转换到同一个类型也可以，比如（int short）可作为 (int, int) 处理</p>
<h3 id="函数模版的显式实参"><a href="#函数模版的显式实参" class="headerlink" title="函数模版的显式实参"></a>函数模版的显式实参</h3><h2 id="模版编译模型"><a href="#模版编译模型" class="headerlink" title="模版编译模型"></a>模版编译模型</h2><h2 id="类模版成员"><a href="#类模版成员" class="headerlink" title="类模版成员"></a>类模版成员</h2><h3 id="类模版成员函数"><a href="#类模版成员函数" class="headerlink" title="类模版成员函数"></a>类模版成员函数</h3><h3 id="非类型形参的模版实参"><a href="#非类型形参的模版实参" class="headerlink" title="非类型形参的模版实参"></a>非类型形参的模版实参</h3><h3 id="类模版中的友元声明"><a href="#类模版中的友元声明" class="headerlink" title="类模版中的友元声明"></a>类模版中的友元声明</h3><h3 id="Queue-和-QueueItem-的友元声明"><a href="#Queue-和-QueueItem-的友元声明" class="headerlink" title="Queue 和 QueueItem 的友元声明"></a>Queue 和 QueueItem 的友元声明</h3><h3 id="成员模版"><a href="#成员模版" class="headerlink" title="成员模版"></a>成员模版</h3><h3 id="完整的-Queue-类"><a href="#完整的-Queue-类" class="headerlink" title="完整的 Queue 类"></a>完整的 Queue 类</h3><h3 id="类模版的-static-成员"><a href="#类模版的-static-成员" class="headerlink" title="类模版的 static 成员"></a>类模版的 static 成员</h3><h2 id="一个泛型句柄类"><a href="#一个泛型句柄类" class="headerlink" title="一个泛型句柄类"></a>一个泛型句柄类</h2><h3 id="定义句柄类"><a href="#定义句柄类" class="headerlink" title="定义句柄类"></a>定义句柄类</h3><h3 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h3><h2 id="模版特化"><a href="#模版特化" class="headerlink" title="模版特化"></a>模版特化</h2><h3 id="函数模版的特化"><a href="#函数模版的特化" class="headerlink" title="函数模版的特化"></a>函数模版的特化</h3><h3 id="类模版的特化"><a href="#类模版的特化" class="headerlink" title="类模版的特化"></a>类模版的特化</h3><h3 id="特化成员而不特化类"><a href="#特化成员而不特化类" class="headerlink" title="特化成员而不特化类"></a>特化成员而不特化类</h3><h3 id="类模版的部分特化"><a href="#类模版的部分特化" class="headerlink" title="类模版的部分特化"></a>类模版的部分特化</h3><h2 id="重载与函数模版"><a href="#重载与函数模版" class="headerlink" title="重载与函数模版"></a>重载与函数模版</h2><h1 id="第十七章-用于大型程序的工具"><a href="#第十七章-用于大型程序的工具" class="headerlink" title="第十七章 用于大型程序的工具"></a>第十七章 用于大型程序的工具</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h3 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h3><h3 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h3><h3 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h3><h3 id="命名空间成员的使用"><a href="#命名空间成员的使用" class="headerlink" title="命名空间成员的使用"></a>命名空间成员的使用</h3><h3 id="类，命名空间和作用域"><a href="#类，命名空间和作用域" class="headerlink" title="类，命名空间和作用域"></a>类，命名空间和作用域</h3><h3 id="重载与命名空间"><a href="#重载与命名空间" class="headerlink" title="重载与命名空间"></a>重载与命名空间</h3><h3 id="命名空间与模版"><a href="#命名空间与模版" class="headerlink" title="命名空间与模版"></a>命名空间与模版</h3><h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><h3 id="转换与多个基类"><a href="#转换与多个基类" class="headerlink" title="转换与多个基类"></a>转换与多个基类</h3><h3 id="多重继承派生类的复制控制"><a href="#多重继承派生类的复制控制" class="headerlink" title="多重继承派生类的复制控制"></a>多重继承派生类的复制控制</h3><h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><h3 id="虚基类的声明"><a href="#虚基类的声明" class="headerlink" title="虚基类的声明"></a>虚基类的声明</h3><h3 id="特殊的初始化语义"><a href="#特殊的初始化语义" class="headerlink" title="特殊的初始化语义"></a>特殊的初始化语义</h3><h1 id="特殊工具与技术"><a href="#特殊工具与技术" class="headerlink" title="特殊工具与技术"></a>特殊工具与技术</h1>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c/" rel="tag"># c++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/11/ReadNote/数据结构、算法与应用c++语言描述/" rel="next" title="数据结构、算法与应用 c++ 语言描述">
                <i class="fa fa-chevron-left"></i> 数据结构、算法与应用 c++ 语言描述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/15/jenkins/JenkinsAndroid/" rel="prev" title="Jenkins Android使用记录">
                Jenkins Android使用记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/head1.jpg" alt="Double">
          <p class="site-author-name" itemprop="name">Double</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">548</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">260</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-快速入门"><span class="nav-number">1.</span> <span class="nav-text">第一章 快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编写简单的-C-程序"><span class="nav-number">1.1.</span> <span class="nav-text">编写简单的 C++ 程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初窥输入／输出"><span class="nav-number">1.2.</span> <span class="nav-text">初窥输入／输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准输入与输出对象"><span class="nav-number">1.2.1.</span> <span class="nav-text">标准输入与输出对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个使用-IO-库的程序"><span class="nav-number">1.2.2.</span> <span class="nav-text">一个使用 IO 库的程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于注释"><span class="nav-number">1.3.</span> <span class="nav-text">关于注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制结构"><span class="nav-number">1.4.</span> <span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while-语句"><span class="nav-number">1.4.1.</span> <span class="nav-text">while 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-语句"><span class="nav-number">1.4.2.</span> <span class="nav-text">for 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-语句"><span class="nav-number">1.4.3.</span> <span class="nav-text">if 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读入未知数目的输入"><span class="nav-number">1.4.4.</span> <span class="nav-text">读入未知数目的输入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的简介"><span class="nav-number">1.5.</span> <span class="nav-text">类的简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sales-item-类（不看）"><span class="nav-number">1.5.1.</span> <span class="nav-text">Sales_item 类（不看）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初窥成员函数-（不看）"><span class="nav-number">1.5.2.</span> <span class="nav-text">初窥成员函数 （不看）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-程序"><span class="nav-number">1.6.</span> <span class="nav-text">C++ 程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-变量和基本类型"><span class="nav-number">2.</span> <span class="nav-text">第二章 变量和基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本内置类型"><span class="nav-number">2.1.</span> <span class="nav-text">基本内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整型"><span class="nav-number">2.1.1.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点型"><span class="nav-number">2.1.2.</span> <span class="nav-text">浮点型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面值常量"><span class="nav-number">2.2.</span> <span class="nav-text">字面值常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">2.3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是变量"><span class="nav-number">2.3.1.</span> <span class="nav-text">什么是变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量名"><span class="nav-number">2.3.2.</span> <span class="nav-text">变量名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义对象"><span class="nav-number">2.3.3.</span> <span class="nav-text">定义对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量初始化规则"><span class="nav-number">2.3.4.</span> <span class="nav-text">变量初始化规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明和定义"><span class="nav-number">2.3.5.</span> <span class="nav-text">声明和定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名字的作用域"><span class="nav-number">2.3.6.</span> <span class="nav-text">名字的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在变量使用处定义变量"><span class="nav-number">2.3.7.</span> <span class="nav-text">在变量使用处定义变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-限定符"><span class="nav-number">2.4.</span> <span class="nav-text">const 限定符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">2.5.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedfe-名字"><span class="nav-number">2.6.</span> <span class="nav-text">typedfe 名字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">2.7.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类类型"><span class="nav-number">2.8.</span> <span class="nav-text">类类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写自己的头文件"><span class="nav-number">2.9.</span> <span class="nav-text">编写自己的头文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计自己的头文件"><span class="nav-number">2.9.1.</span> <span class="nav-text">设计自己的头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预处理器的简单介绍"><span class="nav-number">2.9.2.</span> <span class="nav-text">预处理器的简单介绍</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-标准库类型"><span class="nav-number">3.</span> <span class="nav-text">第三章 标准库类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间的-using-声明"><span class="nav-number">3.1.</span> <span class="nav-text">命名空间的 using 声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库-string-类型"><span class="nav-number">3.2.</span> <span class="nav-text">标准库 string 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string-对象的定义和初始化"><span class="nav-number">3.2.1.</span> <span class="nav-text">string 对象的定义和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-对象的读写"><span class="nav-number">3.2.2.</span> <span class="nav-text">string 对象的读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-对象的操作"><span class="nav-number">3.2.3.</span> <span class="nav-text">string 对象的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-对象中字符的处理"><span class="nav-number">3.2.4.</span> <span class="nav-text">string 对象中字符的处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库-vector-类型"><span class="nav-number">3.3.</span> <span class="nav-text">标准库 vector 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector-对象的定义和初始化"><span class="nav-number">3.3.1.</span> <span class="nav-text">vector 对象的定义和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector-对象的操作"><span class="nav-number">3.3.2.</span> <span class="nav-text">vector 对象的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器简介"><span class="nav-number">3.4.</span> <span class="nav-text">迭代器简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库-bitset-类型"><span class="nav-number">3.5.</span> <span class="nav-text">标准库 bitset 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bitset-对象的定义和初始化"><span class="nav-number">3.5.1.</span> <span class="nav-text">bitset 对象的定义和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitset-对象上的操作"><span class="nav-number">3.5.2.</span> <span class="nav-text">bitset 对象上的操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-数组和指针"><span class="nav-number">4.</span> <span class="nav-text">第四章 数组和指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">4.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的定义和初始化"><span class="nav-number">4.1.1.</span> <span class="nav-text">数组的定义和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组操作"><span class="nav-number">4.1.2.</span> <span class="nav-text">数组操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针的引入"><span class="nav-number">4.2.</span> <span class="nav-text">指针的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是指针"><span class="nav-number">4.2.1.</span> <span class="nav-text">什么是指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针的定义和初始化"><span class="nav-number">4.2.2.</span> <span class="nav-text">指针的定义和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针的操作"><span class="nav-number">4.2.3.</span> <span class="nav-text">指针的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用指针访问数组元素"><span class="nav-number">4.2.4.</span> <span class="nav-text">使用指针访问数组元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针和-const-限定符"><span class="nav-number">4.2.5.</span> <span class="nav-text">指针和 const 限定符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-风格字符串"><span class="nav-number">4.3.</span> <span class="nav-text">C 风格字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建动态数组"><span class="nav-number">4.3.1.</span> <span class="nav-text">创建动态数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新旧代码的兼容"><span class="nav-number">4.3.2.</span> <span class="nav-text">新旧代码的兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多维数组"><span class="nav-number">4.3.3.</span> <span class="nav-text">多维数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-表达式"><span class="nav-number">5.</span> <span class="nav-text">第五章 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算术操作符"><span class="nav-number">5.1.</span> <span class="nav-text">算术操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系操作符和逻辑操作符"><span class="nav-number">5.2.</span> <span class="nav-text">关系操作符和逻辑操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位操作符"><span class="nav-number">5.3.</span> <span class="nav-text">位操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bitset-对象或整型值的使用"><span class="nav-number">5.3.1.</span> <span class="nav-text">bitset 对象或整型值的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将移位操作符用于-IO"><span class="nav-number">5.3.2.</span> <span class="nav-text">将移位操作符用于 IO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值操作符"><span class="nav-number">5.4.</span> <span class="nav-text">赋值操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值操作的右结合性"><span class="nav-number">5.4.1.</span> <span class="nav-text">赋值操作的右结合性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值操作具有低优先级"><span class="nav-number">5.4.2.</span> <span class="nav-text">赋值操作具有低优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合赋值操作符"><span class="nav-number">5.4.3.</span> <span class="nav-text">复合赋值操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自增和自减操作符"><span class="nav-number">5.5.</span> <span class="nav-text">自增和自减操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#箭头操作符"><span class="nav-number">5.6.</span> <span class="nav-text">箭头操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件操作符"><span class="nav-number">5.7.</span> <span class="nav-text">条件操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof-操作符"><span class="nav-number">5.8.</span> <span class="nav-text">sizeof 操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逗号操作符"><span class="nav-number">5.9.</span> <span class="nav-text">逗号操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复合表达式的求值"><span class="nav-number">5.10.</span> <span class="nav-text">复合表达式的求值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级"><span class="nav-number">5.10.1.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结合性"><span class="nav-number">5.10.2.</span> <span class="nav-text">结合性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求值顺序"><span class="nav-number">5.10.3.</span> <span class="nav-text">求值顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-和-delete-表达式"><span class="nav-number">5.11.</span> <span class="nav-text">new 和 delete 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">5.12.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#何时发生隐式类型转换"><span class="nav-number">5.12.1.</span> <span class="nav-text">何时发生隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算术转换"><span class="nav-number">5.12.2.</span> <span class="nav-text">算术转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他隐式转换"><span class="nav-number">5.12.3.</span> <span class="nav-text">其他隐式转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式转换"><span class="nav-number">5.12.4.</span> <span class="nav-text">显式转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时需要强制类型转换"><span class="nav-number">5.12.5.</span> <span class="nav-text">何时需要强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名的强制类型转换"><span class="nav-number">5.12.6.</span> <span class="nav-text">命名的强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旧式强制类型转换"><span class="nav-number">5.12.7.</span> <span class="nav-text">旧式强制类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#语句"><span class="nav-number">6.</span> <span class="nav-text">语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单语句"><span class="nav-number">6.1.</span> <span class="nav-text">简单语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明语句"><span class="nav-number">6.2.</span> <span class="nav-text">声明语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复合语句"><span class="nav-number">6.3.</span> <span class="nav-text">复合语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语句作用域"><span class="nav-number">6.4.</span> <span class="nav-text">语句作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if-语句-1"><span class="nav-number">6.5.</span> <span class="nav-text">if 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-语句"><span class="nav-number">6.6.</span> <span class="nav-text">switch 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-switch"><span class="nav-number">6.6.1.</span> <span class="nav-text">使用 switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-中的控制流"><span class="nav-number">6.6.2.</span> <span class="nav-text">switch 中的控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#default-标号"><span class="nav-number">6.6.3.</span> <span class="nav-text">default 标号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-表达式与-case-标号"><span class="nav-number">6.6.4.</span> <span class="nav-text">switch 表达式与 case 标号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-内部的变量定义"><span class="nav-number">6.6.5.</span> <span class="nav-text">switch 内部的变量定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while-语句-1"><span class="nav-number">6.7.</span> <span class="nav-text">while 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-循环语句"><span class="nav-number">6.8.</span> <span class="nav-text">for 循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#省略-for-语句头的某些部分"><span class="nav-number">6.8.1.</span> <span class="nav-text">省略 for 语句头的某些部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-语句头中的多个定义"><span class="nav-number">6.8.2.</span> <span class="nav-text">for 语句头中的多个定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-while-语句"><span class="nav-number">6.9.</span> <span class="nav-text">do while 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break-语句"><span class="nav-number">6.10.</span> <span class="nav-text">break 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#continue-语句"><span class="nav-number">6.11.</span> <span class="nav-text">continue 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goto-语句"><span class="nav-number">6.12.</span> <span class="nav-text">goto 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-快和异常处理"><span class="nav-number">6.13.</span> <span class="nav-text">try 快和异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throw-表达式"><span class="nav-number">6.13.1.</span> <span class="nav-text">throw 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-块"><span class="nav-number">6.13.2.</span> <span class="nav-text">try 块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准异常"><span class="nav-number">6.13.3.</span> <span class="nav-text">标准异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用预处理器进行调试"><span class="nav-number">6.14.</span> <span class="nav-text">使用预处理器进行调试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-函数"><span class="nav-number">7.</span> <span class="nav-text">第七章 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的定义"><span class="nav-number">7.1.</span> <span class="nav-text">函数的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数返回类型"><span class="nav-number">7.1.1.</span> <span class="nav-text">函数返回类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数形参表"><span class="nav-number">7.1.2.</span> <span class="nav-text">函数形参表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数传递"><span class="nav-number">7.2.</span> <span class="nav-text">参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非引用形参"><span class="nav-number">7.2.1.</span> <span class="nav-text">非引用形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用形参"><span class="nav-number">7.2.2.</span> <span class="nav-text">引用形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector-和-其他容器类型-的形参"><span class="nav-number">7.2.3.</span> <span class="nav-text">vector 和 其他容器类型 的形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组-形参"><span class="nav-number">7.2.4.</span> <span class="nav-text">数组 形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递给函数的数组的处理"><span class="nav-number">7.2.5.</span> <span class="nav-text">传递给函数的数组的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main：-处理命令行选项"><span class="nav-number">7.2.6.</span> <span class="nav-text">main： 处理命令行选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#含有可变形参的函数"><span class="nav-number">7.2.7.</span> <span class="nav-text">含有可变形参的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#return-语句"><span class="nav-number">7.3.</span> <span class="nav-text">return 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#没有返回值的函数"><span class="nav-number">7.3.1.</span> <span class="nav-text">没有返回值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具有返回值的函数"><span class="nav-number">7.3.2.</span> <span class="nav-text">具有返回值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">7.3.3.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数声明"><span class="nav-number">7.4.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部对象"><span class="nav-number">7.5.</span> <span class="nav-text">局部对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动对象"><span class="nav-number">7.5.1.</span> <span class="nav-text">自动对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态局部对象"><span class="nav-number">7.5.2.</span> <span class="nav-text">静态局部对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联函数"><span class="nav-number">7.6.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的成员函数"><span class="nav-number">7.7.</span> <span class="nav-text">类的成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义成员函数的函数体"><span class="nav-number">7.7.1.</span> <span class="nav-text">定义成员函数的函数体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在类外定义成员函数"><span class="nav-number">7.7.2.</span> <span class="nav-text">在类外定义成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写-Sales-item-类的构造函数"><span class="nav-number">7.7.3.</span> <span class="nav-text">编写 Sales_item 类的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类代码文件的组织"><span class="nav-number">7.7.4.</span> <span class="nav-text">类代码文件的组织</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载函数"><span class="nav-number">7.8.</span> <span class="nav-text">重载函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重载与作用域"><span class="nav-number">7.8.1.</span> <span class="nav-text">重载与作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数匹配与实参转换"><span class="nav-number">7.8.2.</span> <span class="nav-text">函数匹配与实参转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载确定的三个步骤"><span class="nav-number">7.8.3.</span> <span class="nav-text">重载确定的三个步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实参类型转换"><span class="nav-number">7.8.4.</span> <span class="nav-text">实参类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指向函数的指针"><span class="nav-number">7.9.</span> <span class="nav-text">指向函数的指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章-标准-IO-库"><span class="nav-number">8.</span> <span class="nav-text">第八章 标准 IO 库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的标准库"><span class="nav-number">8.1.</span> <span class="nav-text">面向对象的标准库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件状态"><span class="nav-number">8.2.</span> <span class="nav-text">条件状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出缓冲区的管理"><span class="nav-number">8.3.</span> <span class="nav-text">输出缓冲区的管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的输入和输出"><span class="nav-number">8.4.</span> <span class="nav-text">文件的输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件流对象的使用"><span class="nav-number">8.4.1.</span> <span class="nav-text">文件流对象的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件模式"><span class="nav-number">8.4.2.</span> <span class="nav-text">文件模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个打开并检查输入文件的程序"><span class="nav-number">8.4.3.</span> <span class="nav-text">一个打开并检查输入文件的程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串流"><span class="nav-number">8.5.</span> <span class="nav-text">字符串流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-9-章-顺序容器"><span class="nav-number">9.</span> <span class="nav-text">第 9 章 顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序容器的定义"><span class="nav-number">9.1.</span> <span class="nav-text">顺序容器的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#容器元素的初始化"><span class="nav-number">9.1.1.</span> <span class="nav-text">容器元素的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器内元素的类型约束"><span class="nav-number">9.1.2.</span> <span class="nav-text">容器内元素的类型约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器和迭代器范围"><span class="nav-number">9.2.</span> <span class="nav-text">迭代器和迭代器范围</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器范围"><span class="nav-number">9.2.1.</span> <span class="nav-text">迭代器范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使迭代器失效的容器操作"><span class="nav-number">9.2.2.</span> <span class="nav-text">使迭代器失效的容器操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序容器的操作"><span class="nav-number">9.3.</span> <span class="nav-text">顺序容器的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#容器定义的类型别名"><span class="nav-number">9.3.1.</span> <span class="nav-text">容器定义的类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#begin-和-end-成员"><span class="nav-number">9.3.2.</span> <span class="nav-text">begin 和 end 成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在顺序容器中添加元素"><span class="nav-number">9.3.3.</span> <span class="nav-text">在顺序容器中添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系操作符"><span class="nav-number">9.3.4.</span> <span class="nav-text">关系操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器大小的操作"><span class="nav-number">9.3.5.</span> <span class="nav-text">容器大小的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问元素"><span class="nav-number">9.3.6.</span> <span class="nav-text">访问元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除元素"><span class="nav-number">9.3.7.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值与-swap"><span class="nav-number">9.3.8.</span> <span class="nav-text">赋值与 swap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-容器的自增长"><span class="nav-number">9.4.</span> <span class="nav-text">vector 容器的自增长</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器的选用"><span class="nav-number">9.5.</span> <span class="nav-text">容器的选用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再谈-string-类型"><span class="nav-number">9.6.</span> <span class="nav-text">再谈 string 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造-string-对象的其他方法"><span class="nav-number">9.6.1.</span> <span class="nav-text">构造 string 对象的其他方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改-string-对象的其他方法"><span class="nav-number">9.6.2.</span> <span class="nav-text">修改 string 对象的其他方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只适用于-string-类型的操作"><span class="nav-number">9.6.3.</span> <span class="nav-text">只适用于 string 类型的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-类型的查找操作"><span class="nav-number">9.6.4.</span> <span class="nav-text">string 类型的查找操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-对象的比较"><span class="nav-number">9.6.5.</span> <span class="nav-text">string 对象的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器适配器"><span class="nav-number">9.7.</span> <span class="nav-text">容器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈适配器"><span class="nav-number">9.7.1.</span> <span class="nav-text">栈适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列和优先级队列"><span class="nav-number">9.7.2.</span> <span class="nav-text">队列和优先级队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十章-关联容器"><span class="nav-number">10.</span> <span class="nav-text">第十章 关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言：pair-类型"><span class="nav-number">10.1.</span> <span class="nav-text">引言：pair 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关联容器"><span class="nav-number">10.2.</span> <span class="nav-text">关联容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-类型"><span class="nav-number">10.3.</span> <span class="nav-text">map 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-对象的定义"><span class="nav-number">10.3.1.</span> <span class="nav-text">map 对象的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-定义的类型"><span class="nav-number">10.3.2.</span> <span class="nav-text">map 定义的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给-map-添加元素"><span class="nav-number">10.3.3.</span> <span class="nav-text">给 map 添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用下标访问-map-对象"><span class="nav-number">10.3.4.</span> <span class="nav-text">使用下标访问 map 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-insert-的使用"><span class="nav-number">10.3.5.</span> <span class="nav-text">map::insert 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找并读取-map-中的元素"><span class="nav-number">10.3.6.</span> <span class="nav-text">查找并读取 map 中的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-map-对象中删除元素"><span class="nav-number">10.3.7.</span> <span class="nav-text">从 map 对象中删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-对象的迭代遍历"><span class="nav-number">10.3.8.</span> <span class="nav-text">map 对象的迭代遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单词转换-map-对象"><span class="nav-number">10.3.9.</span> <span class="nav-text">单词转换 map 对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-类型"><span class="nav-number">10.4.</span> <span class="nav-text">set 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set-容器的定义和使用"><span class="nav-number">10.4.1.</span> <span class="nav-text">set 容器的定义和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-单词排除-集"><span class="nav-number">10.4.2.</span> <span class="nav-text">创建 单词排除 集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multimap-和-multiset-类型"><span class="nav-number">10.5.</span> <span class="nav-text">multimap 和 multiset 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元素的添加和删除"><span class="nav-number">10.5.1.</span> <span class="nav-text">元素的添加和删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在-myltimap-和-multiset-中查找元素"><span class="nav-number">10.5.2.</span> <span class="nav-text">在 myltimap 和 multiset 中查找元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器的综合应用：文本查询程序"><span class="nav-number">10.6.</span> <span class="nav-text">容器的综合应用：文本查询程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查询程序的设计"><span class="nav-number">10.6.1.</span> <span class="nav-text">查询程序的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TextQuery-类"><span class="nav-number">10.6.2.</span> <span class="nav-text">TextQuery 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TextQuery-类的使用"><span class="nav-number">10.6.3.</span> <span class="nav-text">TextQuery 类的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写成员函数"><span class="nav-number">10.6.4.</span> <span class="nav-text">编写成员函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章-泛型算法"><span class="nav-number">11.</span> <span class="nav-text">第十一章 泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">11.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初窥算法"><span class="nav-number">11.2.</span> <span class="nav-text">初窥算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#只读算法"><span class="nav-number">11.2.1.</span> <span class="nav-text">只读算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写容器元素的算法"><span class="nav-number">11.2.2.</span> <span class="nav-text">写容器元素的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对容器元素重新排列的算法"><span class="nav-number">11.2.3.</span> <span class="nav-text">对容器元素重新排列的算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在谈迭代器"><span class="nav-number">11.3.</span> <span class="nav-text">在谈迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入迭代器"><span class="nav-number">11.3.1.</span> <span class="nav-text">插入迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iostream-迭代器"><span class="nav-number">11.3.2.</span> <span class="nav-text">iostream 迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反向迭代器"><span class="nav-number">11.3.3.</span> <span class="nav-text">反向迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-迭代器"><span class="nav-number">11.3.4.</span> <span class="nav-text">const 迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五种迭代器"><span class="nav-number">11.3.5.</span> <span class="nav-text">五种迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型算法结构"><span class="nav-number">11.4.</span> <span class="nav-text">泛型算法结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法的形参模式"><span class="nav-number">11.4.1.</span> <span class="nav-text">算法的形参模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法的命名规范"><span class="nav-number">11.4.2.</span> <span class="nav-text">算法的命名规范</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器特有算法"><span class="nav-number">11.5.</span> <span class="nav-text">容器特有算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十二章-类"><span class="nav-number">12.</span> <span class="nav-text">第十二章 类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类的定义和声明"><span class="nav-number">12.1.</span> <span class="nav-text">类的定义和声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类定义：扼要重述"><span class="nav-number">12.1.1.</span> <span class="nav-text">类定义：扼要重述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据抽象和封装"><span class="nav-number">12.1.2.</span> <span class="nav-text">数据抽象和封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于类定义的更多内容"><span class="nav-number">12.1.3.</span> <span class="nav-text">关于类定义的更多内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类声明和类定义"><span class="nav-number">12.1.4.</span> <span class="nav-text">类声明和类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类对象"><span class="nav-number">12.1.5.</span> <span class="nav-text">类对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐含的-this-指针"><span class="nav-number">12.2.</span> <span class="nav-text">隐含的 this 指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的作用域"><span class="nav-number">12.3.</span> <span class="nav-text">类的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">12.4.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数初始化"><span class="nav-number">12.4.1.</span> <span class="nav-text">构造函数初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认实参予构造函数"><span class="nav-number">12.4.2.</span> <span class="nav-text">默认实参予构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认构造函数"><span class="nav-number">12.4.3.</span> <span class="nav-text">默认构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式类类型转换"><span class="nav-number">12.4.4.</span> <span class="nav-text">隐式类类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类成员的显式初始化"><span class="nav-number">12.4.5.</span> <span class="nav-text">类成员的显式初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#友元"><span class="nav-number">12.5.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-类成员"><span class="nav-number">12.6.</span> <span class="nav-text">static 类成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static-成员函数"><span class="nav-number">12.6.1.</span> <span class="nav-text">static 成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-数据成员"><span class="nav-number">12.6.2.</span> <span class="nav-text">static 数据成员</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十三章-复制控制"><span class="nav-number">13.</span> <span class="nav-text">第十三章 复制控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复制构造函数"><span class="nav-number">13.1.</span> <span class="nav-text">复制构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#合成的复制构造函数"><span class="nav-number">13.1.1.</span> <span class="nav-text">合成的复制构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义自己的复制构造函数"><span class="nav-number">13.1.2.</span> <span class="nav-text">定义自己的复制构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#禁止复制"><span class="nav-number">13.1.3.</span> <span class="nav-text">禁止复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值操作符-1"><span class="nav-number">13.2.</span> <span class="nav-text">赋值操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#析构函数"><span class="nav-number">13.3.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息处理示例"><span class="nav-number">13.4.</span> <span class="nav-text">消息处理示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理指针成员"><span class="nav-number">13.5.</span> <span class="nav-text">管理指针成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义智能指针类"><span class="nav-number">13.5.1.</span> <span class="nav-text">定义智能指针类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义值型类"><span class="nav-number">13.5.2.</span> <span class="nav-text">定义值型类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十四章-重载操作符与转换"><span class="nav-number">14.</span> <span class="nav-text">第十四章 重载操作符与转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十五章-面向对象编程"><span class="nav-number">15.</span> <span class="nav-text">第十五章 面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程：概述"><span class="nav-number">15.1.</span> <span class="nav-text">面向对象编程：概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义基类和派生类"><span class="nav-number">15.2.</span> <span class="nav-text">定义基类和派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义基类"><span class="nav-number">15.2.1.</span> <span class="nav-text">定义基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-成员"><span class="nav-number">15.2.2.</span> <span class="nav-text">protected 成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类"><span class="nav-number">15.2.3.</span> <span class="nav-text">派生类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual-与其他成员函数"><span class="nav-number">15.2.4.</span> <span class="nav-text">virtual 与其他成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公用，私有和受保护的继承"><span class="nav-number">15.2.5.</span> <span class="nav-text">公用，私有和受保护的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#友元关系与继承"><span class="nav-number">15.2.6.</span> <span class="nav-text">友元关系与继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承与静态成员"><span class="nav-number">15.2.7.</span> <span class="nav-text">继承与静态成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转换与继承"><span class="nav-number">15.3.</span> <span class="nav-text">转换与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类到基类的转换"><span class="nav-number">15.3.1.</span> <span class="nav-text">派生类到基类的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基类到派生类的转换"><span class="nav-number">15.3.2.</span> <span class="nav-text">基类到派生类的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数和复制控制"><span class="nav-number">15.4.</span> <span class="nav-text">构造函数和复制控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基类构造函数和复制控制"><span class="nav-number">15.4.1.</span> <span class="nav-text">基类构造函数和复制控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类构造函数"><span class="nav-number">15.4.2.</span> <span class="nav-text">派生类构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制控制和继承"><span class="nav-number">15.4.3.</span> <span class="nav-text">复制控制和继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚析构函数"><span class="nav-number">15.4.4.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数和析构函数中的虚函数"><span class="nav-number">15.4.5.</span> <span class="nav-text">构造函数和析构函数中的虚函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承情况下的类作用域"><span class="nav-number">15.5.</span> <span class="nav-text">继承情况下的类作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#名字查找在编译时发生"><span class="nav-number">15.5.1.</span> <span class="nav-text">名字查找在编译时发生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名字冲突与继承"><span class="nav-number">15.5.2.</span> <span class="nav-text">名字冲突与继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域与成员函数"><span class="nav-number">15.5.3.</span> <span class="nav-text">作用域与成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数与作用域"><span class="nav-number">15.5.4.</span> <span class="nav-text">虚函数与作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纯虚函数"><span class="nav-number">15.6.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器与继承"><span class="nav-number">15.7.</span> <span class="nav-text">容器与继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#句柄类与继承"><span class="nav-number">15.8.</span> <span class="nav-text">句柄类与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针型句柄"><span class="nav-number">15.8.1.</span> <span class="nav-text">指针型句柄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制未知类型"><span class="nav-number">15.8.2.</span> <span class="nav-text">复制未知类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#句柄的使用"><span class="nav-number">15.8.3.</span> <span class="nav-text">句柄的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再谈文本查询示例"><span class="nav-number">15.9.</span> <span class="nav-text">再谈文本查询示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象的解决方案"><span class="nav-number">15.9.1.</span> <span class="nav-text">面向对象的解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值型句柄"><span class="nav-number">15.9.2.</span> <span class="nav-text">值型句柄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Query-base-类"><span class="nav-number">15.9.3.</span> <span class="nav-text">Query_base 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Query-句柄类"><span class="nav-number">15.9.4.</span> <span class="nav-text">Query 句柄类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类-1"><span class="nav-number">15.9.5.</span> <span class="nav-text">派生类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eval-函数"><span class="nav-number">15.9.6.</span> <span class="nav-text">eval 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十六章-模版与泛型编程"><span class="nav-number">16.</span> <span class="nav-text">第十六章 模版与泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模版定义"><span class="nav-number">16.1.</span> <span class="nav-text">模版定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义函数模版"><span class="nav-number">16.1.1.</span> <span class="nav-text">定义函数模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义类模版"><span class="nav-number">16.1.2.</span> <span class="nav-text">定义类模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模版类型形参"><span class="nav-number">16.1.3.</span> <span class="nav-text">模版类型形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写泛型程序"><span class="nav-number">16.1.4.</span> <span class="nav-text">编写泛型程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例化"><span class="nav-number">16.2.</span> <span class="nav-text">实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模版实参推断"><span class="nav-number">16.2.1.</span> <span class="nav-text">模版实参推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数模版的显式实参"><span class="nav-number">16.2.2.</span> <span class="nav-text">函数模版的显式实参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模版编译模型"><span class="nav-number">16.3.</span> <span class="nav-text">模版编译模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类模版成员"><span class="nav-number">16.4.</span> <span class="nav-text">类模版成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类模版成员函数"><span class="nav-number">16.4.1.</span> <span class="nav-text">类模版成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非类型形参的模版实参"><span class="nav-number">16.4.2.</span> <span class="nav-text">非类型形参的模版实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模版中的友元声明"><span class="nav-number">16.4.3.</span> <span class="nav-text">类模版中的友元声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-和-QueueItem-的友元声明"><span class="nav-number">16.4.4.</span> <span class="nav-text">Queue 和 QueueItem 的友元声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员模版"><span class="nav-number">16.4.5.</span> <span class="nav-text">成员模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整的-Queue-类"><span class="nav-number">16.4.6.</span> <span class="nav-text">完整的 Queue 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模版的-static-成员"><span class="nav-number">16.4.7.</span> <span class="nav-text">类模版的 static 成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个泛型句柄类"><span class="nav-number">16.5.</span> <span class="nav-text">一个泛型句柄类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义句柄类"><span class="nav-number">16.5.1.</span> <span class="nav-text">定义句柄类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用句柄"><span class="nav-number">16.5.2.</span> <span class="nav-text">使用句柄</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模版特化"><span class="nav-number">16.6.</span> <span class="nav-text">模版特化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数模版的特化"><span class="nav-number">16.6.1.</span> <span class="nav-text">函数模版的特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模版的特化"><span class="nav-number">16.6.2.</span> <span class="nav-text">类模版的特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特化成员而不特化类"><span class="nav-number">16.6.3.</span> <span class="nav-text">特化成员而不特化类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模版的部分特化"><span class="nav-number">16.6.4.</span> <span class="nav-text">类模版的部分特化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载与函数模版"><span class="nav-number">16.7.</span> <span class="nav-text">重载与函数模版</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十七章-用于大型程序的工具"><span class="nav-number">17.</span> <span class="nav-text">第十七章 用于大型程序的工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number">17.1.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间"><span class="nav-number">17.2.</span> <span class="nav-text">命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间的定义"><span class="nav-number">17.2.1.</span> <span class="nav-text">命名空间的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套命名空间"><span class="nav-number">17.2.2.</span> <span class="nav-text">嵌套命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未命名的命名空间"><span class="nav-number">17.2.3.</span> <span class="nav-text">未命名的命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间成员的使用"><span class="nav-number">17.2.4.</span> <span class="nav-text">命名空间成员的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类，命名空间和作用域"><span class="nav-number">17.2.5.</span> <span class="nav-text">类，命名空间和作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载与命名空间"><span class="nav-number">17.2.6.</span> <span class="nav-text">重载与命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间与模版"><span class="nav-number">17.2.7.</span> <span class="nav-text">命名空间与模版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承与虚继承"><span class="nav-number">17.3.</span> <span class="nav-text">多重继承与虚继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-number">17.3.1.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换与多个基类"><span class="nav-number">17.3.2.</span> <span class="nav-text">转换与多个基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承派生类的复制控制"><span class="nav-number">17.3.3.</span> <span class="nav-text">多重继承派生类的复制控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承下的类作用域"><span class="nav-number">17.3.4.</span> <span class="nav-text">多重继承下的类作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚继承"><span class="nav-number">17.3.5.</span> <span class="nav-text">虚继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚基类的声明"><span class="nav-number">17.3.6.</span> <span class="nav-text">虚基类的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊的初始化语义"><span class="nav-number">17.3.7.</span> <span class="nav-text">特殊的初始化语义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特殊工具与技术"><span class="nav-number">18.</span> <span class="nav-text">特殊工具与技术</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Double</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
