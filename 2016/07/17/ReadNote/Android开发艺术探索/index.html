<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="读书笔记,Android开发艺术探秘,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="Activity 的生命周期和启动模式Activity 生命周期分为两个部分:  典型情况:正常使用过程中Activity的生命周期的改变. 异常情况:Activity被系统回收,设备的Configuration发生改变.  典型情况的Activity生命周期七个生命周期  onCreate():布局初始化,数据加载 onRestart():在onStop()–&amp;gt;onStart() onSt">
<meta name="keywords" content="读书笔记,Android开发艺术探秘">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 开发艺术探秘">
<meta property="og:url" content="http://yoursite.com/2016/07/17/ReadNote/Android开发艺术探索/index.html">
<meta property="og:site_name" content="Double">
<meta property="og:description" content="Activity 的生命周期和启动模式Activity 生命周期分为两个部分:  典型情况:正常使用过程中Activity的生命周期的改变. 异常情况:Activity被系统回收,设备的Configuration发生改变.  典型情况的Activity生命周期七个生命周期  onCreate():布局初始化,数据加载 onRestart():在onStop()–&amp;gt;onStart() onSt">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-08-12T14:50:57.330Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 开发艺术探秘">
<meta name="twitter:description" content="Activity 的生命周期和启动模式Activity 生命周期分为两个部分:  典型情况:正常使用过程中Activity的生命周期的改变. 异常情况:Activity被系统回收,设备的Configuration发生改变.  典型情况的Activity生命周期七个生命周期  onCreate():布局初始化,数据加载 onRestart():在onStop()–&amp;gt;onStart() onSt">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/07/17/ReadNote/Android开发艺术探索/">





  <title>Android 开发艺术探秘 | Double</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Double</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/17/ReadNote/Android开发艺术探索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android 开发艺术探秘</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-17T13:18:12+08:00">
                2016-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Activity-的生命周期和启动模式"><a href="#Activity-的生命周期和启动模式" class="headerlink" title="Activity 的生命周期和启动模式"></a>Activity 的生命周期和启动模式</h1><p>Activity 生命周期分为两个部分:</p>
<ol>
<li>典型情况:正常使用过程中Activity的生命周期的改变.</li>
<li>异常情况:Activity被系统回收,设备的Configuration发生改变.</li>
</ol>
<h2 id="典型情况的Activity生命周期"><a href="#典型情况的Activity生命周期" class="headerlink" title="典型情况的Activity生命周期"></a>典型情况的Activity生命周期</h2><p>七个生命周期</p>
<ol>
<li><code>onCreate()</code>:布局初始化,数据加载</li>
<li><code>onRestart()</code>:在<code>onStop()</code>–&gt;<code>onStart()</code></li>
<li><code>onStart()</code>:activity还在后台</li>
<li><code>onResume()</code>:activity出现在前台,可以和用户进行交互</li>
<li><code>onPause()</code>:activity在前台, 不宜进行大量的耗时操作</li>
<li><code>onStop()</code>:activity回到后台</li>
<li><code>onDestroy()</code>:activity被销毁</li>
</ol>
<a id="more"></a>
<p>注意:</p>
<ol>
<li>如果<code>Activity</code>使用了透明主题,那么,在<code>Activity</code>回到后台的时候<code>onStop()</code>不会被调用.</li>
<li><p>在<code>Activity A</code>跳转到<code>ActivityB</code>的时候:</p>
<ul>
<li>Activity A’s onPause() method executes.</li>
<li>Activity B’s onCreate(), onStart(), and onResume() methods execute in sequence. (Activity B now has user focus.)</li>
<li><p>Then, if Activity A is no longer visible on screen, its onStop() method executes.</p>
<p>所以:如果在A中做数据处理,B中马上要使用到的话,就需要在A中的<code>onPause()</code>保存数据,这样B就能获取到最新的数据.</p>
</li>
</ul>
</li>
</ol>
<h2 id="异常情况的生命周期"><a href="#异常情况的生命周期" class="headerlink" title="异常情况的生命周期"></a>异常情况的生命周期</h2><h3 id="资源相关的系统配置发生改变导致Activity被杀死重新创建"><a href="#资源相关的系统配置发生改变导致Activity被杀死重新创建" class="headerlink" title="资源相关的系统配置发生改变导致Activity被杀死重新创建"></a>资源相关的系统配置发生改变导致Activity被杀死重新创建</h3><p>Android中系统配置改变的时候,Android会根据系统配置加载不同的资源,所以系统配置改变的时候需要重新创建<code>Activity</code>;</p>
<p>使用到的两个关键方法:</p>
<ol>
<li><code>onSaveInstanceState()</code>:调用时机在<code>onStop()</code>之前</li>
<li><code>onRestoreInstanceState()</code>or<code>onCreate()</code>:这两个方法都可以用来恢复现场</li>
</ol>
<p><strong><em>如何保证Activity不受系统配置影响:</em></strong></p>
<p>可以在<code>Activity</code>对应的清单文件标签中添加属性:</p>
<pre><code>android:configChanges=&quot;orientation|screenSize&quot;
</code></pre><p>这样在屏幕旋转的时候就不会执行销毁Activity,会执行<code>onConfigurationChanged</code>方法</p>
<h2 id="资源内存不足导致低优先级的Activity被杀死"><a href="#资源内存不足导致低优先级的Activity被杀死" class="headerlink" title="资源内存不足导致低优先级的Activity被杀死"></a>资源内存不足导致低优先级的Activity被杀死</h2><p>Activity优先级有高到低:</p>
<ol>
<li>前台可见,和用户正常交互</li>
<li>可见,非前台,处在<code>onPause()</code></li>
<li>后台Activity,<code>onStop()</code></li>
</ol>
<p>在<code>Activity</code>被销毁的时候会执行数据保存方法:<code>onSaveInstanceState()</code></p>
<h2 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h2><p>Android 中使用任务栈来管理<code>Activity</code></p>
<ul>
<li>standard: 谁启动这个<code>Activity</code>,它就会在启动它的<code>Context</code>所处的栈中创建实例,<em>注意:</em>当我们使用<code>ApplicationContext</code>去启动<code>Activity</code>的时候会报错,因为<code>ApplicationContext</code>没有任务栈,这时候就需要<code>FLAG_ACTIVITY_NEW_TASK</code>(非<code>Activity</code>类型的<code>Context</code>没有所谓的任务栈).</li>
<li>singleTop:onNewIntent</li>
<li>singleTask:栈内复用,onNewIntent, <em>注意:</em><code>Activity</code>会在自己想要的任务栈(此<code>Activity</code>也只会在这个任务栈中出现)内实现复用</li>
<li>singleInstance:单实例模式,singleTask的加强版,单独占有一个任务栈,并且只有一个<code>Activity</code>实例</li>
</ul>
<p>任务栈: 1. 前台任务栈 2. 后台任务栈(<code>Activity</code>处于暂停状态)</p>
<h3 id="TaskAffinity"><a href="#TaskAffinity" class="headerlink" title="TaskAffinity"></a>TaskAffinity</h3><p>通过给<code>Activity</code>设置这个参数来设定<code>Activity</code>所在的任务栈,<code>Activity</code>默认的任务栈名是包名.</p>
<p>使用:</p>
<ol>
<li>和<code>singleTask</code>配对使用:让<code>Acitivity</code>运行在指定的任务栈中.</li>
<li>和<code>allowTaskReparenting</code>属性配对使用</li>
</ol>
<h3 id="给Activity指定启动模式"><a href="#给Activity指定启动模式" class="headerlink" title="给Activity指定启动模式"></a>给Activity指定启动模式</h3><ol>
<li><p>清单文件设置</p>
<pre><code>android:launchMode = &quot;...&quot;
</code></pre></li>
<li><p>代码设置:</p>
<pre><code>intent.addFrags(...)
</code></pre></li>
</ol>
<p>上面两中方式可以同时使用,第二种方法的优先级高.</p>
<p>上面两中方法的可设置范围不同:第一种方法无法设置<code>FLAG_ACTIVITY_CLEAR_TOP</code>; 第二种方法无法设置<code>singleInstance</code></p>
<h3 id="一个命令"><a href="#一个命令" class="headerlink" title="一个命令"></a>一个命令</h3><pre><code>adb shell dumpsys activity
</code></pre><h3 id="Activity-Flags"><a href="#Activity-Flags" class="headerlink" title="Activity Flags"></a>Activity Flags</h3><p>标记位</p>
<p>作用:</p>
<ol>
<li>启动模式</li>
<li>影响<code>Activity</code>运行状态</li>
</ol>
<p><code>FLAG_ACTIVITY_SINGLE_TOP</code>:在这个<code>Activity</code>的任务栈中在它前面的<code>Activity</code>都会出栈,singleTask</p>
<p><code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</code>:和<code>android:excludeFromRecents=&quot;true&quot;</code>一样的效果, 适用于应用的扉页</p>
<h2 id="IntentFilter-的匹配规则"><a href="#IntentFilter-的匹配规则" class="headerlink" title="IntentFilter 的匹配规则"></a>IntentFilter 的匹配规则</h2><p>启动Android四大组件的方式: 1. 显示启动; 2. 隐式启动.</p>
<p>隐式启动的时候<code>Intent</code>回去匹配目标组件定义的<code>IntentFliter</code>中所设置的过滤信息,匹配成功就会启动.</p>
<p>过滤信息:</p>
<ol>
<li>action</li>
<li>category</li>
<li>data</li>
</ol>
<p><strong><em>注意:</em></strong>1. 一个过滤列表中的action,category,data可以有多个. 2. 只有一个Intent同时匹配action,category,data才算完全匹配,完全匹配才能启动目标组件.3. 一个<code>Activity</code>可以同时设置多个<code>intent-filter</code></p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>是字符串,区分大小写(category不区分大小写)</p>
<p>一个过滤规则中可以有多个<code>action</code>,<code>Intent</code>只需要匹配其中的一个<code>action</code>就可以.</p>
<h3 id="category"><a href="#category" class="headerlink" title="category"></a>category</h3><p>匹配机制: 要求如果<code>Intent</code>中如果设置了<code>category</code>那么设置的<code>category</code>必须和过滤规则中的其中一个<code>category</code>相同.</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>由两部分组成: 1. mimeType 2. URI</p>
<p>uri结构:</p>
<pre><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]
</code></pre><ul>
<li>scheme: url模式</li>
<li>host:主机名</li>
<li>port:端口号</li>
<li>path,pathPattern,pathPrefix:路径信息</li>
</ul>
<p>匹配其中一组data即可</p>
<p>过滤规则:</p>
<ol>
<li><p>如果<code>intent-filter</code>中设置了<code>mimeType</code>,没有设置<code>url</code>:那么uri默认为:content或者file;</p>
<pre><code>intent.setDataAndType(Uri.parse(&quot;file://abc&quot;, &quot;image/png&quot;));
</code></pre><p> <strong><em>注意:</em></strong>必须使用<code>setDataAndType()</code>方法来同时设置type和uri,如果分别调用<code>setData</code>,<code>setType</code>会互相消除设置(查看源码可知)</p>
</li>
</ol>
<p>判断隐身启动是否能成功: </p>
<ol>
<li><code>PackageManager</code>或者<code>Intent</code>的<code>resolveActivity</code>方法</li>
<li><p><code>PackageManager</code>:<code>queryIntentActivities</code></p>
<pre><code>public abstract List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent, int flags);
public abstract ResolveInfo resolveActivity(Intent intent, int flags);
</code></pre><p> 参数二:<code>MATCH_DEFAULT_ONLY</code>:不包含<code>DEFAULT</code>的category的Activity不支持隐式启动.</p>
</li>
</ol>
<h1 id="IPC-进程"><a href="#IPC-进程" class="headerlink" title="IPC 进程"></a>IPC 进程</h1><p>IPC：Inter-Process Communication 进程间通讯</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>线程：CPU调度最小单元</p>
<p>进程：一个执行单元，在PC或者移动设备中就是一个程序或者应用， 一个进程中包含对个线程</p>
<p>ANR：Application Not Responding 应用无响应，Android中的UI线程阻塞导致</p>
<h2 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h2><p>开启多进程模式：给四大组件指定<code>android:process</code>属性</p>
<h3 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h3><p>这里探讨：一个应用内的多进程的情况。</p>
<p>开启多进程方式：</p>
<ol>
<li>设置属性：<code>android:process=&quot;...进程名&quot;</code></li>
<li>通过jni在native层fork一个新的进程（非常规）</li>
</ol>
<p>在Android应用开启的时候系统自动分配的进程名就是应用的包名。</p>
<p>进程名自定义命名的方式：</p>
<ol>
<li><code>:</code>+名称：这种命名方式，系统默认在<code>：</code>前面加上当前应用的包名，属于应用的私有进程。例如：<code>android:process=&quot;:remote</code></li>
<li>普通命名：这种命名方式创建的线程属于全局进程，其他的应用可以通过ShareUID方式和它跑在同一个进程中。例如：<code>android:process=&quot;com.ryg.chapter_2.remote&quot;</code></li>
</ol>
<p>Android系统会给每一个应用分配唯一的UID，具有相同UID的应用才能共享数据。</p>
<p>两个应用通过ShareUID跑在同一进程需要：</p>
<ol>
<li>相同的ShareUID</li>
<li>签名相同</li>
</ol>
<h3 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h3><p>Android为每个进程分配独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间。</p>
<p>当两个进程访问同一个类的时候，会创建多个副本。</p>
<p>多进程可能导致的问题：</p>
<ol>
<li>静态成员和单例模式完全失效：多个副本，内存分配区域不同</li>
<li>线程同步机制完全失效</li>
<li>SharedPreferences的可靠性下降：可能会并发读写</li>
<li>Application会多次创建：开启进程相当与开启两个应用</li>
</ol>
<h2 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h2><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>Java所提供的序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。</p>
<p>使用：实现接口并定义标识（非必须）即可。</p>
<p>实现这个接口的对象就可以固话到本地了。（通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>）</p>
<p><code>serialVersionUID</code>作用：保证序列化的类版本和当前类的版本相同，防止类被更改了。</p>
<h3 id="Parcelable-接口"><a href="#Parcelable-接口" class="headerlink" title="Parcelable 接口"></a>Parcelable 接口</h3><p>Android中推出的序列化方法。</p>
<p>效率高，主要用在内存序列化上。</p>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>是Android中的一个类，实现了IBinder的接口。</p>
<p>是Android中跨进程通信的一种方式。</p>
<p>从Android Framework角度来说，是ServiceManager连接各种Manager（ActivityManager，WindowManager等）和相应的ManagerService的桥梁。</p>
<p>从Android应用层来说：Binder是客户端和服务端通讯的媒介，bindService的时候，会获得一个Binder对象，通过这个对象获得服务或者数据。</p>
<p>…..</p>
<h2 id="Android-中的-IPC-方式"><a href="#Android-中的-IPC-方式" class="headerlink" title="Android 中的 IPC 方式"></a>Android 中的 IPC 方式</h2><h3 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h3><p>使用Bundle在Intent中传递数据. Bundle实现了序列化, 所以在使用Intent启动其他进程的四大组件的时候可以传递数据.</p>
<h3 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h3><p>两个进程读写同一个文件.</p>
<p><strong><em>注意:</em></strong>避免并发读写,在数据同步要求不高的进程通讯使用. <code>SharedPreferences</code>是Android提供的轻量级存储方案,系统对它的读写有一定的缓存策略所以不适和在进程间通讯.</p>
<h3 id="使用-Messenger"><a href="#使用-Messenger" class="headerlink" title="使用 Messenger"></a>使用 Messenger</h3><p>通过Messenger传递 Message对象</p>
<p>底层实现是AIDL</p>
<h4 id="Messenger-的两中构造方法-重要"><a href="#Messenger-的两中构造方法-重要" class="headerlink" title="Messenger 的两中构造方法 (重要)"></a>Messenger 的两中构造方法 (重要)</h4><pre><code>public Messenger(Handler target){
    mTarger = target.getImessager();    
}

public Messenger(IBinder target){
    mTarget = IMessenger.Stub.asInterface(target);
}
</code></pre><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端:"></a>服务端:</h4><ol>
<li>创建一个<code>Service</code>并在清单文件中设置属性<code>android:process=&quot;:remote&quot;</code>让其在进程中执行</li>
<li>创建一个<code>Handler</code>的继承类<code>MessengerHandler</code>,作为进程通讯的信息处理类</li>
<li>在<code>Service</code>中创建<code>Messenger</code>对象<code>mMessenger</code>构造参数为<code>new MessengerHandler()</code></li>
<li>在<code>Service</code>的<code>onBind()</code>方法中返回<code>mMessenger.getBinder()</code></li>
</ol>
<p>服务端给客户端发消息:上面实现了客户端–&gt;服务端的通讯在上面的基础上:</p>
<ol>
<li>在<code>MessengerHandler</code>类中的<code>handleMessage()</code>方法中 ,在接收到客户端信息的<code>Message</code>对象通过:<code>Messenger client = msg.replyTo;</code> 方法获得从 服务端–&gt;客户端的<code>Messenger</code> <strong><em>注意</em></strong>:这里的replyTo对象需要在客户端设置</li>
<li>通过<code>Messenger</code> client 发送<code>Message</code>对象</li>
</ol>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ol>
<li><code>bindService()</code>:绑定服务端的<code>Service</code>,在Serice<code>ServiceConnection</code>接口中通过<code>Ibinder</code>创建<code>Messenger</code>对象,(<code>mMessenger = new Messenger(service)</code>);</li>
<li>通过<code>mMessenger</code>发送的<code>Message</code>就能到达在服务端定义的<code>MessengerHandler</code>中</li>
</ol>
<p>接受从服务端发来的消息:</p>
<ol>
<li>创建相应的<code>Handler</code>继承类: <code>MessengerHandler</code></li>
<li>通过<code>Handler</code>继承类创建<code>Messenger</code>:<code>private Messenger mGetReplyMessenger = new Messenger(new MessengerHandler())</code></li>
<li>设置<code>replyTo</code>对象:<code>msg = mGetReplyMessenger;</code>这样在服务端就能获得到从 服务端–&gt;客户端的<code>Messenger</code></li>
</ol>
<p>注:</p>
<ol>
<li>客户端–&gt;服务端通讯:需要在客户端获取 服务端创建的<code>Messenger</code>且用来创建<code>Messenger</code>对象的<code>Handler</code>在服务端: 传递方式是<code>bindService()</code></li>
<li>服务端–&gt;客户端通讯:需要在服务端获取 客户端创建的<code>Messenger</code>且用来创建<code>Messenger</code>对象的<code>Handler</code>在客户端: 传递方式是<code>msg.replyTo</code></li>
</ol>
<h3 id="使用-AIDL"><a href="#使用-AIDL" class="headerlink" title="使用 AIDL"></a>使用 AIDL</h3><p>Messenger是以串行的方式处理客户端发来的消息,如果大量的消息同时发送到服务器,服务端只能一个一个处理,不适合并发请求.</p>
<p>Messenger的主要功能是传递消息.</p>
<p>如果需要跨进程调用方法就需要AIDL.</p>
<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><ol>
<li>创建一个<code>Service</code>监听客户端的连接请求</li>
<li>创建AIDL文件,暴露接口给客户端:使用Android studio 自动生成AIDL文件<code>IBookManager</code>接口,在这里定义需要的方法, </li>
<li>在正常工程中创建接口的实现<code>BookBinder extends IBookManager.Stub</code>,实现里面的方法</li>
<li>在<code>Service</code>的<code>onBind()</code>方法中返回3中创建的类的对象<code>mBookBinder</code></li>
</ol>
<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><ol>
<li>绑定服务端的<code>Service</code></li>
<li>将<code>Binder</code>对象转成<code>AIDL</code>接口所属的类型(<code>mIBookManager = IBookManager.Stub.asInterface(service);</code>),然后就可以调用里面的方法了</li>
</ol>
<h4 id="传递自定义的对象"><a href="#传递自定义的对象" class="headerlink" title="传递自定义的对象"></a>传递自定义的对象</h4><ol>
<li><p>在服务端aidl包中创建<code>Book.java</code>和<code>Book.aidl</code></p>
<p> //  Book.aidl<br> parcelable Book;</p>
<p> // Book.java<br> // 和普通类的代码一样,不过需要实现parcelable接口</p>
</li>
<li><p>在aidl接口文件中导入<code>Book</code></p>
</li>
</ol>
<h4 id="观察者模式监听服务器变化"><a href="#观察者模式监听服务器变化" class="headerlink" title="观察者模式监听服务器变化"></a>观察者模式监听服务器变化</h4><p>P77-P90</p>
<h3 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h3><p>和Messenger一样,底层实现是Binder</p>
<h3 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h3><h2 id="Binder-连接池"><a href="#Binder-连接池" class="headerlink" title="Binder 连接池"></a>Binder 连接池</h2><p>作用:将每个业务模块的Binder请求统一转发到远程<code>Service</code>中执行.避免重复创建<code>Service</code>的过程.</p>
<p>在项目中有多个地方使用到AIDL,创建了多个AIDL接口的时候,再多创建一个AIDL接口用来管理所有的AIDL接口类,通过一个接口获取其他所有的AIDL接口</p>
<h2 id="选择合适的IPC方式"><a href="#选择合适的IPC方式" class="headerlink" title="选择合适的IPC方式"></a>选择合适的IPC方式</h2><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td>简单易用</td>
<td>自能传输Bundle支持的数据类型</td>
<td>适合四大组件的进程间通讯</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发,无法做到进程间即时通讯</td>
<td>无并发.交换简单的数据实时性不高</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大.一对多,实时通讯</td>
<td>使用复杂需要处理号线程同步</td>
<td>一对多通讯,有ＲＰＣ需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>功能一般，一对多的串行通讯．实时｜不支持RPC</td>
<td>无RPC需求,低并发的一对多通讯</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>分享存储在数据库中的数据</td>
<td>可以理解为受约束的AIDL,提供数据源的CRUD操作</td>
<td>一对多的数据共享</td>
</tr>
<tr>
<td>Socket</td>
<td>功能强大</td>
<td>不支持RPC,细节处理繁琐</td>
<td>网络数据交换</td>
</tr>
</tbody>
</table>
<h1 id="View-的事件体系"><a href="#View-的事件体系" class="headerlink" title="View 的事件体系"></a>View 的事件体系</h1><h2 id="View的基础知识"><a href="#View的基础知识" class="headerlink" title="View的基础知识"></a>View的基础知识</h2><h3 id="什么是View"><a href="#什么是View" class="headerlink" title="什么是View"></a>什么是View</h3><p>Android中所有控件的基类.</p>
<h3 id="View-的位置信息"><a href="#View-的位置信息" class="headerlink" title="View 的位置信息"></a>View 的位置信息</h3><p>由它的四个顶点来决定对应View的四个属性: mLeft,mTop,mRight,mBottom</p>
<p><strong><em>注意:</em></strong>上面四个属性的值都是相对与View的父容器来说的.</p>
<p>View的宽高:</p>
<pre><code>width = mRight - mLeft;
height = mBottom - mTop;
</code></pre><p>这四个属性都是<code>protected</code>,通过相应的<code>getter</code>方法来获取四个位置属性.</p>
<p>Android 3.0 后引入另外几个参数: x,y,translationX,translationY;</p>
<p>x,y:表示View左上角坐标</p>
<p>translationX,translationY:View相对父容器的偏移量</p>
<pre><code>x = mLeft + translationX;
y = mTop + translationY;
</code></pre><p><strong>注意:</strong>View滑动的时候 top和left没有变,变的是translationX,translationY,x,y</p>
<h3 id="MotionEvent-和-TouchSlop"><a href="#MotionEvent-和-TouchSlop" class="headerlink" title="MotionEvent 和 TouchSlop"></a>MotionEvent 和 TouchSlop</h3><p>MotionEvent:在手指触摸屏幕后发生的一系列事件:</p>
<ul>
<li>ACTION_DOWN:手指刚接触屏幕</li>
<li>ACTION_MOVE:手指在屏幕上移动</li>
<li>ACTION_UP:手指离开屏幕的瞬间</li>
</ul>
<p>通过MotionEvent对象可以获得手指的x和y坐标: 系统提供了两组方法: <code>getX/getY</code> , <code>getRawX/getRawY</code>(一个获取到的坐标是相对当前View的,一个是相对手机屏幕的)</p>
<p>TouchSlop:是系统所能识别出被认为是滑动的最小距离. 是一个常量值,不同的手机中它的值不同.</p>
<p>获得这个值:</p>
<pre><code>ViewConfiguration.get(getContext()).getScaledTouchSlop();
</code></pre><p>使用:在触摸事件中做过滤</p>
<h3 id="VelocityTracker-GestureDetector-Scroller"><a href="#VelocityTracker-GestureDetector-Scroller" class="headerlink" title="VelocityTracker , GestureDetector , Scroller"></a>VelocityTracker , GestureDetector , Scroller</h3><h4 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h4><p>最终手指在滑动过程中的速度,包括水平和垂直反向的速度.</p>
<p>使用:在<code>View</code>的<code>onTouchEvent</code>方法中追踪当前的事件速度</p>
<pre><code>VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
</code></pre><p>获取速度:</p>
<pre><code>velocityTracker.computeCurrentVelocity(1000); 
int xVelocity = velocityTracker.getXVelocity();
int yVelocity = velocityTracker.getYVelocity();
</code></pre><ol>
<li>获取速度前必须调用计算速度的方法</li>
<li><p>速度可能是负的,计算公式为:</p>
<pre><code>速度 = (终点位置 - 起点位置) / 时间段
</code></pre></li>
</ol>
<p>回收:不需要使用的时候调用</p>
<pre><code>velocityTracker.clear();
velocityTracker.recycle();
</code></pre><h4 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h4><p>手势检测,辅助检测用户的单击,滑动,长按,双击等行为.</p>
<p>使用:</p>
<ol>
<li><p>创建对象</p>
<pre><code>GestureDetector mGestureDetector = new GestureDetector(this);
// 解决长按屏幕无法拖动的现象
mGestureDetector.setLongpressEnabled(false);
</code></pre></li>
<li><p>接管目标<code>View</code>的<code>onTouchEvent</code>方法:在<code>onTouchEvent</code>方法中</p>
<pre><code>boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
</code></pre><p>接口:</p>
</li>
<li><p>onGestureListener:内部的方法</p>
<ul>
<li>onDown:由一个ACTION_DOWN触发</li>
<li>onShowPress:手指在屏幕上没有松开或者拖动的状态</li>
<li>onSingleTapUp:单击</li>
<li>onScroll:手指按下拖动, 一个ACTION_DOWN,多个ACTION_MOVE</li>
<li>onLongPress:长按屏幕</li>
<li>onFling:快速滑动</li>
</ul>
</li>
<li><p>onDoubleTapListener:内部方法</p>
<ul>
<li>onDoubleTap:双击,和<code>onSingleTapConfirmed</code>不会共存</li>
<li>onSingleTapConfirmed: 和<code>onSingleTapUp</code>区别,它只能是严格的单击,不能是双击中的一次单击</li>
<li>onDoubleTapEvent:双击过程中每个ACTION会触发</li>
</ul>
</li>
</ol>
<blockquote>
<p>建议:如果只是监听滑动相关的,建议自己在<code>onTouchEvent</code>中实现,如果监听双击行为的话使用<code>GestureDetector</code>会很方便.</p>
</blockquote>
<h4 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h4><p>弹性滑动对象,用于实现弹性滑动.</p>
<p>如果使用<code>View</code>的<code>scrollTo/scrollBy</code>方法来滑动是不会有过度动画的.</p>
<h2 id="View-的滑动"><a href="#View-的滑动" class="headerlink" title="View 的滑动"></a>View 的滑动</h2><h3 id="使用-scrollTo-scrollBy"><a href="#使用-scrollTo-scrollBy" class="headerlink" title="使用 scrollTo/scrollBy"></a>使用 scrollTo/scrollBy</h3><p>它改变的是内容的位置,也不能将当前的View滑动到附近所在View的区域上.</p>
<h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><h3 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h3><p>改变LayoutParams</p>
<p>一般可以多写一个View,控制它的宽高来达到平移的效果.</p>
<pre><code>MarginLayoutParams lp = (MarginLayoutParams)mBtn.getLayoutParams();
// 设置参数 ...
mBtn.requestLayout();
// 或者 mBtn.setLayoutParams(lp);
</code></pre><h3 id="各种滑动方式的对比"><a href="#各种滑动方式的对比" class="headerlink" title="各种滑动方式的对比"></a>各种滑动方式的对比</h3><p>scrollTo/scrollBy:操作简单,适合对View的内容滑动.</p>
<p>动画:操作简单,复杂的动画效果.</p>
<p>改变布局参数:操作复杂,适合有交互的View.</p>
<h2 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h2><h3 id="使用Scroller"><a href="#使用Scroller" class="headerlink" title="使用Scroller"></a>使用Scroller</h3><h3 id="通过动画"><a href="#通过动画" class="headerlink" title="通过动画"></a>通过动画</h3><h3 id="使用延时策略"><a href="#使用延时策略" class="headerlink" title="使用延时策略"></a>使用延时策略</h3><h2 id="View-的事件分发机制"><a href="#View-的事件分发机制" class="headerlink" title="View 的事件分发机制"></a>View 的事件分发机制</h2><h3 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h3><p>三个方法:</p>
<pre><code>public boolean dispathTouchEvent(MotionEvent ev)
</code></pre><p>进行事件分发, 返回的结果受当前View的<code>onTouchEvent</code>和下级的<code>dispatchTouchEvent</code>方法的影响,表示是否消耗当前事件.</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent event)
</code></pre><p>在<code>dispatchTouchEvent</code>方法内部调用这个方法, 用来-判断是否要拦截某个事件.</p>
<pre><code>public boolean onTouchEvent(MotionEvent event)
</code></pre><p>在<code>dispatchTouchEvent</code>内部调用,返回结果表示是否消耗当前事件, 如果不消耗,则在同一事件序列中 当前View无法再次接收到事件.</p>
<p>事件处理伪代码:</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev){
    boolean consume = false;
    if(onInterceptTouchEvent(ev)){
        consume = onTouchEvent(ev);
    } else {
        consume = child.dispatchEvent(ev);
    }
    return consume;
}
</code></pre><blockquote>
<p>伪代码解释:对于一个根ViewGroup在接收到一个点击事件的时候,首先会调用<code>dispatchTouchEvent</code>,这个方法内部右先调用<code>onInterceptTouchEvent</code>,如果这个方法返回<code>true</code>表示要拦截这个事件,<code>ViewGroup</code>自己消耗这个事件调用<code>onTouchEvent</code>, 如果这个方法返回<code>false</code>表示不拦截,那么这个触摸事件就传到<code>ViewGroup</code>的子控件中,接着子控件的<code>onInterceptTouchEvent</code>方法会执行, 这个过程一直执行知道事件被消耗掉.</p>
</blockquote>
<p>View处理事件:优先级</p>
<pre><code>onTouchListener &gt; onTouchEvent &gt; onClickListener
</code></pre><p>事件传递:先向下传,如果最底层元素没有处理事件(onTouchEvent 没有返回true),就一级一级往会传</p>
<pre><code>Activity --&gt; Window --&gt; View ; View --&gt; Window --&gt; Activity
</code></pre><p>几个事件分发结论:</p>
<pre><code>P142
</code></pre><h3 id="事件分发的源码解析"><a href="#事件分发的源码解析" class="headerlink" title="事件分发的源码解析"></a>事件分发的源码解析</h3><h2 id="View-滑动冲突"><a href="#View-滑动冲突" class="headerlink" title="View 滑动冲突"></a>View 滑动冲突</h2><h3 id="常见的滑动冲突场景"><a href="#常见的滑动冲突场景" class="headerlink" title="常见的滑动冲突场景"></a>常见的滑动冲突场景</h3><ul>
<li>外部滑动方向和内部滑动方向不一致</li>
<li>外部滑动方向和内部滑动方向一致</li>
<li>上面两种情况嵌套</li>
</ul>
<h3 id="滑动冲突处理规则"><a href="#滑动冲突处理规则" class="headerlink" title="滑动冲突处理规则"></a>滑动冲突处理规则</h3><p>场景一处理规则:</p>
<ol>
<li>根据滑动路径和水平的夹角</li>
<li>水平和垂直方向上的距离</li>
<li>水平和垂直方向的速度差</li>
</ol>
<p>场景二处理规则:</p>
<ol>
<li>根据业务</li>
</ol>
<p>场景三处理规则:</p>
<ol>
<li>具体分析</li>
</ol>
<h3 id="滑动冲突解决方式"><a href="#滑动冲突解决方式" class="headerlink" title="滑动冲突解决方式"></a>滑动冲突解决方式</h3><h4 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h4><p>比较符合点击事件的处理机制.</p>
<p>伪代码:</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent ev){
    boolean intercepted = false;
    int x = (int) event.getX();
    int y = (int) event.getY();
    switch(event.getAction){
        case MotionEvent.ACTION_DOWN:
            intercepted = false;
            break;
        case MotionEvent.ACTION_MOVW:
            if(是父容器需要处理的点击事件){
                intercepted = true;
            } else {
                intercepted = false;
            }
            break;
        case MotionEvent.ACTION_UP:
            intercepted = false;
            break;
        default:
            break;
    }
    mLastXInterceptX = x;
    mLastYInterceptY = y;
    return intercepted;
}
</code></pre><h4 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h4><h1 id="View-的工作原理"><a href="#View-的工作原理" class="headerlink" title="View 的工作原理"></a>View 的工作原理</h1><h2 id="初识-ViewRoot-和-DecorView"><a href="#初识-ViewRoot-和-DecorView" class="headerlink" title="初识 ViewRoot 和　DecorView"></a>初识 ViewRoot 和　DecorView</h2><p>ViewRoot 对应于　ViewRootImpl 类, 它是连接Window和DecorView的纽带.</p>
<p>View的三大流程是通过ViewRoot完成的.</p>
<p>View的三大流程:</p>
<ol>
<li>测量流程</li>
<li>布局流程</li>
<li>绘制流程</li>
</ol>
<h2 id="理解-MeasureSpec"><a href="#理解-MeasureSpec" class="headerlink" title="理解 MeasureSpec"></a>理解 MeasureSpec</h2><p>View的尺寸由 MeasureSpec 和 父容器 影响.</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>MeasureSpec是一个 32位 int值, 高2位代表SpecMode, 低30位代表SpecSize.</p>
<p>SpecMode:测量模式.</p>
<ol>
<li>UNSPECIFIED:父容器不对子View作限制,View需要多大的宽高就给多大.</li>
<li>EXACTLY:表示父容器已经检测到View的高宽, 此时View的宽高由SpecSize决定, 对应与:<code>match_parent</code> 和 <code>View在xml中指定宽高</code></li>
<li>AT_MOST:父容器指定了一个大小, View不能超过这个数值, 对应于:<code>wrap_content</code></li>
</ol>
<h3 id="MeasureSpec-和-LayoutParams-的对应关系"><a href="#MeasureSpec-和-LayoutParams-的对应关系" class="headerlink" title="MeasureSpec 和 LayoutParams 的对应关系"></a>MeasureSpec 和 LayoutParams 的对应关系</h3><p>系统内部通过 MeasureSpec 来进行View的测量, 正常情况下会使用View 指定的 MeasureSpec;</p>
<p>但是我们也可以给View设置LayoutParams, 在View测量的时候, 系统会将LayoutParams在父容器的约束下转换成MeasureSpec,然后根据这个确定View的宽高.</p>
<p>LayoutParams需要和父容器一起决定View.</p>
<h2 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h2><h3 id="measure-过程"><a href="#measure-过程" class="headerlink" title="measure 过程"></a>measure 过程</h3><p>View测量,如果是ViewGroup的话还会测量其子View.</p>
<p><strong>View 的 measure 过程</strong></p>
<p>View的measure过程由measure方法完成, measure是一个final类型, View 的measure方法内部会调用<code>onMeasure()</code>方法,<code>onMeasure()</code>可以被重写.</p>
<p>View的<code>onMeasure()</code>方法:</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));

}
</code></pre><p><code>setMeasureDimension()</code>方法设置View的宽高.</p>
<p><code>getDefaultSize()</code>方法:</p>
<pre><code>public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

    switch (specMode) {
            case MeasureSpec.UNSPECIFIED:
                result = size;
                break;
            case MeasureSpec.AT_MOST:
            case MeasureSpec.EXACTLY:
                result = specSize;
                break;

    }
    return result;

}
</code></pre><p>直接继承View的自定义控件需要重写<code>onMeasure()</code>方法并设置<code>wrap_content</code>时的自身大小,否则在布局中相当于使用了<code>match_parent</code>.</p>
<p><code>onMeasure()</code>处理代码:P186</p>
<p><strong>ViewGroup 的 measure过程</strong><br>除了测量自己.还会遍历测量子View</p>
<p>…..</p>
<h4 id="获取View的宽高"><a href="#获取View的宽高" class="headerlink" title="获取View的宽高"></a>获取View的宽高</h4><p>View的测量是需要时间的,我们在 Activity 的<code>onCreate</code>,<code>onStart</code>,<code>onResume</code>直接获取View的宽高很可能获取到的值为<code>0</code>.</p>
<p>解决方法:</p>
<ol>
<li><p>Activity/View #onWindowFocusChanged</p>
<p> 这个方法表示:View已经初始化完毕. <em>注意</em>这个方法会调用多次,在activity失去和获得焦点都会调用</p>
<p> 代码:</p>
<pre><code>public void onWindowFocusChanged(){
     super.onWindowFocusChanged();
    if(hasFocus){
        int width = mView.getMeasuredWidth();
        int height = mView.getMeasureHeight();
    }
}
</code></pre></li>
<li><p>view.post(runnable)</p>
<pre><code>mView.post(new Runnable(){
    @Override
    public void run(){
        int width = mView.getMeasureWidth();
        int height = mView.getMeasureHeight();
    }
});
</code></pre></li>
</ol>
<ol start="3">
<li><p>ViewTreeObserver</p>
<p> 使用ViewTreeObserver的众多回调来获得尺寸.</p>
</li>
<li><p>view.measure(int widthMeasureSpec, int heightMeasureSpec)</p>
<p> 复杂….</p>
</li>
</ol>
<h3 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h3><p>layout作用确定ViewGroup中子元素的位置.</p>
<p><code>layout</code>方法确定<code>ViewGroup</code>本身的位置,<code>onlayout</code>方法确定子<code>View</code>的位置.</p>
<p><code>layout</code>:</p>
<pre><code>通过`setFrame`方法设定View的2个顶点的位置参数.
</code></pre><p><code>onlayout</code></p>
<h3 id="draw-过程"><a href="#draw-过程" class="headerlink" title="draw 过程"></a>draw 过程</h3><p>将View绘制到屏幕上.</p>
<p>绘制过程:</p>
<ol>
<li>绘制背景 background.draw(canvas);</li>
<li>绘制自己 (onDraw)</li>
<li>绘制 (dispatchDraw)</li>
<li>绘制装饰 (onDrawScrollBars)</li>
</ol>
<h2 id="自定义-View"><a href="#自定义-View" class="headerlink" title="自定义 View"></a>自定义 View</h2><h3 id="自定义-View-的分类"><a href="#自定义-View-的分类" class="headerlink" title="自定义 View 的分类"></a>自定义 View 的分类</h3><ol>
<li><p>继承View重写onDraw方法</p>
<p> 静态或者动态显示一些不规则的图形, 需要自己支持<code>wrap_content</code>,<code>padding</code></p>
</li>
<li><p>继承ViewGroup派生特殊的Layout</p>
<p> 自定义布局</p>
</li>
<li><p>继承特定的View(比如 TextView)</p>
<p> 扩展某种View的功能</p>
</li>
<li><p>继承特定的ViewGroup(比如 LinearLayout)</p>
<p> 常见,相比2更容易些</p>
</li>
</ol>
<p>###自定义View须知</p>
<ol>
<li>让View支持wrap_content: 继承View或者ViewGroup时需要处理</li>
<li>如果有必要,让View支持padding</li>
<li>尽量不要在View中使用Handler: 可以使用<code>post</code>系列方法来实现.,除非真要用Handler发消息</li>
<li>View中如果有线程或者动画,需要及时停止:参考 View#onDetachedFromWindow</li>
<li>View中带有滑动嵌套的时候,需要处理滑动冲突</li>
</ol>
<h3 id="自定义View实例"><a href="#自定义View实例" class="headerlink" title="自定义View实例"></a>自定义View实例</h3><p>….</p>
<h1 id="理解-RemoteViews"><a href="#理解-RemoteViews" class="headerlink" title="理解 RemoteViews"></a>理解 RemoteViews</h1><p>RemoteViews表示的是View的结构，它可以在其他进程中显示，内部提供了一组基础的跨进程更新界面的方法。</p>
<p>使用：</p>
<ol>
<li>通知栏</li>
<li>桌面小部件</li>
</ol>
<h2 id="RemoteViews-的应用"><a href="#RemoteViews-的应用" class="headerlink" title="RemoteViews 的应用"></a>RemoteViews 的应用</h2><h3 id="RemoteView-在通知栏上的应用"><a href="#RemoteView-在通知栏上的应用" class="headerlink" title="RemoteView 在通知栏上的应用"></a>RemoteView 在通知栏上的应用</h3><p>RemoteViews的创建：需要应用包名，布局文件资源id</p>
<h3 id="RemoteViews-在桌面小部件上的应用"><a href="#RemoteViews-在桌面小部件上的应用" class="headerlink" title="RemoteViews 在桌面小部件上的应用"></a>RemoteViews 在桌面小部件上的应用</h3><p>AppWidgetProvider是Android中提供用于实现桌面小部件的类，本质是广播。</p>
<p>继承至BroadcastReceiver</p>
<h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><h4 id="1-定义小部件界面"><a href="#1-定义小部件界面" class="headerlink" title="1 定义小部件界面"></a>1 定义小部件界面</h4><p><code>res/layout</code>中创建布局文件</p>
<h4 id="2-定义小部件配置信息"><a href="#2-定义小部件配置信息" class="headerlink" title="2 定义小部件配置信息"></a>2 定义小部件配置信息</h4><p><code>res/xml</code>下创建<code>appwidget_provider_info.xml</code>(名称随意)</p>
<pre><code>&lt;appwidget-provider xmlns:android=&quot;.....&quot;
    android:initialLayout=&quot;@layout/widget&quot;
    android:minHeight = &quot;84dp&quot;
    android:minWidth = &quot;84dp&quot;
    android:updatePeriodMillis = &quot;86400000&quot;

&lt;/appwidget-provider&gt;
</code></pre><p>updatePeridMillis:表示小部件的自动更新周期。</p>
<h4 id="3-定义小部件的实现类"><a href="#3-定义小部件的实现类" class="headerlink" title="3 定义小部件的实现类"></a>3 定义小部件的实现类</h4><p>创建一个继承<code>AppWidgetProvider</code></p>
<h4 id="4-在AndroidManifest-xml中声明小部件"><a href="#4-在AndroidManifest-xml中声明小部件" class="headerlink" title="4 在AndroidManifest.xml中声明小部件"></a>4 在AndroidManifest.xml中声明小部件</h4><p>必须要定义一个action，作为桌面小部件的标识。</p>
<p>根据不同的action执行不同的方法：</p>
<ul>
<li><code>onEnable</code></li>
<li><code>onUpdate</code></li>
<li><code>onDelete</code></li>
<li><code>onDisable</code></li>
<li><code>onReceive</code></li>
</ul>
<h3 id="PendingIntent-概述"><a href="#PendingIntent-概述" class="headerlink" title="PendingIntent 概述"></a>PendingIntent 概述</h3><p>表示一种处于pending状态的Intent，在将来某个时候发生。</p>
<p>作用：给RemoteViews添加点击事件。</p>
<p>支持三种待定意图：</p>
<ol>
<li>启动Activity</li>
<li>启动Service</li>
<li>发送广播</li>
</ol>
<p>参数：</p>
<ol>
<li>content</li>
<li>requestCode：一般设置为0;</li>
<li>intent</li>
<li>flags</li>
</ol>
<p><strong>flags:</strong></p>
<ol>
<li>FLAG_ONE_SHOT:表示这个PendingIntent只能使用一次，使用后就会自动cancel。</li>
<li>FLAG_NO_CREATE:表示PendingIntent不会主动创建，一般不使用。</li>
<li>FLAG_CANCEL_CURRENT:表示当前描述的PendingIntent如果已经存在，他们都会被cancel，然后创建一个新的PendingIntent，对于通知栏，之前的PendingIntent就不能使用了。</li>
<li>FLAG_UPDATE_CURRENT:更新已经存在的PendingIntent</li>
</ol>
<h2 id="RemotesViews-的内部机制"><a href="#RemotesViews-的内部机制" class="headerlink" title="RemotesViews 的内部机制"></a>RemotesViews 的内部机制</h2><p>作用：在其他进程中显示并更新View界面。</p>
<p>RemoteViews没有提供<code>findViewById</code>方法，可以使用<code>set</code>方法来更新UI界面。</p>
<p>。。。。。。。。。。</p>
<h1 id="Android-的-Drawable"><a href="#Android-的-Drawable" class="headerlink" title="Android 的 Drawable"></a>Android 的 Drawable</h1><p>Drawable表示的是一种可以在Canvas上进行绘制的抽象的概念.</p>
<h2 id="Drawable-简介"><a href="#Drawable-简介" class="headerlink" title="Drawable 简介"></a>Drawable 简介</h2><p>表示一种图像概念, 在开发中常用作背景使用,一般用xml定义.</p>
<p>Drawable在Android是一个抽象类.</p>
<p>Drawable可以通过<code>getIntrinsicWidth</code>和<code>getIntrinsicHeight</code>获得宽高,但是并不是所有的Drawable都有宽高的.</p>
<p>一般来说过Drawable没有宽高的概念,它作为背景的时候会被自动拉伸至View的大小.</p>
<h2 id="Drawable-的分类"><a href="#Drawable-的分类" class="headerlink" title="Drawable 的分类"></a>Drawable 的分类</h2><h3 id="BitmapDrawable"><a href="#BitmapDrawable" class="headerlink" title="BitmapDrawable"></a>BitmapDrawable</h3><p>最简单的Drawable。</p>
<p>标签：bitmap</p>
<p>属性：</p>
<ul>
<li><code>android：src</code>图片资源</li>
<li><code>android：antialias</code>是否开启图片抗锯齿</li>
<li><code>android：dither</code>是否开启抖动效果，防止图片失真</li>
<li><code>android：filter</code>是否开启过滤效果，图片被拉伸或者压缩的时候可以保持较好的显示效果</li>
<li><code>android：gravity</code>图片小于容器的时候，用于定位，多个选项用<code>|</code>隔开</li>
<li><code>android：mipMap</code>图像处理技术，纹理映射， 一般<code>false</code></li>
<li><code>android：titleMode</code>平铺，</li>
</ul>
<h3 id="ShapeDrawable"><a href="#ShapeDrawable" class="headerlink" title="ShapeDrawable"></a>ShapeDrawable</h3><p>一种常见的Drawable，可以理解为通过颜色来构造图形。</p>
<pre><code>&lt;shape
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=[&quot;rectangle&quot;|&quot;oval&quot;|&quot;line&quot;|&quot;ring&quot;]&gt;

    &lt;corners
        android:radius=&quot;integer&quot;
        android:topLeftRadius=&quot;integer&quot;
        android:topRightRadius=&quot;integer&quot;
        android:bottomLeftRadius=&quot;integer&quot;
        android:bottomRightRadius=&quot;integer&quot;/&gt;

    &lt;gradient
        android:angle=&quot;integer&quot;
        android:centerX=&quot;integer&quot;
        android:centerY=&quot;integer&quot;
        android:centerColor=&quot;integer&quot;
        android:endColor=&quot;color&quot;
        android:gradientRadius=&quot;integer&quot;
        android:startColor=&quot;color&quot;
        android:type=&quot;[&quot;linear&quot;|&quot;radial&quot;|&quot;sweep&quot;]&quot;
        android:useLevel=[&quot;true&quot;|&quot;false&quot;]/&gt;

    &lt;padding
        android:left=&quot;integer&quot;
        android:top=&quot;integer&quot;
        android:right=&quot;integer&quot;
        android:bottom=&quot;integer&quot;/&gt;

    &lt;size
        android:width=&quot;integer&quot;
        android:height=&quot;integer&quot;/&gt;

    &lt;solid
        android:color=&quot;color&quot;/&gt;

    &lt;stroke
        android:width=&quot;integer&quot;
        android:color=&quot;color&quot;
        android:dashWidth=&quot;integer&quot;
        android:dashGap=&quot;integer&quot;/&gt;
&lt;/shape&gt;
</code></pre><p><strong>android:shape</strong>：</p>
<ul>
<li>四个选项，默认是矩形，line和ring 必须通过<code>stroke</code>标签来指定线宽的颜色</li>
<li>ring：有五个特殊属性：<code>android:innerRadius</code>,<code>android:thickness</code>,<code>android:innerRadiusRatio</code>,<code>android:thicknessRatio</code>,<code>android:useLevel</code></li>
</ul>
<p><strong>corner</strong>:</p>
<ul>
<li>只适用于矩形，设置四个角的圆角</li>
</ul>
<p><strong>gradoent:</strong></p>
<ul>
<li>和<code>solid</code>标签互斥</li>
</ul>
<p><strong>solid:</strong></p>
<ul>
<li>纯色填充</li>
</ul>
<p><strong>stroke:</strong></p>
<ul>
<li>描边，可设置虚线</li>
</ul>
<p><strong>paddding:</strong></p>
<ul>
<li>内边距</li>
</ul>
<p><strong>size:</strong></p>
<ul>
<li>表示shape的固有大小，但不是最终显示的大小，它会被拉伸或者压缩</li>
</ul>
<h3 id="LayerDrawable"><a href="#LayerDrawable" class="headerlink" title="LayerDrawable"></a>LayerDrawable</h3><p>对应标签：<code>layer-list</code>，将不同的Drawable放置在不同层上叠加。</p>
<pre><code>&lt;layer-list
    xmlns:android=&quot;http://schema.android.com/apk/res/android&quot;&gt;
    &lt;item
        android:drawable=&quot;@[package:]drawable/drawable_resource&quot;
        android:id=&quot;@[+][package:]id/resource_name&quot;
        android:top=&quot;dimension&quot;
        android:right=&quot;dimension&quot;
        android:bottom=&quot;dimension&quot;/&gt;
&lt;/layer-list&gt;
</code></pre><p>一个<code>layer-list</code>包含多个<code>item</code>，每个<code>item</code>表示一个Drawable。</p>
<h3 id="StateListDrawable"><a href="#StateListDrawable" class="headerlink" title="StateListDrawable"></a>StateListDrawable</h3><p>对应标签<code>selector</code>，也是表示Drawable集合，每个Drawable对应一个状态。主要用于设置成可点击的控件的背景。</p>
<pre><code>&lt;selector xmlns:.....
    android:constantSize=[&quot;true&quot;|&quot;false&quot;]
    android:dither=[&quot;true&quot;|&quot;false&quot;]
    android:variablePadding=[&quot;true&quot;|&quot;false&quot;]&gt;

    &lt;item
        android:drawable=&quot;@[package:]drawable/drawable_resource&quot;
        android:state_pressed=[&quot;true&quot;|&quot;false&quot;]
        android:state_focused=[&quot;true&quot;|&quot;false&quot;]
        android:state_hovered=[&quot;true&quot;|&quot;false&quot;]
        android:state_selected=[&quot;true&quot;|&quot;false&quot;]
        android:state_checkable=[&quot;true&quot;|&quot;false&quot;]
        android:state_checked=[&quot;true&quot;|&quot;false&quot;]
        android:state_enabled=[&quot;true&quot;|&quot;false&quot;]
        android:state_activated=[&quot;true&quot;|&quot;false&quot;]
        android:state_window_focused=[&quot;true&quot;|&quot;false&quot;]/&gt;
&lt;/selector&gt;
</code></pre><ul>
<li><code>android:constantSize</code>:表示drawable的固有大小是否不随状态改变， 默认<code>false</code></li>
<li><code>android:dither</code>:是否开启抖动，默认<code>true</code></li>
<li><code>android:variablePadding</code>:padding是否随状态改变，默认<code>false</code>建议<code>false</code></li>
</ul>
<h3 id="LevelListDrawable"><a href="#LevelListDrawable" class="headerlink" title="LevelListDrawable"></a>LevelListDrawable</h3><p>对应标签：<code>level-list</code>,语法：</p>
<pre><code>&lt;level-list
    xmlns:android=&quot;...&quot;
    &lt;item
        android:drawable=&quot;@drawable/drawable_resource&quot;
        android:maxLevel=&quot;integer&quot;
        android:minLevel=&quot;integer&quot;/&gt;
&lt;/level-list&gt;
</code></pre><p>使用：</p>
<ol>
<li>作为View的背景使用，通过Drawable的<code>setLevel</code>方法</li>
<li>作为<code>ImageView</code>的前景使用，通过ImageView的<code>setImageLevel</code>方法来切换Drawable</li>
</ol>
<p>级别：0-10000</p>
<h3 id="TransitionDrawable"><a href="#TransitionDrawable" class="headerlink" title="TransitionDrawable"></a>TransitionDrawable</h3><p>对应标签<code>transition</code>，用于实现Drawable之间的淡入和淡出效果。</p>
<p>语法：</p>
<pre><code>&lt;transition
    xmlans:android=&quot;....&quot;
    &lt;item
        android:drawable=&quot;@[package:]drawable/drawable_resource&quot;
        android:id=&quot;@[+][package:]id/resource_name&quot;
        android:top=&quot;dimension&quot;
        android:right=&quot;dimension&quot;
        android:bottom=&quot;dimension&quot;
        android:left=&quot;dimension&quot;/&gt;
&lt;/transition&gt;
</code></pre><p>例子：</p>
<pre><code>&lt;TextView
    android:id=&quot;@+id/button&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:background=&quot;@drawable/transition_drawable&quot;/&gt;
</code></pre><p>通过<code>startTransition</code>,<code>reverseTransition</code>实现淡入淡出效果以及逆过程。</p>
<pre><code>TransitionDrawable drawable = (TransitionDrawable) textView.getBackground();
drawable.startTransition(1000);
</code></pre><h3 id="InsetDrawable"><a href="#InsetDrawable" class="headerlink" title="InsetDrawable"></a>InsetDrawable</h3><p>对应<code>inset</code>标签，将其他Drawable内嵌到自己当中，并可以在四周流出一定间距。 当一个View希望自己的背景比自己的实际区域小，可以采用InsetDrawable实现，也可以使用LayerDrawable实现。</p>
<p>语法：</p>
<pre><code>&lt;inset
    xmlns:android=&quot;...&quot;
    android:drawable=&quot;@drawable/drawable_resource&quot;
    android:insetTop=&quot;dimension&quot;
    android:insetBottom=&quot;dimension&quot;
    android:insetRight=&quot;dimension&quot;
    android:insetLeft=&quot;dimension&quot;/&gt;
</code></pre><p>属性表示各个方向的内凹距离。</p>
<p>实例：</p>
<pre><code>&lt;inset xmlns:android=&quot;...&quot;
    android:insetBottom=&quot;15dp&quot;
    android:insetTop=&quot;15dp&quot;
    android:insetLeft=&quot;15dp&quot;
    android:insetRight=&quot;15dp&quot;&gt;

    &lt;shape android:shape=&quot;rectangle&quot;&gt;
        &lt;solid android:color=&quot;#ff0000&quot;/&gt;
    &lt;/shape&gt;
&lt;/inset&gt;
</code></pre><h3 id="ScaleDrawable"><a href="#ScaleDrawable" class="headerlink" title="ScaleDrawable"></a>ScaleDrawable</h3><p>对应<code>scale</code>标签，根据等级属性设置Drawable的缩放比例。</p>
<h3 id="ClipDrawable"><a href="#ClipDrawable" class="headerlink" title="ClipDrawable"></a>ClipDrawable</h3><p>对应标签<code>clip</code>，更具等级来裁剪图片。 裁剪方向由：<code>android:clipOrientation</code>,<code>android:gravity</code>控制。</p>
<p>例子：</p>
<pre><code>&lt;ImageView
    android:id=&quot;@+id/test_clip&quot;
    android:layout_width=&quot;100dp&quot;
    android:layout_height=&quot;100dp&quot;
    android:src=&quot;@drawable/clip_drawable&quot;
    android:gravity=&quot;center&quot;/&gt;

ClipDrawable drawable = (ClipDrawable) imageView.getDrawable;
drawable.setLevel(5000);
</code></pre><p>等级范围：0-10000,0表示完全裁剪， 10000表示不裁剪。</p>
<h2 id="自定义Drawable"><a href="#自定义Drawable" class="headerlink" title="自定义Drawable"></a>自定义Drawable</h2><p>一般不使用。</p>
<h1 id="理解-Window-和-WindowManager"><a href="#理解-Window-和-WindowManager" class="headerlink" title="理解 Window 和 WindowManager"></a>理解 Window 和 WindowManager</h1><p>Window 是一个抽象类,它的具体体现是PhoneWindow.</p>
<p>通过WindowManager创建Window.</p>
<p>Window是View的直接管理者.</p>
<h2 id="Window-和-WindowManager"><a href="#Window-和-WindowManager" class="headerlink" title="Window 和 WindowManager"></a>Window 和 WindowManager</h2><h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><p>Window的属性</p>
<p>几个常用的:</p>
<ul>
<li>FLAG_NOT_FOCUSABLE:表示window不需要获取焦点</li>
<li>FLAG_NOT_TOUCH_MODAL:一般来说都需要开启,当前window以外的触摸事件传递到其他的window</li>
<li>FLAG_SHOW_WHEN_LOCKED:window显示在锁屏界面</li>
</ul>
<h3 id="Tapy"><a href="#Tapy" class="headerlink" title="Tapy"></a>Tapy</h3><p>表示Window的类型/</p>
<ol>
<li>应用Window:对应一个Activity</li>
<li>子Window:不能独立存在,必须依附于特定的父Window中(比如:Dialog)</li>
<li>系统Window:需要声明权限,比如:Toash,系统状态栏</li>
</ol>
<h3 id="Window-分层"><a href="#Window-分层" class="headerlink" title="Window 分层"></a>Window 分层</h3><p>每个Window对应有z-ordered,层级大的覆盖在层级小的window上面.</p>
<p>层级:</p>
<pre><code>应用Window &lt; 子Window &lt; 系统Window
</code></pre><h3 id="windowManager-提供的功能"><a href="#windowManager-提供的功能" class="headerlink" title="windowManager 提供的功能"></a>windowManager 提供的功能</h3><ol>
<li>添加View</li>
<li>更新View</li>
<li>删除View</li>
</ol>
<p>实现可拖动的Window: P297</p>
<h2 id="Window-内部机制"><a href="#Window-内部机制" class="headerlink" title="Window 内部机制"></a>Window 内部机制</h2><p>每个Window都对应一个View和一个ViewRootImpl, window和View通过ViewRootImpl建立联系.</p>
<h3 id="Window-的添加过程"><a href="#Window-的添加过程" class="headerlink" title="Window 的添加过程"></a>Window 的添加过程</h3><h3 id="window-删除过程"><a href="#window-删除过程" class="headerlink" title="window 删除过程"></a>window 删除过程</h3><p>###　window 更新过程</p>
<h2 id="Window-创建过程"><a href="#Window-创建过程" class="headerlink" title="Window 创建过程"></a>Window 创建过程</h2><p>View是Android中视图的呈现方式, 但是View不能独立存在,它需要依附在Window中,因此有视图的地方就有Window.</p>
<h3 id="Activity-的Window创建过程"><a href="#Activity-的Window创建过程" class="headerlink" title="Activity 的Window创建过程"></a>Activity 的Window创建过程</h3><h3 id="Dialog-的Window创建过程"><a href="#Dialog-的Window创建过程" class="headerlink" title="Dialog 的Window创建过程"></a>Dialog 的Window创建过程</h3><p>必须使用Activity的Context来创建,如果使用Application的Context创建会报错.</p>
<p>报错:没有应用的token,token一般只有Activity持有.</p>
<p>注意:系统Window不需要token,指定type</p>
<h3 id="Toast-的创建过程"><a href="#Toast-的创建过程" class="headerlink" title="Toast 的创建过程"></a>Toast 的创建过程</h3><p>Toast的创建流程比Dialog复杂,它具有定时消失功能,所以系统采用了Handler.</p>
<p>Toast内部有两类IPC:</p>
<ol>
<li>Toast访问NotificationManagerService</li>
<li>NotificationManagerService回调Toast里的TN接口</li>
</ol>
<p>Toast内部视图指定方式:</p>
<ol>
<li>系统默认</li>
<li><code>setView()</code>方法来自定义视图</li>
</ol>
<p>Toast的show和cancel用于显示和隐藏Toast,内部是一个IPC的过程.</p>
<h1 id="四大组件的工作流程"><a href="#四大组件的工作流程" class="headerlink" title="四大组件的工作流程"></a>四大组件的工作流程</h1><h1 id="Android-的消息机制"><a href="#Android-的消息机制" class="headerlink" title="Android 的消息机制"></a>Android 的消息机制</h1><p>Handler是Android消息机制的上层接口，通过Handler轻松将任务切换到Handler所在的进程中去执行。</p>
<p>通常作用：更新UI</p>
<p>Android消息机制一般就是指Handler的运行机制，Handler运行需要MessageQueue和Looper支持。</p>
<p>MessageQueue是消息队列，用于存储消息。</p>
<p>Looper：消息循环，循环从消息队列中查找消息，并将消息发送到相应的Handler中处理。</p>
<p>ThreadLocal：不是线程，作用是在每个线程中存储数据，在不同的线程中互补干扰地存储并提供数据。</p>
<p>Handler创建的时候需要Looper，获取Looper就需要用到ThreadLocal；线程默认是没有Looper（除了UI线程ActivityThread）</p>
<h2 id="Android-消息机制概述"><a href="#Android-消息机制概述" class="headerlink" title="Android 消息机制概述"></a>Android 消息机制概述</h2><p>ViewRootImpl的<code>checkThread</code>方法中会检测UI更新线程是否是UI线程，否则抛异常。</p>
<p>Handler的出现是为了解决子线程无法访问UI的矛盾。</p>
<p><strong>系统为什么不允许子线程访问UI线程？</strong></p>
<ol>
<li>因为UI控件不是线程安全的，并发访问会出现问题</li>
<li>如果加上锁机制，会让逻辑变得复杂，访问效率低</li>
</ol>
<p>##　Android 的消息机制分析</p>
<h3 id="ThreadLocal-的工作原理"><a href="#ThreadLocal-的工作原理" class="headerlink" title="ThreadLocal 的工作原理"></a>ThreadLocal 的工作原理</h3><p>是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定的线程中才能获取到存储的数据。</p>
<p>*<em>作用:</em></p>
<ol>
<li>基于上面的特征：Handler可以通过它来存取Looper。</li>
<li>复制逻辑下的对象传递。<br> 在函数调用栈比较深，同时又需要用监听器做接口回调的时候，可以使用ThreadLocal，它让监听器作为全局对象存在。<br> 需要在同一个线程中，并且操作同一个ThreadLocal对象。</li>
</ol>
<p><strong>线程访问同一个ThreadLocal对象，但是获取的值是不一样的。</strong></p>
<p>因为不同线程访问同一个ThreadLocal的<code>get</code>方法，ThreadLocal会在各自线程中取出一个数组从这个数组中根据这个ThreadLocal索引找值。</p>
<p>Thread类内部有个成员用于存储ThreadLocal数据： <code>ThreadLocal.Values localValues</code>,内部有一个数组存储数据。</p>
<p>不同线程中虽然使用同一个<code>ThreadLocal</code>对象，但是他们操作的不是同一个<code>localValues</code></p>
<h3 id="消息队列的工作原理"><a href="#消息队列的工作原理" class="headerlink" title="消息队列的工作原理"></a>消息队列的工作原理</h3><p>MessageQueue主要包含两个操作：插入，读取（删除） ； <code>enqueueMessage</code>,<code>next</code>.</p>
<p>通过单链表的数据结构维护消息列表。</p>
<p><code>next</code>方法内部是一个无限循环，作用：找到消息并返回删除。</p>
<h3 id="Looper-的工作原理"><a href="#Looper-的工作原理" class="headerlink" title="Looper 的工作原理"></a>Looper 的工作原理</h3><p>会不停从MessageQueue中查看是否有新消息，如果有就处理，没有就一直阻塞。</p>
<p>构造方法：(私有)</p>
<pre><code>private Looper(boolean quitAllowed){
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre><p>如何创建Looper对象：<code>Looper.prepare()</code></p>
<p>如何开始消息循环：<code>Looper.loop()</code></p>
<p>通常步骤：</p>
<pre><code>new Thread(&quot;Thread#2&quot;){
    @Override
    public  void run(){
        Looper.prepare();
        Handler handler = new Handler();
        Looper.loop();
    }
}
</code></pre><p>针对主线程：<code>prepareMainLooper</code>,<code>getMainLooper</code>一般不会使用。</p>
<p>关闭Looper：<code>quit</code>，<code>quitSafely</code>，一般在子线程中使用Looper的时候，需要手动关闭，来终止消息循环。</p>
<p><code>loop（）</code>方法：内部无限循环，发现消息执行 消息处理：<code>msg.target.dispatchMessage(msg)</code></p>
<h3 id="Handler-的工作原理"><a href="#Handler-的工作原理" class="headerlink" title="Handler 的工作原理"></a>Handler 的工作原理</h3><p>消息发送和接收。</p>
<p>最终消息由Looper交给Handler处理，Handler调用<code>dispatchMessage</code>方法：</p>
<pre><code>public void dispatchMessage(Message msg){
    if(msg.callback != null){
        handleCallback(msg);
    } else {
        if(mCallback != null){
            if(mCallback.handleMessage(msg)){
                return;
            }
        }
        handleMessage(msg);
    }
}
</code></pre><p>Message的callback就是一个Runnable对象，就是Handler的post方法所传递的参数。</p>
<p><code>handleCallback（msg）</code>方法内部就是执行了Runnable的<code>run</code>方法。</p>
<p><code>mCallback</code>是一个接口，在创建Handler的时候作为参数。</p>
<p>Handler构造方法，可以通过特定的Looper来创建，就是说Handler在创建的时候会检查本线程中的Looper对象是否存在，否则抛异常。</p>
<h2 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h2><p>主线程入口：<code>main</code>方法，这个方法里调用：</p>
<pre><code>Looper.prepareMainLooper();
Looper.loop();
</code></pre><p>主线程Handler： ActivityThread.H, 内部定义了一组消息类型，主要是四大组件的启动和停止等过程。</p>
<h1 id="Android-的线程和线程池"><a href="#Android-的线程和线程池" class="headerlink" title="Android 的线程和线程池"></a>Android 的线程和线程池</h1><p>主线程：处理和界面相关的实务。</p>
<p>##　主线程和子线程<br>java线程模型：主线程指进程所拥有的线程，在java中默认进程只有一个线程。 子线程也叫工作线程，除了主线程之外其他的都是子线程。</p>
<h2 id="Android-中的线程形态"><a href="#Android-中的线程形态" class="headerlink" title="Android 中的线程形态"></a>Android 中的线程形态</h2><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>一种轻量级的异步任务类，可以在线程池中执行后台任务，然后把执行进度和结果返回给主线程中更新UI。</p>
<p>它封装了Thread和Handler。</p>
<p>四个核心方法：</p>
<ol>
<li><code>onPreExecute</code>:在主线程中执行，在异步任务之前会调用这个方法，一般做一些准备工作</li>
<li><code>doInBackground(Params ... params)</code>:异步任务，在这个方法中通过<code>publishProgress</code>方法更新任务进度（同时触发<code>onPregressUpdate</code>），将异步结果传递给<code>onPostExecute</code></li>
<li><code>onProgressUpdate</code>:在主线程中执行，用于更新进度</li>
<li><code>onPostExecute</code>:在主线程中执行，将结果更新到UI线程</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>AsyncTask的对象必须在主线程中创建</li>
<li>execute方法必须在UI线程中调用</li>
<li>不要在程序中调用AsyncTask中的四大方法</li>
<li>一个AsyncTask对象只能执行一次，即只能调用<code>execute</code>方法一次，否则会异常</li>
</ol>
<h3 id="AsyncTask-的工作原理"><a href="#AsyncTask-的工作原理" class="headerlink" title="AsyncTask 的工作原理"></a>AsyncTask 的工作原理</h3><p>。。<br>。。</p>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>继承Thread，是一种可以使用Handler的Thread，它在其<code>run</code>方法中创建Handler，具体使用场景是与IntentService配合使用。</p>
<p>需要在不适用的时候<code>quit</code>或者<code>quitSafely</code></p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>是一种特殊的Service,它继承Service并且是一个抽象类。</p>
<p>用于执行后台耗时操作，任务执行完成会自动销毁。</p>
<p>优点：属于四大组件，优先级高。</p>
<p>内部封装了：HandlerThread和Handler</p>
<p><code>onCreate</code>方法：</p>
<pre><code>创建一个HandlerThread并且调用`start`方法
通过本线程Looper创建Handler：mServuceHandler
</code></pre><p><code>onStartCommand</code>内部调用<code>onStart</code>:</p>
<pre><code>通过mServiceHandler发送一个消息，这个消息会在HandlerThread中被处理，处理完成就会结束线程。
</code></pre><h2 id="Android线程池"><a href="#Android线程池" class="headerlink" title="Android线程池"></a>Android线程池</h2><p>优点：</p>
<ol>
<li>重用线程池中的线程，避免线程创建和销毁所带来的性能消耗</li>
<li>能有效控制线程池的最大并发数，避免大量线程之间因互相强系统资源导致的阻塞</li>
<li>可以对线程做简单管理，并提供定时执行和指定间隔执行功能</li>
</ol>
<p>线程池：Executor，是一个接口，真正实现类<code>ThreadPoolExecutor</code></p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>构造方法提供了一系列的参数来配置线程池：</p>
<ul>
<li><code>corePoolSize</code>:线程池的核心线程数，会在线程池中一直存活</li>
<li><code>maximunPoolSize</code>:线程池最大线程数，线程数达到最大后，后续的新任务被阻塞</li>
<li><code>keepAliveTime</code>:非核心线程闲置时间超过时长就会被回收， <code>allowCoreThreadTimeOut</code>设置为<code>true</code>那么核心线程也会被回收</li>
<li><code>unit</code>:keepAliveTime的单位</li>
<li><code>workQueue</code>:线程池中的队列消息，通过线程池的execute方法提交的Runnable对象会存储到这个参数中</li>
<li><code>threadFactory</code>:线程工厂，为线程池提供创建新线程的功能，是一个接口</li>
</ul>
<p>执行任务的规则：</p>
<ol>
<li>优先使用核心线程</li>
<li>任务中线程数量达到或者超过核心线程数，新的任务会被插入到任务队列中等待执行</li>
<li>如果步骤2执行不成功（任务队列满了），如果线程数量未达到线程最大数，就会创建新的非核心线程</li>
<li>步骤3也达到线程数量的时候，拒绝执行任务，会调用<code>rejectedExecutionHandler</code></li>
</ol>
<h3 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><ol>
<li>通过<code>Executors</code>的<code>newFixedThreadPool</code>创建</li>
<li>线程数固定</li>
<li>不会被回收</li>
<li>能快速响应外界请求</li>
<li>没有超时机制</li>
<li>任务队列没有数量限制</li>
</ol>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool:"></a>CachedThreadPool:</h4><ol>
<li>通过<code>Executors</code>的<code>newCachedThreadPool</code>方法来创建。</li>
<li>线程数不固定</li>
<li>都是非核心线程</li>
<li>线程数最大为：Integer.MAX_VALUE</li>
<li>有超时时间：60s</li>
<li>它的任务队列相当于一个空集合，因为所有的任务都会执行</li>
<li>这类线程适合执行大量但是耗时较少的任务</li>
<li>在没有任务的适合，它不占用任务系统资源，因为没有核心线程</li>
</ol>
<h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><ol>
<li>通过<code>Executors</code>的<code>newScheduledThreadPool</code></li>
<li>核心线程数量是固定的</li>
<li>非核心线程数量是没有限制的</li>
<li>主要用于执行定时任务和具有固定周期的重复任务</li>
</ol>
<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><ol>
<li>通过<code>Executors</code>的<code>newSingleThreadExecutor</code>来创建</li>
<li>只有一个核心线程，没有非核心线程</li>
<li>确保所有的任务按顺序执行，这些任务之间不需要处理线程同步的问题</li>
<li>将所有的任务都统一到一个线程中</li>
</ol>
<p>最后使用方法：</p>
<pre><code>Runnable command = new Runnable(){
    @Override
    public void run(){
        SystemClock.sleep(2000);
    }
}

ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4);
fixedThreadPool.execute(command);

ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
cachedThreadPool.execute(command);
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
            <a href="/tags/Android开发艺术探秘/" rel="tag"># Android开发艺术探秘</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/16/ReadNote/设计模式/创建者模式/设计模式之蝉-抽象工厂模式/" rel="next" title="设计模式之蝉 - 抽象工厂方法模式">
                <i class="fa fa-chevron-left"></i> 设计模式之蝉 - 抽象工厂方法模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/22/Android/aidl/aidl_官方文档/" rel="prev" title="AIDL 官方文档">
                AIDL 官方文档 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/head1.jpg" alt="Double">
          <p class="site-author-name" itemprop="name">Double</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">548</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">260</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Activity-的生命周期和启动模式"><span class="nav-number">1.</span> <span class="nav-text">Activity 的生命周期和启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#典型情况的Activity生命周期"><span class="nav-number">1.1.</span> <span class="nav-text">典型情况的Activity生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常情况的生命周期"><span class="nav-number">1.2.</span> <span class="nav-text">异常情况的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#资源相关的系统配置发生改变导致Activity被杀死重新创建"><span class="nav-number">1.2.1.</span> <span class="nav-text">资源相关的系统配置发生改变导致Activity被杀死重新创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源内存不足导致低优先级的Activity被杀死"><span class="nav-number">1.3.</span> <span class="nav-text">资源内存不足导致低优先级的Activity被杀死</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity-启动模式"><span class="nav-number">1.4.</span> <span class="nav-text">Activity 启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TaskAffinity"><span class="nav-number">1.4.1.</span> <span class="nav-text">TaskAffinity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给Activity指定启动模式"><span class="nav-number">1.4.2.</span> <span class="nav-text">给Activity指定启动模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个命令"><span class="nav-number">1.4.3.</span> <span class="nav-text">一个命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity-Flags"><span class="nav-number">1.4.4.</span> <span class="nav-text">Activity Flags</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IntentFilter-的匹配规则"><span class="nav-number">1.5.</span> <span class="nav-text">IntentFilter 的匹配规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#action"><span class="nav-number">1.5.1.</span> <span class="nav-text">action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#category"><span class="nav-number">1.5.2.</span> <span class="nav-text">category</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data"><span class="nav-number">1.5.3.</span> <span class="nav-text">data</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IPC-进程"><span class="nav-number">2.</span> <span class="nav-text">IPC 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程"><span class="nav-number">2.1.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android中的多进程模式"><span class="nav-number">2.2.</span> <span class="nav-text">Android中的多进程模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开启多进程模式"><span class="nav-number">2.2.1.</span> <span class="nav-text">开启多进程模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多进程模式的运行机制"><span class="nav-number">2.2.2.</span> <span class="nav-text">多进程模式的运行机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC基础概念介绍"><span class="nav-number">2.3.</span> <span class="nav-text">IPC基础概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable-接口"><span class="nav-number">2.3.1.</span> <span class="nav-text">Serializable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parcelable-接口"><span class="nav-number">2.3.2.</span> <span class="nav-text">Parcelable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binder"><span class="nav-number">2.3.3.</span> <span class="nav-text">Binder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-中的-IPC-方式"><span class="nav-number">2.4.</span> <span class="nav-text">Android 中的 IPC 方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Bundle"><span class="nav-number">2.4.1.</span> <span class="nav-text">使用Bundle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用文件共享"><span class="nav-number">2.4.2.</span> <span class="nav-text">使用文件共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Messenger"><span class="nav-number">2.4.3.</span> <span class="nav-text">使用 Messenger</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Messenger-的两中构造方法-重要"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">Messenger 的两中构造方法 (重要)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">服务端:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">客户端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-AIDL"><span class="nav-number">2.4.4.</span> <span class="nav-text">使用 AIDL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端-1"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">服务端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端-1"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递自定义的对象"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">传递自定义的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#观察者模式监听服务器变化"><span class="nav-number">2.4.4.4.</span> <span class="nav-text">观察者模式监听服务器变化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用ContentProvider"><span class="nav-number">2.4.5.</span> <span class="nav-text">使用ContentProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Socket"><span class="nav-number">2.4.6.</span> <span class="nav-text">使用Socket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder-连接池"><span class="nav-number">2.5.</span> <span class="nav-text">Binder 连接池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择合适的IPC方式"><span class="nav-number">2.6.</span> <span class="nav-text">选择合适的IPC方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#View-的事件体系"><span class="nav-number">3.</span> <span class="nav-text">View 的事件体系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#View的基础知识"><span class="nav-number">3.1.</span> <span class="nav-text">View的基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是View"><span class="nav-number">3.1.1.</span> <span class="nav-text">什么是View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View-的位置信息"><span class="nav-number">3.1.2.</span> <span class="nav-text">View 的位置信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MotionEvent-和-TouchSlop"><span class="nav-number">3.1.3.</span> <span class="nav-text">MotionEvent 和 TouchSlop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VelocityTracker-GestureDetector-Scroller"><span class="nav-number">3.1.4.</span> <span class="nav-text">VelocityTracker , GestureDetector , Scroller</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#VelocityTracker"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">VelocityTracker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GestureDetector"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">GestureDetector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scroller"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">Scroller</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-的滑动"><span class="nav-number">3.2.</span> <span class="nav-text">View 的滑动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-scrollTo-scrollBy"><span class="nav-number">3.2.1.</span> <span class="nav-text">使用 scrollTo/scrollBy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用动画"><span class="nav-number">3.2.2.</span> <span class="nav-text">使用动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变布局参数"><span class="nav-number">3.2.3.</span> <span class="nav-text">改变布局参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各种滑动方式的对比"><span class="nav-number">3.2.4.</span> <span class="nav-text">各种滑动方式的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#弹性滑动"><span class="nav-number">3.3.</span> <span class="nav-text">弹性滑动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Scroller"><span class="nav-number">3.3.1.</span> <span class="nav-text">使用Scroller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过动画"><span class="nav-number">3.3.2.</span> <span class="nav-text">通过动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用延时策略"><span class="nav-number">3.3.3.</span> <span class="nav-text">使用延时策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-的事件分发机制"><span class="nav-number">3.4.</span> <span class="nav-text">View 的事件分发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#点击事件的传递规则"><span class="nav-number">3.4.1.</span> <span class="nav-text">点击事件的传递规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件分发的源码解析"><span class="nav-number">3.4.2.</span> <span class="nav-text">事件分发的源码解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-滑动冲突"><span class="nav-number">3.5.</span> <span class="nav-text">View 滑动冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的滑动冲突场景"><span class="nav-number">3.5.1.</span> <span class="nav-text">常见的滑动冲突场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动冲突处理规则"><span class="nav-number">3.5.2.</span> <span class="nav-text">滑动冲突处理规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动冲突解决方式"><span class="nav-number">3.5.3.</span> <span class="nav-text">滑动冲突解决方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外部拦截法"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">外部拦截法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部拦截法"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">内部拦截法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#View-的工作原理"><span class="nav-number">4.</span> <span class="nav-text">View 的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初识-ViewRoot-和-DecorView"><span class="nav-number">4.1.</span> <span class="nav-text">初识 ViewRoot 和　DecorView</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解-MeasureSpec"><span class="nav-number">4.2.</span> <span class="nav-text">理解 MeasureSpec</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MeasureSpec"><span class="nav-number">4.2.1.</span> <span class="nav-text">MeasureSpec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MeasureSpec-和-LayoutParams-的对应关系"><span class="nav-number">4.2.2.</span> <span class="nav-text">MeasureSpec 和 LayoutParams 的对应关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View的工作流程"><span class="nav-number">4.3.</span> <span class="nav-text">View的工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#measure-过程"><span class="nav-number">4.3.1.</span> <span class="nav-text">measure 过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取View的宽高"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">获取View的宽高</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#layout过程"><span class="nav-number">4.3.2.</span> <span class="nav-text">layout过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#draw-过程"><span class="nav-number">4.3.3.</span> <span class="nav-text">draw 过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义-View"><span class="nav-number">4.4.</span> <span class="nav-text">自定义 View</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义-View-的分类"><span class="nav-number">4.4.1.</span> <span class="nav-text">自定义 View 的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义View实例"><span class="nav-number">4.4.2.</span> <span class="nav-text">自定义View实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解-RemoteViews"><span class="nav-number">5.</span> <span class="nav-text">理解 RemoteViews</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RemoteViews-的应用"><span class="nav-number">5.1.</span> <span class="nav-text">RemoteViews 的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RemoteView-在通知栏上的应用"><span class="nav-number">5.1.1.</span> <span class="nav-text">RemoteView 在通知栏上的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RemoteViews-在桌面小部件上的应用"><span class="nav-number">5.1.2.</span> <span class="nav-text">RemoteViews 在桌面小部件上的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用步骤："><span class="nav-number">5.1.2.1.</span> <span class="nav-text">使用步骤：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-定义小部件界面"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">1 定义小部件界面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-定义小部件配置信息"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">2 定义小部件配置信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-定义小部件的实现类"><span class="nav-number">5.1.2.4.</span> <span class="nav-text">3 定义小部件的实现类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-在AndroidManifest-xml中声明小部件"><span class="nav-number">5.1.2.5.</span> <span class="nav-text">4 在AndroidManifest.xml中声明小部件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PendingIntent-概述"><span class="nav-number">5.1.3.</span> <span class="nav-text">PendingIntent 概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RemotesViews-的内部机制"><span class="nav-number">5.2.</span> <span class="nav-text">RemotesViews 的内部机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-的-Drawable"><span class="nav-number">6.</span> <span class="nav-text">Android 的 Drawable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Drawable-简介"><span class="nav-number">6.1.</span> <span class="nav-text">Drawable 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Drawable-的分类"><span class="nav-number">6.2.</span> <span class="nav-text">Drawable 的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BitmapDrawable"><span class="nav-number">6.2.1.</span> <span class="nav-text">BitmapDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ShapeDrawable"><span class="nav-number">6.2.2.</span> <span class="nav-text">ShapeDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LayerDrawable"><span class="nav-number">6.2.3.</span> <span class="nav-text">LayerDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StateListDrawable"><span class="nav-number">6.2.4.</span> <span class="nav-text">StateListDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LevelListDrawable"><span class="nav-number">6.2.5.</span> <span class="nav-text">LevelListDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TransitionDrawable"><span class="nav-number">6.2.6.</span> <span class="nav-text">TransitionDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InsetDrawable"><span class="nav-number">6.2.7.</span> <span class="nav-text">InsetDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScaleDrawable"><span class="nav-number">6.2.8.</span> <span class="nav-text">ScaleDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClipDrawable"><span class="nav-number">6.2.9.</span> <span class="nav-text">ClipDrawable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义Drawable"><span class="nav-number">6.3.</span> <span class="nav-text">自定义Drawable</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解-Window-和-WindowManager"><span class="nav-number">7.</span> <span class="nav-text">理解 Window 和 WindowManager</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Window-和-WindowManager"><span class="nav-number">7.1.</span> <span class="nav-text">Window 和 WindowManager</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flags"><span class="nav-number">7.1.1.</span> <span class="nav-text">Flags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tapy"><span class="nav-number">7.1.2.</span> <span class="nav-text">Tapy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-分层"><span class="nav-number">7.1.3.</span> <span class="nav-text">Window 分层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windowManager-提供的功能"><span class="nav-number">7.1.4.</span> <span class="nav-text">windowManager 提供的功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window-内部机制"><span class="nav-number">7.2.</span> <span class="nav-text">Window 内部机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-的添加过程"><span class="nav-number">7.2.1.</span> <span class="nav-text">Window 的添加过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-删除过程"><span class="nav-number">7.2.2.</span> <span class="nav-text">window 删除过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window-创建过程"><span class="nav-number">7.3.</span> <span class="nav-text">Window 创建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity-的Window创建过程"><span class="nav-number">7.3.1.</span> <span class="nav-text">Activity 的Window创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dialog-的Window创建过程"><span class="nav-number">7.3.2.</span> <span class="nav-text">Dialog 的Window创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Toast-的创建过程"><span class="nav-number">7.3.3.</span> <span class="nav-text">Toast 的创建过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四大组件的工作流程"><span class="nav-number">8.</span> <span class="nav-text">四大组件的工作流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-的消息机制"><span class="nav-number">9.</span> <span class="nav-text">Android 的消息机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-消息机制概述"><span class="nav-number">9.1.</span> <span class="nav-text">Android 消息机制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-的工作原理"><span class="nav-number">9.1.1.</span> <span class="nav-text">ThreadLocal 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列的工作原理"><span class="nav-number">9.1.2.</span> <span class="nav-text">消息队列的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Looper-的工作原理"><span class="nav-number">9.1.3.</span> <span class="nav-text">Looper 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler-的工作原理"><span class="nav-number">9.1.4.</span> <span class="nav-text">Handler 的工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主线程的消息循环"><span class="nav-number">9.2.</span> <span class="nav-text">主线程的消息循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-的线程和线程池"><span class="nav-number">10.</span> <span class="nav-text">Android 的线程和线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-中的线程形态"><span class="nav-number">10.1.</span> <span class="nav-text">Android 中的线程形态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncTask"><span class="nav-number">10.1.1.</span> <span class="nav-text">AsyncTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncTask-的工作原理"><span class="nav-number">10.1.2.</span> <span class="nav-text">AsyncTask 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerThread"><span class="nav-number">10.1.3.</span> <span class="nav-text">HandlerThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IntentService"><span class="nav-number">10.1.4.</span> <span class="nav-text">IntentService</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android线程池"><span class="nav-number">10.2.</span> <span class="nav-text">Android线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">10.2.1.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的分类"><span class="nav-number">10.2.2.</span> <span class="nav-text">线程池的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FixedThreadPool"><span class="nav-number">10.2.2.1.</span> <span class="nav-text">FixedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CachedThreadPool"><span class="nav-number">10.2.2.2.</span> <span class="nav-text">CachedThreadPool:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledThreadPool"><span class="nav-number">10.2.3.</span> <span class="nav-text">ScheduledThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SingleThreadExecutor"><span class="nav-number">10.2.4.</span> <span class="nav-text">SingleThreadExecutor</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Double</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
