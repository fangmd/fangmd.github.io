<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Python,廖雪峰笔记,简明Python,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="第一个Python程序 编写一个文件：hello.py print(&amp;apos;hello , world&amp;apos;);  运行这个文件 python hello.py  运行文件方法二： // 1. 修改文件内容 #!/usr/bin/env python3 print(&amp;apos;hello,world&amp;apos;)  // 2. 给文件添加执行权限 chmod a+x hello.py">
<meta name="keywords" content="Python,廖雪峰笔记,简明Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 学习记录">
<meta property="og:url" content="http://yoursite.com/2016/08/14/ReadNote/Python/index.html">
<meta property="og:site_name" content="Double">
<meta property="og:description" content="第一个Python程序 编写一个文件：hello.py print(&amp;apos;hello , world&amp;apos;);  运行这个文件 python hello.py  运行文件方法二： // 1. 修改文件内容 #!/usr/bin/env python3 print(&amp;apos;hello,world&amp;apos;)  // 2. 给文件添加执行权限 chmod a+x hello.py">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-08-12T14:50:57.334Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python 学习记录">
<meta name="twitter:description" content="第一个Python程序 编写一个文件：hello.py print(&amp;apos;hello , world&amp;apos;);  运行这个文件 python hello.py  运行文件方法二： // 1. 修改文件内容 #!/usr/bin/env python3 print(&amp;apos;hello,world&amp;apos;)  // 2. 给文件添加执行权限 chmod a+x hello.py">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/08/14/ReadNote/Python/">





  <title>Python 学习记录 | Double</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Double</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/14/ReadNote/Python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python 学习记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-14T21:38:14+08:00">
                2016-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h1><ol>
<li><p>编写一个文件：<code>hello.py</code></p>
<pre><code>print(&apos;hello , world&apos;);
</code></pre></li>
<li><p>运行这个文件</p>
<pre><code>python hello.py
</code></pre></li>
<li><p>运行文件方法二：</p>
<pre><code>// 1. 修改文件内容
#!/usr/bin/env python3
print(&apos;hello,world&apos;)

// 2. 给文件添加执行权限
chmod a+x hello.py

// 3. 执行文件
./hello.py
</code></pre></li>
</ol>
<p>上面使用了交互模式和直接运行<code>.py</code>文件</p>
<a id="more"></a>
<h2 id="Python-脚本运行-传入参数"><a href="#Python-脚本运行-传入参数" class="headerlink" title="Python 脚本运行 传入参数"></a>Python 脚本运行 传入参数</h2><pre><code># ex14.py
from sys import argv

script num1 num2 = argv # 输入的参数进行解包
</code></pre><p>使用：</p>
<pre><code>python3 ex14.py num1 num2
</code></pre><p>python3 后面的参数会被打包传入py脚本，通过argv解包获取参数。</p>
<h2 id="Python-获取控制台的输入"><a href="#Python-获取控制台的输入" class="headerlink" title="Python 获取控制台的输入"></a>Python 获取控制台的输入</h2><pre><code># ex13.py
a = input()

prompt = &apos;&gt;&apos; # 输入提示内容
a = input()
</code></pre><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>*</code></li>
<li><code>/</code>:返回浮点数</li>
<li><code>//</code>:整数商</li>
<li><code>%</code>:取余数</li>
<li><code>**</code>:次方，幂（3 ** 4 = 81）</li>
<li><code>=</code>:assign a value to a variable</li>
<li>‘_‘:mines last printed </li>
<li><code>&gt;&gt;</code>:右位移</li>
<li><code>&lt;&lt;</code>:左位移</li>
<li><code>&amp;</code></li>
<li><code>|</code></li>
<li><code>^</code></li>
<li><code>~</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>!=</code></li>
<li><code>and</code></li>
<li><code>not</code></li>
<li><code>or</code></li>
</ul>
<h2 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h2><h3 id="numbers-数字"><a href="#numbers-数字" class="headerlink" title="numbers 数字"></a>numbers 数字</h3><p>Python 只有 3 种数字类型： 整数（比如 2），浮点（比如 2.3），复数（比如 -5+4j）</p>
<h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>python3 中的所有字符串都是 unicode</p>
<p>使用单眼号或者双眼号</p>
<p>三眼号：字符串内部换行其他写法：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> , <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&apos;&apos;line1</span><br><span class="line">line2</span><br><span class="line">line3&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">加一个`\`可以去除开头生成的多余的新行</span><br></pre></td></tr></table></figure>
<p><code>\\</code>转义符号 ,<code>\\n</code>表示换行，<code>\\t</code>表示制表符</p>
<p>外部使用单眼号，内部使用双眼号的时候，双眼号不用转义</p>
<p>使用<code>r</code>(raw)表示眼号内需要转义的字符都默认不转义:</p>
<pre><code>print(r&apos;C:\some\name&apos;) # C:\some\name
</code></pre><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">name = <span class="string">'fang'</span></span><br><span class="line">print(<span class="string">'&#123;0&#125; is &#123;1&#125; years old'</span>.format(name, age))</span><br></pre></td></tr></table></figure>
<h5 id="format-是如何工作的"><a href="#format-是如何工作的" class="headerlink" title="format 是如何工作的"></a>format 是如何工作的</h5><p>string 可以包含<strong>格式说明符</strong>，format 使用参数替换 string 中的<strong>格式说明符</strong></p>
<p>还有一些复杂的<strong>格式说明符</strong>使用方式</p>
<h4 id="String-concatenate"><a href="#String-concatenate" class="headerlink" title="String concatenate"></a>String concatenate</h4><ul>
<li><code>+</code>:concatenate string</li>
<li><p><code>*</code>:repeat string</p>
<pre><code>3 * &apos;un&apos; + &apos;ium&apos; # &apos;unununium&apos;
</code></pre></li>
<li><p>两个string并排自动 concatenate, 只对于字符串对于变量或者表达式无效</p>
<pre><code>&apos;Py&apos; &apos;thon&apos; # &apos;Python&apos;
</code></pre><p>  如果要将字符串和变量拼接需要使用<code>+</code></p>
</li>
</ul>
<h4 id="string-index"><a href="#string-index" class="headerlink" title="string index"></a>string index</h4><p>可以使用负索引</p>
<p>越界会报错：<code>IndexError</code></p>
<h4 id="截取-slicing"><a href="#截取-slicing" class="headerlink" title="截取 slicing"></a>截取 slicing</h4><pre><code>s[x:y]

word = &apos;Python&apos;
word[0:2]
word[:2] + word[2:] # &apos;Python&apos;

+---+---+---+---+---+---+
| P | y | t | h | o | n |
+---+---+---+---+---+---+
0     1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
</code></pre><p>索引越界不会报错：</p>
<pre><code>word[4:42] # &apos;on&apos;
word[42:] #&apos;&apos;
</code></pre><p>字符串属于常量，不能使用索引赋值，只能创建新的string：</p>
<pre><code>&apos;J&apos; + word[1:] # Jython
word[:2] + &apos;py&apos; # python
</code></pre><h4 id="built-in-function"><a href="#built-in-function" class="headerlink" title="built-in function"></a>built-in function</h4><p>相关方法见项目</p>
<p>format:</p>
<pre><code>&apos;The value {0}, {1}, {0}&apos;.format(1, 2)

result = &quot;The square root of 5 is {0:.{1}f}&quot;.format(math.sqrt(5), 4)
</code></pre><h4 id="lean-from-koans"><a href="#lean-from-koans" class="headerlink" title="lean from koans"></a>lean from koans</h4><ol>
<li>字符串中换行站一个字符</li>
<li><code>str == &quot;navel&quot;.__class__</code> # True</li>
<li>97 == ord(‘a’)</li>
</ol>
<p>用正则分割 string：</p>
<pre><code>string = &quot;the,rain;in,spain&quot;
pattern = re.compile(&apos;,|;&apos;)
words = pattern.split(string) # list
</code></pre><p>字母大小写处理：</p>
<pre><code>self.assertEqual(&apos;Guido&apos;, &apos;guido&apos;.capitalize())
self.assertEqual(&apos;GUIDO&apos;, &apos;guido&apos;.upper())
self.assertEqual(&apos;timbot&apos;, &apos;TimBot&apos;.lower())
self.assertEqual(&apos;Guido Van Rossum&apos;, &apos;guido van rossum&apos;.title())
self.assertEqual(&apos;tOtAlLy AwEsOmE&apos;, &apos;ToTaLlY aWeSoMe&apos;.swapcase())
</code></pre><p>快速拼接list：</p>
<pre><code>words = [&quot;Now&quot;, &quot;is&quot;, &quot;the&quot;, &quot;time&quot;]
self.assertEqual(&apos;Now is the time&apos;, &apos; &apos;.join(words))
</code></pre><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p><code>True</code></p>
<p><code>False</code></p>
<p>运算：<code>and</code>,<code>or</code>,<code>not</code></p>
<h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><pre><code>None is None # True  There is only one None

isinstance(None, object) # True
</code></pre><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p><code>None</code></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>a = &apos;ANC`
</code></pre><p>上面变量的赋值Python解释器做了两件事：</p>
<ol>
<li>在内存中创建一个<code>ABC</code>字符串</li>
<li>在内存中创建一个名为<code>a</code>的变量，并把它指向<code>ABC</code></li>
</ol>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>使用大写的变量表示常量：</p>
<pre><code>PI = 3.14159
</code></pre><p>实际上PI还是一个变量，Python中没有任何机制来保证他不回改变，这只是开发者定义的使用方法。</p>
<p>除法：</p>
<ol>
<li><code>/</code>：结果是精确的浮点</li>
<li><code>//</code>:地板除，结果还是整数</li>
</ol>
<p>Python的整数和浮点数都没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）</p>
<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>Unicode把所有语言都统一到一套编码里</p>
<p><code>UTF-8</code>编码：可变长的Unicode编码，节省空间</p>
<h3 id="Python-的字符串"><a href="#Python-的字符串" class="headerlink" title="Python 的字符串"></a>Python 的字符串</h3><p>在最新的Python3版本中，字符串是以Unicode编码的，也就是说Python的字符串支持多语言。</p>
<ul>
<li><code>ord()</code>:获取字符的整数表示</li>
<li><code>chr()</code>:把编码转换成对应的字符</li>
<li><code>encode()</code>:方法把字符串编码成指定的<code>bytes</code></li>
<li><code>deocde()</code>:把获取到的字节流转换成字符串</li>
<li><code>len()</code>:获取字符串的长度，或者字节的字节数（由调用对象决定）</li>
</ul>
<p>为了防止乱码，可以在<code>py</code>文件中添加：</p>
<pre><code># -*- coding: utf-8 -*-
</code></pre><p>告诉解释器按照UTF－8编码读取源代码</p>
<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>python中格式化字符串的方式和C语言一致使用<code>%</code>实现：</p>
<pre><code>`hello, %s&apos; % &apos;wordl&apos;
`Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;,1000)
</code></pre><p>占位符：</p>
<ol>
<li><code>%d</code></li>
<li><code>%f</code></li>
<li><code>%s</code></li>
<li><p><code>%x</code></p>
<pre><code>&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)
&apos;  3-01&apos;
&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926
&apos;3.14&apos;
</code></pre></li>
</ol>
<p>注意：<code>%s</code>可是适配任何数据类型，<code>%%</code>来做转义表示一个％</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2><p>Python内置数据类型列表：list，是一种有序集合</p>
<pre><code>classmates = [&apos;python&apos;, &apos;java&apos;, &apos;scheme&apos;]
</code></pre><ul>
<li><code>len(列表对象)</code>:获取列表长度，参数为列表对象</li>
<li>使用索引访问列表中的元素（和数组一样）, 也有切片操作，支持用<code>+</code>号连接</li>
<li>反问最后一个元素快捷方法：<code>classmates[-1]</code>使用－1作为索引，－2表示倒数第二个，以此类推</li>
<li>添加元素：<code>classmates.append(&#39;Adam&#39;)</code>,<code>classmates.insert(1,&#39;Jack&#39;)</code></li>
<li>delete element:<code>classmates.pop()</code>,<code>classmates.pop(1)</code></li>
<li>replace element:<code>classmates[1] = &#39;Sarah&#39;</code></li>
<li>列表中存储的数据类型可以是多种</li>
<li>二维数组实现方式：数组里面的元素也是数组</li>
</ul>
<h3 id="利用切片增-删-改"><a href="#利用切片增-删-改" class="headerlink" title="利用切片增 删 改"></a>利用切片增 删 改</h3><pre><code>lettters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]
letters[2:5]=[&apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
letters[2:5]=[] # remove
letters[:] = [] # clear
</code></pre><h3 id="配合-range-生成-list"><a href="#配合-range-生成-list" class="headerlink" title="配合 range 生成 list"></a>配合 range 生成 list</h3><pre><code>self.assertEqual([5, 4], list(range(5, 3, -1)))
self.assertEqual([0, 2, 4, 6], list(range(0, 8, 2
self.assertEqual([1, 4, 7], list(range(1, 8, 3)))
self.assertEqual([5, 1, -3], list(range(5, -7, -4)))
self.assertEqual([5, 1, -3, -7], list(range(5, -8, -4)))
</code></pre><h3 id="list-一些方法"><a href="#list-一些方法" class="headerlink" title="list 一些方法"></a>list 一些方法</h3><ul>
<li><code>list.append(x)</code></li>
<li><code>list.extend(L)</code>: Extend the list by appending all the items in the given list.</li>
<li><code>list.insert(i, x)</code></li>
<li><code>list.remove(x)</code></li>
<li><code>list.pop([i])</code>:The square brackets around the i in the method signature denote that the parameter is optional, 中括号表示参数是可选的</li>
<li><code>list.clear()</code></li>
<li><code>list.index(x)</code></li>
<li><code>list.count(x)</code></li>
<li><code>list.sort(key=None, reverse=False)</code></li>
<li><code>list.reverse()</code></li>
<li><code>list.copy()</code></li>
</ul>
<h3 id="list-assignments"><a href="#list-assignments" class="headerlink" title="list assignments"></a>list assignments</h3><pre><code>first_name, last_name = [&quot;John&quot;, &quot;Smith&quot;]

title, *first_names, last_name = [&quot;Sir&quot;, &quot;Ricky&quot;, &quot;Bobby&quot;, &quot;Worthington&quot;] # first_names: &quot;Ricky&quot;, &quot;Bobby&quot;
</code></pre><h3 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h3><pre><code>first_name, last_name = last_name, first_name
</code></pre><h3 id="Using-Lists-as-Stacks-堆栈"><a href="#Using-Lists-as-Stacks-堆栈" class="headerlink" title="Using Lists as Stacks 堆栈"></a>Using Lists as Stacks 堆栈</h3><pre><code>list.append(5)
list.pop()
</code></pre><h3 id="Using-Lists-as-Queues-队列"><a href="#Using-Lists-as-Queues-队列" class="headerlink" title="Using Lists as Queues 队列"></a>Using Lists as Queues 队列</h3><pre><code>list.append(2)
list.popleft()
</code></pre><h3 id="List-Comprehensions-列表解析"><a href="#List-Comprehensions-列表解析" class="headerlink" title="List Comprehensions 列表解析"></a>List Comprehensions 列表解析</h3><p>A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses.</p>
<p>一个列表解析器由方括号和<code>for</code>，<code>if</code>表达式组成。</p>
<p>对集合中每个元素进行操作：</p>
<pre><code>squares = list(map(lambda x: x**2, range(10)))
# or better
squares = [x**2 for x in range(10)]
</code></pre><p>列表解析器也可以使用复杂表达式和方法函数：</p>
<pre><code>[str(round(p1, i)) for i in range(1, 6)]
</code></pre><h3 id="Nested-List-Comprehensions"><a href="#Nested-List-Comprehensions" class="headerlink" title="Nested List Comprehensions"></a>Nested List Comprehensions</h3><p>嵌套列表解析器</p>
<pre><code>[[row[i] for row in matrix] for i in range(4)]
</code></pre><h3 id="The-del-statement-删除语句"><a href="#The-del-statement-删除语句" class="headerlink" title="The del statement 删除语句"></a>The del statement 删除语句</h3><p>使用索引删除集合中的元素</p>
<pre><code>a = [-1, 23, 34, 45]
del a[0]
del a[2:3]
del a[:]
del a
</code></pre><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组，一旦初始化就不能修改(immutable)</p>
<p>创建方式：</p>
<pre><code>classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)
# or
classmates = 1234, 2133213, &apos;23432&apos;
</code></pre><p>因为不可变所以更加安全，在代码优先使用 tuple</p>
<p>定义一个元素的 tuple ,需要加逗号，来消除歧义</p>
<pre><code>t = (1, )
(1).__class__ # int
</code></pre><p>没有 append</p>
<pre><code>with self.assertRaises(AttributeError): count_of_three.append(&quot;boom&quot;)
</code></pre><p>tuple -&gt; list:</p>
<pre><code>a = [1, 2]
a = list(a)
a.append(3)
a = tuple(a)
</code></pre><p>str -&gt; tuple:</p>
<pre><code>tuple(&apos;Hello&apos;) # (&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;0&apos;)
</code></pre><h2 id="unpack-list-tuple"><a href="#unpack-list-tuple" class="headerlink" title="unpack list tuple"></a>unpack list tuple</h2><pre><code>a, b = [1, 2]
first, *middle, last = [1, 2, 3, 4, 5 ]
</code></pre><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>和dirt类似不过是key的集合，但是不存储value</p>
<p>基本用途：成员测试和消除重复条目，集合对象还支持并集、 交集、 差和对称差等数学运算。</p>
<p>创建：需要一个list作为输入集合</p>
<pre><code>s = set([1,2,3])
# or
basket = {&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;}
</code></pre><p>由于存储的是key，不可重复,无序</p>
<p>添加：<code>add(key)</code><br>删除：<code>remove(key)</code></p>
<p>可以作交集和并集的操作：</p>
<pre><code>s1 - s2 # letters in a but not in b
s1 &amp; s2 # 交集
s1 | s2 # 并集
a ^ b # letters in a or b but not both
</code></pre><h3 id="set-Comprehensions"><a href="#set-Comprehensions" class="headerlink" title="set Comprehensions"></a>set Comprehensions</h3><pre><code>a = {x for x in &apos;asdfwer&apos; if x not in &apos;abc&apos;}
</code></pre><h3 id="amp-operate"><a href="#amp-operate" class="headerlink" title="&amp; | ^ - operate"></a>&amp; | ^ - operate</h3><pre><code>scotsmen = {&apos;MacLeod&apos;, &apos;Wallace&apos;, &apos;Willie&apos;}
warriors = {&apos;MacLeod&apos;, &apos;Wallace&apos;, &apos;Leonidas&apos;}

self.assertEqual({&apos;Willie&apos;}, scotsmen - warriors)
self.assertEqual({&apos;MacLeod&apos;, &apos;Wallace&apos;, &apos;Willie&apos;, &apos;Leonidas&apos;}, scotsmen | warriors)
self.assertEqual({&apos;MacLeod&apos;, &apos;Wallace&apos;}, scotsmen &amp; warriors)
self.assertEqual({&apos;Willie&apos;, &apos;Leonidas&apos;}, scotsmen ^ warriors)
</code></pre><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><pre><code>{} # dict
self.assertEqual(True, &apos;cow&apos; not in set(&apos;apocalypse now&apos;) )
self.assertEqual(True, set(&apos;cake&apos;).issubset(set(&apos;cherry cake&apos;)) )
</code></pre><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>字典：dictionary, map</p>
<p>创建一个dict</p>
<pre><code>e = dict()
d = {&apos;Michael&apos;:98, &apos;Bob&apos;:76, &apos;Tracy&apos;:98}
</code></pre><p>使用：</p>
<pre><code>d[&apos;Michael&apos;]
</code></pre><p>无论这个字典由多大，他的查询速度都不会变慢，因为dict内部可以直接计算出值的存放位置</p>
<p>获取 keys，获取 values：</p>
<pre><code>d.keys()
d.values()
</code></pre><p>批量插入 keys： values=42</p>
<pre><code>result = {}.fromkeys((&apos;red warrior&apos;, &apos;green elf&apos;, &apos;blue valkyrie&apos;, &apos;yellow dwarf&apos;, &apos;confused looking zebra&apos;), 42)
</code></pre><p>判断key是否存在：</p>
<ol>
<li><p>通过<code>in</code></p>
<p> <code>Michael</code> in d # True:表示存在 ，False 表示不存在</p>
</li>
<li><p>通过<code>get()</code>方法，不存在返回None，或者自己指定的Value</p>
<pre><code>d.get(&apos;Thomas&apos;, -1)
d.get(&apos;Thomas&apos;)
</code></pre></li>
</ol>
<p>注意返回<code>None</code>的时候，交互式命令行不会显示结果</p>
<p>删除key：</p>
<pre><code>d.pop(&apos;Bob&apos;) # 返回被删除的值
</code></pre><p>和list的区别：</p>
<pre><code>1. 查找和插入的速度快
2. 需要占用大量的内存
</code></pre><p>用空间换取速度</p>
<p>通过key计算位置的算法：哈希算法</p>
<ol start="3">
<li><p>loop</p>
<pre><code>for k, v in a_dict.items():
    pass
</code></pre></li>
</ol>
<h4 id="dict-sort"><a href="#dict-sort" class="headerlink" title="dict sort"></a>dict sort</h4><p>通过 zip 将 dict –》zip, max 将 zip –》 list</p>
<pre><code>a = {
    &apos;a&apos;: 12,
    &apos;b&apos;: 34,
    &apos;v&apos;: 1,
    &apos;f&apos;: 123,
}

print(max(zip(a.values(), a.keys())))
print(min(zip(a.values(), a.keys())))
print(sorted(zip(a.values(), a.keys())))
</code></pre><h2 id="条件判断-More-Control-Flow-Tools"><a href="#条件判断-More-Control-Flow-Tools" class="headerlink" title="条件判断 More Control Flow Tools"></a>条件判断 More Control Flow Tools</h2><ul>
<li>if</li>
<li>else</li>
<li>elif</li>
</ul>
<p>注意要加冒号，Python依靠缩进规则会执行判断语句后面的缩进代码</p>
<p>if判断条件简写：</p>
<pre><code>if x:
    print(&apos;True&apos;)
</code></pre><p>只要x是非零数值，非空字符串，非空list等，就判断为True，否则False</p>
<p>比较例子：</p>
<pre><code>23 == 2
23 is 2
&apos;nam&apos; is &apos;name&apos;
n in nums
</code></pre><blockquote>
<p>python没有switch语句，你可以使用if…elif…else语句达到同样的目的(有时用字典代替会更加快捷)。</p>
</blockquote>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><pre><code>s = input(&apos;birth:&apos;)
birth = int(s)
if brith &lt; 2000:
    print(&apos;00 pre&apos;)
else:
    priint(&apos;00 after&apos;)
</code></pre><p>注意：input返回的数据类型是<code>str</code></p>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><pre><code>first = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
last = [&apos;4&apos;, &apos;5&apos;, &apos;6&apos;]
names = zip(first, last) # [(&apos;a&apos;, &apos;4&apos;), (&apos;b&apos;, &apos;5&apos;), (&apos;c&apos;, &apos;6&apos;)]
for a, b in names
print(a, b)
</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="循环-1"><a href="#循环-1" class="headerlink" title="循环"></a>循环</h3><ol>
<li><code>for x in xs</code>,把每个xs中的每个元素代入变量x，然后执行缩进快的语句</li>
<li><code>while</code>,<code>if</code></li>
</ol>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>使用<code>range()</code>生成整数数列：</p>
<pre><code>sum = 0
for x in range(101):
    sum = sum + x
print(sum)

range(3, 5)

range(0, 101, 4) # 0-100每隔三个取一个数 0 4 8
</code></pre><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>跳出循环</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>跳出本次循环，继续下次循环</p>
<h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><p>可共享的代码</p>
<p>Python 支持在一个文件中编写代码然后在运行的时候被其他程序块调用，这样叫做模块。</p>
<p>模块可以被导入到其他模块中使用。</p>
<p>一个Python文件就是一个模块</p>
<h2 id="More-on-Modules"><a href="#More-on-Modules" class="headerlink" title="More on Modules"></a>More on Modules</h2><p>模块中可以包含一段运行代码在模块被引用的时候执行，并只执行一次用作初始化Module。</p>
<p>import 的两种方式：</p>
<pre><code>from fibo import fib, fib2
from fibo import *
</code></pre><h3 id="Executing-modules-as-scripts"><a href="#Executing-modules-as-scripts" class="headerlink" title="Executing modules as scripts"></a>Executing modules as scripts</h3><p>运行一个Python moule:</p>
<pre><code>python3 fibo.py &lt;arguments&gt;
</code></pre><h3 id="The-Module-Search-Path"><a href="#The-Module-Search-Path" class="headerlink" title="The Module Search Path"></a>The Module Search Path</h3><p>脚本运行的时候会优先去内部模块中查找导入的模块，然后在脚本所在目录中查找</p>
<p>模块注释：一个三重引号引起的字符串没有赋给一个变量就会被认为是注释</p>
<pre><code>&quot;&quot;&quot; 。。。。
。。。。
。。。。&quot;&quot;&quot;
</code></pre><h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>包管理模块命名空间。</p>
<h2 id="给模块创建发布"><a href="#给模块创建发布" class="headerlink" title="给模块创建发布"></a>给模块创建发布</h2><ol>
<li>创建一个文件夹，将模块放入</li>
<li><p>创建一个文件<code>setup.py</code><br> 这个文件包含有关发布的元数据</p>
<pre><code>from distutils.core import setup
setup(
    name    =&apos;nester&apos;,
    version =&apos;1.0.0&apos;,
    py_modules  =[&apos;nester&apos;],
    author  =&apos;double&apos;
    author_email    =&apos;sdf@sdf&apos;
    url = &apos;http://asd.com&apos;
    description =&apos;A simple&apos;
)
</code></pre></li>
<li>在上面创建的文件目录下：<pre><code>python3 setup.py sdist
</code></pre></li>
<li>将发布安装到Python本地中：<pre><code>sudo python3 setup.py install
</code></pre></li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>可重用的代码</p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><pre><code>max(2, 3)
</code></pre><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><pre><code>int(...)
float(...)
str(...)
bool(...)
</code></pre><p>函数名：创建一个函数对象的引用</p>
<pre><code>a = abs # 变量a指向abs函数
a(-1) # 调用
</code></pre><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p><code>def</code>语句，函数名，括号，参数，冒号：</p>
<pre><code>def my_abs(x):
    if x&gt;=0:
        return x
    else:
        return -x
</code></pre><h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><pre><code>def nop():
    pass
</code></pre><p><code>pass</code>可以作为占位符，先让代码运行起来，后续再编写，也可以用在if语句块中</p>
<pre><code>if age &gt;= 18:
    pass # 如果没有pass代码就会报错
</code></pre><h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>定义：</p>
<pre><code>def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError(&apos;bad operand type&apos;)
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre><h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>比如返回一个坐标：</p>
<pre><code>import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    my = y - step * math.sin(angle)
    return nx, ny
x, y = move(100, 100, 60, math.pi/6)
</code></pre><p>这里其实函数返回的值是tuple</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>正常的函数参数</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><pre><code>def power(x, n=2):
    s = 1
    while n&gt;0:
        n = n-1
        s = s*x
    return s
</code></pre><p>上面的n表示默认参数，在函数调用的时候可以不指定，只有在调用和默认参数不符合的时候才需要指定第二个参数</p>
<p>注意：默认参数必须指向不变对象,默认参数的位置必须在非默认参数的后面。</p>
<p>如果要将默认参数放在前面： keyword-only<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(a=<span class="number">1</span>, *, b, c)</span>:</span></span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">print_sum(<span class="number">2</span>, b=<span class="number">3</span>, c=<span class="number">3</span>) <span class="comment"># result: 2 3 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="可变参数-Arbitrary-Arguments-Lists"><a href="#可变参数-Arbitrary-Arguments-Lists" class="headerlink" title="可变参数 Arbitrary Arguments Lists"></a>可变参数 Arbitrary Arguments Lists</h3><p>传入集合不方便：</p>
<pre><code>def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre><p>定义可变参数：</p>
<pre><code>def calc(*numbers):
    ....
</code></pre><p>将list或者tuple变成可变参数传入：</p>
<pre><code>nums = [1,2,3]
calc(*nums)
</code></pre><h3 id="关键字参数-Keyword-Arguments"><a href="#关键字参数-Keyword-Arguments" class="headerlink" title="关键字参数 Keyword Arguments"></a>关键字参数 Keyword Arguments</h3><p>一个键值对</p>
<pre><code>def person(name, age, **kw):
    print(&apos;name&apos;, name, &apos;age:&apos;,age, &apos;other:&apos;, kw)
</code></pre><p>关键字参数在函数内部会自动组装成一个dict</p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>检查传入的关键字参数：</p>
<pre><code>def person(name, age, **kw):
    if &apos;city&apos; in kw:
        pass
    if &apos;job&apos; in kw:
        pass
    print(&apos;name:&apos;, name,&apos;age:&apos;,age, &apos;other:&apos;,kw)
</code></pre><p>使用函数：</p>
<pre><code>person(&apos;jack&apos;, 24, city=&apos;Beijing&apos;, addr=&apos;Chaoyang&apos;)
</code></pre><p>限制关键字参数的名字：</p>
<pre><code>def person(name, age, *, city, job):
    pass
</code></pre><p>如果函数中已经定义了可变参数，后面的命名关键字参数就不需要特殊分隔符了：</p>
<pre><code>def persion(name, age, *args, city, job):
    pass
</code></pre><h3 id="unpacking-arguments"><a href="#unpacking-arguments" class="headerlink" title="unpacking arguments"></a>unpacking arguments</h3><p>e.g</p>
<pre><code>nums = [13, 23, 24]

def sums(x, y, z):
    print(x+y+z)

sums(*nums)
</code></pre><h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。</p>
<p>顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<h2 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h2><p>一个不带有返回值的return语句相当于返回return None。</p>
<p>每个函数的末尾都隐含的包含一个return None语句除非你编写了自己的return语句。</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><pre><code>def fact(n):
    if n==1:
        return 1
    return n*fact(n-1)
</code></pre><p>使用递归需要注意防止栈溢出，因为在计算机中，函数调用通过栈（stack）这种数据结构实现的，每一层调用栈内就加一层栈帧，递归由多少层就有多少层栈。</p>
<h3 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><p>方法中只有一个表达式的时候使用：s表示方法参数，s+2 表示结果</p>
<pre><code>s = lambda s: s+2
</code></pre><h3 id="方法文档-DocStrings"><a href="#方法文档-DocStrings" class="headerlink" title="方法文档 DocStrings"></a>方法文档 DocStrings</h3><pre><code>def my_function():
    &quot;&quot;&quot; Do nothing, but document it.

    No, really, it does not do anything.
    &quot;&quot;&quot;
    pass
print(my_function.__doc__)
</code></pre><h1 id="高级特征"><a href="#高级特征" class="headerlink" title="高级特征"></a>高级特征</h1><h2 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 slice"></a>切片 slice</h2><p>取出list或者tuple的部分元素</p>
<pre><code>L[0:3]
</code></pre><p>开始索引和结束索引，如果开始为0可以省略，同样范围是包头不包尾</p>
<p>支持倒数：索引为负数，倒数第一个元素是－1</p>
<ul>
<li>取前10: <code>L[:10]</code></li>
<li>取后10: <code>L[-10:]</code></li>
<li>前11-20: <code>L[10:20]</code></li>
<li>前10个数，每两个取一个: <code>L[:10:2]</code></li>
<li>所有的数，每5个取1个: <code>L[::5]</code></li>
<li>复制一个list: <code>L[:]</code></li>
<li>复制一个倒序list: <code>L[::-1]</code></li>
</ul>
<p>字符串也可以使用切片操作：</p>
<pre><code>&apos;ABCDSS&apos;[:3]
</code></pre><h2 id="迭代-iteration"><a href="#迭代-iteration" class="headerlink" title="迭代 iteration"></a>迭代 iteration</h2><p><code>for...in</code></p>
<p>迭代dict时，默认时迭代key，如果要迭代value：<code>for value in d.values()</code>,同时迭代：<code>for k,v in d.items()</code></p>
<p>字符串也是可迭代对象</p>
<p>判断一个对象是否可迭代：</p>
<pre><code>form collections import Iterable
isinstance(&apos;acb&apos;, Iterable) # str是否可迭代 ， True
</code></pre><p>如果要实现下标循环，可以使用<code>enumerate</code>函数把一个list变成索引－元素对：</p>
<pre><code>for i,value in enumerate([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]):
    print(i, value)
</code></pre><h2 id="列表生成式-List-Comprehensions"><a href="#列表生成式-List-Comprehensions" class="headerlink" title="列表生成式 List Comprehensions"></a>列表生成式 List Comprehensions</h2><p>生成一个整数列表：<code>range(x,y)</code> , x，y表示生成的范围，包头不包尾</p>
<p>生成x＊x的列表：<code>[x * x for x in range(1, 11)]</code></p>
<p>还可以加判断：<code>[x * x for x in range(1, 11) if x % 2 == 0]</code> # [4, 16, 36, 64, 100]</p>
<p>两层循环生成全列表：<code>[m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code></p>
<p>列出单前目录下的全部文件和目录名：</p>
<pre><code>import os
[d for d in os.listdir(&apos;.&apos;)] # os.listdir 可以列出文件和目录
</code></pre><p>使用两个变量来生成列表：<code>[k + &#39;+&#39; + v for k, n in d.items()]</code> # d是一个dict</p>
<p>把list中的所有字符串变成小写：<code>[s.lower for s in L]</code> # L is a list</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<h3 id="创建generator"><a href="#创建generator" class="headerlink" title="创建generator:"></a>创建generator:</h3><p>方法一：将<code>[]</code>–&gt;<code>()</code></p>
<pre><code>L = [x * x for x in range(10)]
g = (x * x for x in range(10))
</code></pre><p>如何打印生成器：<code>next(g)</code>,调用这个方法计算下一个元素的值，直到退后一个元素，没有更多元素的时候抛出<code>StopIteration</code>的错误 ； 使用 <code>for n in g</code></p>
<p>还可以使用函数来生成，比如：</p>
<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return &apos;done&apos;
</code></pre><p>如果函数中包含了关键字<code>yield</code>这个函数就成为了generator</p>
<pre><code>f = fib(6)
</code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>已经知道可用<code>for</code>的有</p>
<ol>
<li><code>list</code>,<code>tuple</code>,<code>dict</code>,<code>set</code>,<code>str</code></li>
<li><code>generator</code>,包括生成器和带<code>yield</code>的generator function</li>
</ol>
<p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code></p>
<p>可以使用<code>isInstance()</code>来判断是否属于某个对象</p>
<p>迭代器都是<code>Iterator</code>对象，但是<code>List</code>,<code>dict</code>,<code>str</code>虽然是<code>Iterable</code>,但不是<code>Iterator</code></p>
<p>将<code>Iterable</code>转化成<code>Iterator</code>: <code>iter()</code></p>
<pre><code>isinstance(iter(&apos;abc&apos;, Iterator))
</code></pre><p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。</p>
<p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>Functional Programming</p>
<p>特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<h2 id="高阶函数-Higher-order-funciton"><a href="#高阶函数-Higher-order-funciton" class="headerlink" title="高阶函数 Higher-order funciton"></a>高阶函数 Higher-order funciton</h2><h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><pre><code>f = abs
</code></pre><h3 id="函数名也是变量"><a href="#函数名也是变量" class="headerlink" title="函数名也是变量"></a>函数名也是变量</h3><pre><code>abs ＝ 10   
abs(-10) # 报错
</code></pre><h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>应为变量可以指向一个函数，所以一个指向函数的变量也可以作为参数传入一个函数，就成为了一个高阶函数</p>
<pre><code>def add(x, y, f):
    return f(x) + f(y)
</code></pre><p>高阶函数：将函数作为参数</p>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p><code>map()</code>,<code>reduce()</code></p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>接收两个参数：1. 函数 2. Iterable</p>
<p>返回结果：Iterator,惰性序列</p>
<pre><code>def f(x):
    return x * x

r = map(f, [1, 2, 3, 4])
list(r) # [1, 2, 9, 16]
</code></pre><p>map返回的是惰性序列，因此需要通过<code>list()</code>函数把整个序列都计算出来返回一个list</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>接收两个参数： 1. 函数 2. Iterable</p>
<p>将结果继续和序列的下一个元素作累积计算：求和</p>
<pre><code>from functools import reduce
def add(x,y ):
    return x + y
reduce(add, [1, 2, 3, 4])
</code></pre><p>将序列[1, 2, 3]–&gt; 123:</p>
<pre><code>from functools import reduce
def fn(x, y):
    return x*10+y
reduce(fn,[1, 2, 3])
</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>用于过滤序列</p>
<p>将函数作用于每个元素，返回<code>True</code>表示删除,<code>False</code>留下</p>
<p>返回的结果也是<code>Iterator</code></p>
<h4 id="用fliter求素数"><a href="#用fliter求素数" class="headerlink" title="用fliter求素数"></a>用fliter求素数</h4><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>Python内置<code>sorted()</code></p>
<pre><code>sorted([23,45,76])
</code></pre><p>是一个高阶函数，还可以接收一个key函数来自定义排序方式</p>
<p>比如按绝对值大小排序：</p>
<pre><code>sorted([23,23,23,], key=abs)
</code></pre><p>反向排序：</p>
<pre><code>sorted([&apos;wer&apos;,&apos;sdfdf&apos;,&apos;sdfe&apos;,&apos;df&apos;], key=str.lower, reverse=True)
</code></pre><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数：除了可以将函数作为参数，同时也可以将函数作为返回值</p>
<h3 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包 Closure"></a>闭包 Closure</h3><p>闭包函数没有立即执行，返回函数不要引用任何循环变量，或者后续会发生变化的量。</p>
<p>如果要引用循环变量：</p>
<pre><code>def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i) 立即被执行，因此i的当前值被传入f()
    return fs
</code></pre><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数有个限制：就是只能有一个表达式，不同写<code>return</code>，返回值就是表达式的结果</p>
<p>好处： 1. 不用写函数名，不同担心函数名冲突 2. 匿名函数也可以被变量指向</p>
<pre><code>f = lambda x: x * x
</code></pre><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>函数对象有一个<code>_name_</code>属性，可以拿到函数的名字：</p>
<pre><code>def now():
    print(&apos;2016-8-14&apos;)
f = now
now._name_ # &apos;name&apos;
f._name_ # &apos;now&apos;
</code></pre><p>使用装饰器扩张函数的功能</p>
<pre><code>def log(func):
    def wrapper(*args, **kw):
        print(&apos;call %s():&apos;, % func._name_)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&apos;2016-8-14&apos;)
</code></pre><p>调用now不回执行函数本身</p>
<p>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。</p>
<p>wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>
<h2 id="偏函数-Partial-function"><a href="#偏函数-Partial-function" class="headerlink" title="偏函数 Partial function"></a>偏函数 Partial function</h2><p>Python的<code>functools</code>模块提供了很多有用的功能</p>
<p>n进制转换</p>
<pre><code>int(&apos;1234&apos;, base=8)

def int8(x, base=2):
    return int(x,base)
</code></pre><p>创建偏函数：</p>
<pre><code>import functools
int8 = functools.partial(int, base=8)
</code></pre><p>偏函数的作用就是把一个函数的参数给固定住，也就是设置默认值，返回一个新的函数，方便使用。</p>
<p>也可以接收函数对象，<code>*args</code>,<code>**kw</code></p>
<p>**kw:</p>
<pre><code>kw = {&apos;base&apos;:2}
int(&apos;10010&apos;, **kw)
</code></pre><p>*args:</p>
<pre><code>max2 = functools.partial(max, 10) # 实际上是把10加到了max参数中
max2(4,5,3) # 结果是 10
</code></pre><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>一个<code>.py</code>文件可以称为一个模块（Module）</p>
<p>好处：</p>
<ol>
<li>提高代码的可维护性</li>
<li>复用性好</li>
</ol>
<p>为了避免函数名相同，Python中有包来阻止模块</p>
<p>每个包的目录下都会有一个<code>_init_.py</code>文件，</p>
<h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>private：<code>_xxx</code>,用于代码封装</p>
<h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>Python中安装第三方包是通过pip包管理工具完成的</p>
<h1 id="面向对象编程-oop"><a href="#面向对象编程-oop" class="headerlink" title="面向对象编程 oop"></a>面向对象编程 oop</h1><p>定义一个对象：</p>
<pre><code>class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print(&apos;%s: %s&apos; % (self.name, self.score))
</code></pre><p>给对象发送消息实际上是调用对象的方法：</p>
<pre><code>lisa = Student(&apos;Lisa Simpson&apos;, 87)
lisa.print_score()
</code></pre><p>三大特征：封装，继承，多态</p>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><pre><code>class Student(object):
    pass
</code></pre><p>类关键字，类名，参数为其父类</p>
<p>构造方法：</p>
<pre><code>def __init__(self, name, score):
    self.name = name
    self.score = score
</code></pre><p>注意这里的第一个参数永远是<code>self</code></p>
<p>使用构造方法：</p>
<pre><code>bart = Student(&apos;Bart Simpson&apos;, 87)
</code></pre><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><pre><code>def print_score(self):
    print(&apos;%s: %s&apos; % (self.name, self.score))

bart.print_score()
</code></pre><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>让内部属性不被外部访问，加<code>_</code>即可；</p>
<pre><code>class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print(&apos;%s: %s&apos; % (self.__name, self.__score))

    def get_name(self):
        return self.__name
    def get_score(self):
        return self._score
    def set_score(self, score):
        if 0&lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueEoor(&apos;bad score&apos;)
</code></pre><p>访问双下划线的实例变量：其实Python只是更改了属性名</p>
<pre><code>bart._student__name ＃ 但是不同的Python解释器可能会把__name改成不同的变量名
</code></pre><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><pre><code>class Dog(Animal):
    def eat(self):
        print(&apos;Dog eatting....&apos;)
</code></pre><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><h3 id="使用-type"><a href="#使用-type" class="headerlink" title="使用 type()"></a>使用 type()</h3><pre><code>type(123) # &lt;class &apos;int&apos;&gt;
type(abs) # &lt;class &apos;builtin_function_or_method&apos;&gt;
</code></pre><p>返回的是Class类型：</p>
<pre><code>type(13) == int # True
</code></pre><p>判断一个对象是否是函数：</p>
<pre><code>import types
def fn():
    pass

type(fn) == types.FunctionType # True
type(lambda x: x)==types.LambdaType
types.BuiltinFunctionType
types.GeneratorType
</code></pre><h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><pre><code>isinstance(a, b)
</code></pre><h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>获取一个对象的所有属性和方法：</p>
<pre><code>dir(&apos;ABC&apos;)
</code></pre><p>属性：</p>
<p>getattr():</p>
<pre><code>getattr(obj, &apos;z&apos;) ＃如果属性不存在会报错
getattr(obj, &apos;z&apos;, 404) # 如果属性不存在就返回 404
</code></pre><p>setattr():</p>
<pre><code>setattr(obj, &apos;y&apos;, 19)
</code></pre><p>hasattr():</p>
<pre><code>hasattr(obj, &apos;power&apos;)
</code></pre><h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>定义一个类属性：</p>
<pre><code>class Student(object):
    name = &apos;Student&apos;
</code></pre><p>类的所有实例都能访问到这个属性</p>
<p>注意不要把实例属性和类属性使用相同的名称，实例属性会屏蔽掉类属性</p>
<h1 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h1><h2 id="使用-slots"><a href="#使用-slots" class="headerlink" title="使用 __slots"></a>使用 __slots</h2><p>在创建一个class的实例后给实例绑定任何属性和方法：</p>
<pre><code>class Student(object):
    pass

s = Student()
s.name = &apos;Michael&apos; #绑定属性

def set_age(self ,age):
    self.age = age
from types import MethodType
s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25) # 调用方法
s.age # 25
</code></pre><p>给一个实例绑定的方法或者属性，对另一个实例是不起作用的</p>
<p>给class绑定方法：</p>
<pre><code>def set_score(self, score):
    self.score = score

Student.set_score = set_score
</code></pre><h3 id="使用-slots-1"><a href="#使用-slots-1" class="headerlink" title="使用 slots"></a>使用 <strong>slots</strong></h3><p>限制实例的属性，在定义class的时候，定义一个特殊的<code>__slots__</code>变量：</p>
<pre><code>class Student(object):
    __slots_- = (&apos;name&apos;, &apos;age&apos;) # 使用tuple定义允许绑定的属性名称
</code></pre><p>如果绑定没有定义的属性会报错：<code>AttributeError</code></p>
<p>限制对于其子类没有作用</p>
<h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p>负责把一个方法变成属性调用：</p>
<pre><code>class Student(object):
    @property
    def score(self):
        return self._score

    @score.setter
    def score(self ,value):
        if not isinstance(value, int):
            reise ValueError(&apos;scroe must be an integer!&apos;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&apos;score must between 0 -100!&apos;)
        self._score = value
</code></pre><p>使用：<br>    s = Student()<br>    s.score = 60 # s.set_score(60)<br>    s.score # s.get_score()</p>
<p>只读属性：上面的类去掉<a href="mailto:`@score.setter" target="_blank" rel="noopener">`@score.setter</a> 后面的函数`，score就成了自读属性</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><pre><code>class Dog(Mammal, Runnable):
    pass
</code></pre><h3 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h3><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>看到类似<code>__xxx__</code>的变量或者函数名就要注意这些在Python中是有特殊用途的。</p>
<p>比如：</p>
<ol>
<li><code>__slots__</code></li>
<li><code>__len__</code></li>
<li><p><code>__str__</code></p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name
    __repr__ = __str__
</code></pre><p> <code>print(Student(&#39;Michael&#39;))</code>:调用<code>__str__()</code><br> <code>s</code>:调用<code>__repr__()</code></p>
</li>
<li><p><code>__iter__</code>:如果一个类被用于<code>for..in</code>循环就需要实现这个方法，该方法返回一个迭代对象，然后Python的for循环就会不断调用这个迭代对象的<code>__next__()</code>方法获取下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p>
<pre><code>class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1
    def __iter__(self):
        return self
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b
        if self.a &gt; 10000:
            raise StopIteration();
        return self.a
</code></pre></li>
<li><p><code>__getitem__</code>:如果要让对象实现下标操作 <code>f = Fib()   f[0]</code></p>
<pre><code>class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if ininstance(n, slice):
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x&gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
</code></pre></li>
</ol>
<ol start="6">
<li><code>__setitem__</code></li>
<li><code>__delitem__</code></li>
<li><p><code>__getattr__</code>:正常情况调用类没有定义的方法或者属性的时候会报错，可以通过定义这个方法避免一部分</p>
<pre><code>class Student(object):
    def __init__(self):
        self.name = &apos;Michael&apos;
    def __getattr__(self, attr):
        if attr == &apos;score&apos;
            return 99
</code></pre><p> 当调用不存在的属性的时候，Python解释器就会调用<code>__getattr</code>来尝试获取属性</p>
<p> 这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。<br> 作用：可以针对完全动态的情况作调用。</p>
<p> REST API：链式调用：</p>
<pre><code>class Chain(object):
    def __init__(self, path=&apos;&apos;):
        self._path = path
    def __getattr__(self, path):
        return Chain(&apos;%s/%s&apos; % (self.path, path))
    def __str__(self):
        return self._path
    __repr__ = __str__
</code></pre><p> 使用：</p>
<pre><code>Chain().status.user.timeline.list # /status/user/timeline/list
</code></pre><p> 这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！<br> 还有些REST API会把参数放在URL中：GitHub的API</p>
<pre><code>GET /users/:user/repos
Chain().users(&apos;michael&apos;).repos
</code></pre></li>
<li><p><code>__call__</code>:调用自身的方法:</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name
    def __call__(self):
        print(&apos;My name is %s.&apos; % self.name)
</code></pre><p> 使用：</p>
<pre><code>s = Student(&apos;Michael&apos;)
s()
</code></pre><p> 对象能否调用的判断方式：是否是<code>Callable</code>对象</p>
<pre><code>callable(Student()) # True
callable(max) # True
</code></pre></li>
</ol>
<h2 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h2><p><code>Enum</code></p>
<pre><code>from enum import Enum

Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;))
</code></pre><p>定义了<code>Month</code>类型的枚举类，使用<code>Month.Jan</code>来引用常量，或者枚举所有成员：</p>
<pre><code>for name, member in Month.__members__.items():
    print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)
</code></pre><p>更精确控制枚举类型：自定义类</p>
<pre><code>from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0
    Mon = 1
    Tue = 2
</code></pre><p><code>@unique</code>装饰器保证没有重复的值</p>
<p>访问枚举类型的方法：</p>
<pre><code>day1 = Weekday.Mon
day2 = Weekday[&apos;Tue&apos;] # Weekday.Tue
day3 = Weekday.Tue.value # 2
day4 = Weekday(1) # Weekday.Mon

for name, member in Weekday.__members__.items():
    pass   # Sun =&gt; Weekday.Sun
</code></pre><h2 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h2><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p>
<p><code>tyoe()</code>查看一个类型或者变量的类型：</p>
<pre><code>type(Hello) # &lt;class &apos;type&apos;&gt;
type(h) # &lt;class &apos;hello.Hello&apos;&gt;
</code></pre><p>通过<code>type</code>创建一个类：</p>
<pre><code>1. class 的名称
2. 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；
3. class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。
</code></pre><h3 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h3><p>控制类的创建行为的第二种方式</p>
<p>元类：先定义类，然后创建实例，先定义metaclass，然后创建类。</p>
<p>先定义metaclass，就可以创建类，最后创建实例。</p>
<p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p>
<p>。。跳过</p>
<h1 id="错误和调试"><a href="#错误和调试" class="headerlink" title="错误和调试"></a>错误和调试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><pre><code>try:
    print(&apos;try...&apos;)
    r = 10 / 0
    print(&apos;result:&apos;, r)
except ZeroDivisionError as e:
    print(&apos;except:&apos;, e)
except:
    pass
fnally:
    print(&apos;finally...&apos;)
print(&apos;END&apos;)
</code></pre><p>所有的错误类型都继承自<code>BaseException</code></p>
<h3 id="获取错误信息"><a href="#获取错误信息" class="headerlink" title="获取错误信息"></a>获取错误信息</h3><pre><code>e.args[0]
</code></pre><h3 id="异常类-Exception"><a href="#异常类-Exception" class="headerlink" title="异常类 Exception"></a>异常类 Exception</h3><p>获取 异常名 包括父类：</p>
<pre><code>class MySpecialError(RuntimeError):
    pass

mro = MySpecialError.mro()
self.assertEqual(&apos;RuntimeError&apos;, mro[1].__name__)
self.assertEqual(&apos;Exception&apos;, mro[2].__name__)
self.assertEqual(&apos;BaseException&apos;, mro[3].__name__)
self.assertEqual(&apos;object&apos;, mro[4].__name__)
</code></pre><h3 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h3><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获</p>
<h3 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h3><p>Python内置<code>logging</code>模块记录错误信息：</p>
<pre><code># err_logging.py
import logging

logging.exception(e)
</code></pre><p>通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</p>
<h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>定义自己的错误：</p>
<pre><code>class FooErrr(ValueError)
    pass
def foo(s):
    n = int(s)
    if n==0
        raise FooError(&apos;invalid value: %s&apos; % s)
    return 10/n

foo(&apos;0&apos;)
</code></pre><p>aise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><pre><code>assert n != 0, &apos;n is zero!&apos;
</code></pre><p>断言的意思是这里<code>n!=0</code>应该为True，否则程序后面的代码会出错</p>
<p>关闭断言： <code>-0</code></p>
<p>关闭后所有的assert语句被当成pass处理</p>
<h3 id="loggin"><a href="#loggin" class="headerlink" title="loggin"></a>loggin</h3><pre><code>logging.info() # 输出一段文本
logging.basicConfig(level=logging.INFO) # 设置logging的级别
</code></pre><p>logging也可以通过配置，设置输出到文件中</p>
<h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><p>让程序单步运行</p>
<pre><code>python3 -m pdb err.py
1 # 查看代码
n # 单步执行代码
p 变量名 # 查看变量
q # 结束调试
</code></pre><h3 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace()"></a>pdb.set_trace()</h3><p> 设置断点</p>
<pre><code>c # 继续运行
</code></pre><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>
<h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p><code>open()</code>:</p>
<pre><code>f = open(`/Users/michael/test.txt`,&apos;r&apos;) # r 表示读， 如果文件不存在报错：`IOError` w, a
</code></pre><p>文件打开成功后：</p>
<pre><code>f.read() # 返回文件中的 str
</code></pre><p>关闭文件：</p>
<pre><code>f.close(()
</code></pre><p>完整流程：</p>
<pre><code>try:
    f = open(&apos;/path&apos;, &apos;r&apos;)
        print(f.read())
finally:
    if f:
        f.close()
</code></pre><p>简化，自动关闭：</p>
<pre><code>with open(&apos;/path&apos;,&apos;r&apos;) as  f:
    print(f.read())
</code></pre><p>read不设置读取量的时候，容易内存溢出，可以设置读取量：</p>
<pre><code>for line in f.readlines():
    print(line.strip()) # 把末尾 \n 去掉

f.read(size) # size 读取子节数
</code></pre><h3 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h3><p>具有<code>read()</code>方法的对象</p>
<p>比如:<code>StringIO</code></p>
<h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><pre><code>f = open(&apos;/path&apos;,&apos;rb&apos;)
f.read() # 输出十六进制表示的子节
</code></pre><h3 id="字符编码-1"><a href="#字符编码-1" class="headerlink" title="字符编码"></a>字符编码</h3><pre><code>f = open(&apos;/open&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)
f.read()
</code></pre><p>遇到编码不规范的文件会<code>UnicodeDecodeError</code>:</p>
<pre><code>f = open(&apos;/path&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;)
</code></pre><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件</p>
<p>要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。</p>
<h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>在内存中读写，在内存中读写str，先创建StringIO，然后像文件一样写入即可：</p>
<pre><code>from io import StringIO
f = StringIO()
f.write(&apos;hello&apos;) # 返回 5 字符数
f.getvalue() # 获取之前写入的所有字符

from io import StringIO
f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)
while True:
    s = f.readline()
    if s == &apos;&apos;:
        break
    print(s.strop())
</code></pre><h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>内存中读写二进制，创建一个，然后写入</p>
<pre><code>from io import BytesIO
f = BytesIO()
f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))
print(f.getvalue9)) # 十六进制

from io import StringIO
f = BytesIO(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)
f.read() # b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;
</code></pre><h2 id="操作文件盒目录"><a href="#操作文件盒目录" class="headerlink" title="操作文件盒目录"></a>操作文件盒目录</h2><p>使用<code>os</code>模块：</p>
<pre><code>import os
os.name # 操作系统 posix:linux,Unix,Mac os; nt: Windows
</code></pre><p>获取系统详细信息：</p>
<pre><code>os.uname() # 在 Window 中无效
</code></pre><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><pre><code>os.environ
</code></pre><p>获取某个环境变量的值：</p>
<pre><code>os.environ.get(&apos;key&apos;)
</code></pre><h3 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><p>操作文件和目录的函数在：<code>os</code>,<code>os.path</code>模块中：</p>
<pre><code># 查看当前目录的绝对路径：
os.path.abspath(&apos;.&apos;) # /Users/michael
# 在某目录下创建一个新目录， 1. 获取完整路径
os.path.join(&apos;/Users/michael&apos;,&apos;testdir&apos;) # &apos;/Users/michael/testdir&apos; 返回目录
# 2. mkdir
os.mkdir(‘上面代码创建的目录’)
# rm
os.rmkdir(&apos;path....&apos;)
</code></pre><p>合成两个路径的时候，不要直接使用字符串拼接，而要通过<code>os.path.join()</code>,保证正确处理不同的操作系统的路径分隔符：linux,unix,mac:<code>/</code>; Window:<code>\</code></p>
<p>拆分路径：<code>os.path.split()</code> 会自动分隔路径和文件名；<code>os.path.splitext()</code>分隔文件的扩展名 <code>(&#39;/path/to/file&#39;, &#39;.txt&#39;)</code></p>
<p>文件操作：</p>
<pre><code>os.rename(&apos;test.text&apos;,&apos;test.py&apos;)
os.remove(&apos;test.py&apos;)
</code></pre><p><code>os</code>模块中没有复制文件的操作，因为复制文件不是操作系统提供的系统调用，<code>shutil</code>中提供了文件复制的操作，可以看作是’os’模块的补充。</p>
<p>过滤文件：</p>
<pre><code>[x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)] # 获取目录中的所有目录

[x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;] # 获取目录下的 py 文件
</code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><code>pickling</code>,<code>unpickling</code></p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>Python提供了<code>pickle</code>模块来实现序列化：</p>
<pre><code>import pickle
d = dict(name=&apos;Bob&apos;, age=20, score=88)
pickle.dumps(d) # 方法一 这个方法将对象序列化成 bytes 然后写入文件

f = open(&apos;dump.txt&apos;, &apos;wb&apos;) # 方法二
pickle.dump(d, f)
f.close()
</code></pre><p>读取文件中的对象：</p>
<pre><code>f = open(&apos;dump.txt&apos;, &apos;rb&apos;)
d = pickle.load(f)
f.close() # d: {&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;}
</code></pre><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>Python内置的<code>json</code>模块： Python对象变成JSON</p>
<pre><code>import json
d = dict(name=&apos;Bob&apos;, age=20, score=88)
json.dumps(d) #&apos;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&apos;
</code></pre><p>类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>
<p>JSON to 对象使用<code>loads()</code>,<code>load()</code>前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化:</p>
<pre><code>json_str = &apos;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&apos;
json.loads(json_str) # {&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;}
</code></pre><h3 id="JSON-进阶"><a href="#JSON-进阶" class="headerlink" title="JSON 进阶"></a>JSON 进阶</h3><p>Python 的 <code>dict</code>对象可以直接序列化为JSON的<code>{}</code>,不过我们一般使用<code>class</code>表示对象：</p>
<pre><code>s = Student(&apos;Bob&apos;, 20, 88)
print(json.dumps(s))
</code></pre><p>对象实现可序列化：</p>
<pre><code>def student2dict(std):
    return{
        &apos;name&apos;:std.name,
        &apos;age&apos;:std.age,
        &apos;score&apos;: std.score
    }
</code></pre><p>这样Student对象会先通过上门的函数转换成<code>dict</code>对象，然后被序列化</p>
<pre><code>print(json.dumps(s, default=student2dict))

print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre><p>json反序列化：</p>
<pre><code>def dict2student(d):
    return Student(d[&apos;name&apos;], d[&apos;age&apos;], d[&apos;score&apos;])
</code></pre><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>在Python程序中创建子进程：</p>
<pre><code>import os
print(&apos;Process (%s) start...&apos; % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid ==0:
    print(&apos;I am child process (%s) and my parent is %s.&apos; % (os.getpid(), os.getpid()))
else:
    print(&apos;I (%s) just created a child precess(%s).&apos; % (os.getpid()), pid)
</code></pre><p>运行结果：</p>
<pre><code>Process (876) start...
I (876) just created a child process (877).
I am child process (877) and my parent is 876.
</code></pre><p>由于Window中没有<code>fork</code>调用，所以上门的代码在Windows中无效</p>
<p>一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>提供跨平台的多进程模块</p>
<p>启动一个子进程并等待其结束：</p>
<pre><code>from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print(&apos;Run child process %s (%s)...&apos; % (name, os.getpid()))
if __name__ == &apos;__main__&apos;:
    print(&apos;Parent process %s.&apos; % os.getpid())
    p = Process(target=run_proc, args=(&apos;test&apos;, ))
    print(Child process will start.&apos;&apos;)
    p.start()
    p.join()
    print(&apos;Child process end.&apos;)
</code></pre><p>执行结果：</p>
<pre><code>Parent process 928.
Process will start.
Run child process test (929)...
Process end.
</code></pre><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。</p>
<p>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p><code>subprocess</code>启动一个子进程，然后控制其输入和输出。</p>
<pre><code>import subprocess

print(&apos;$ nslookup www.python.org&apos;)
r = subprocess.call([&apos;nslookup&apos;, &apos;www.python.org&apos;])
print(&apos;Exit code:&apos;, r)
</code></pre><h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><p>Python的<code>multiprocessing</code>模块包装了底层机制，提供<code>Queue</code>,<code>Pipes</code>等方式来实现交互</p>
<pre><code>from multiprocess import Process, Queue
import os, time, random

# 写数据进进程执行的代码：
def write(q):
    print(&apos;Process to write: %s&apos; % os.getpid())
    for value in [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]:
        print(&apos;Put %s to queue...&apos; % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码：
def read(q):
    print(&apos;Process to read: %s&apos; % os.getpid())
    while True:
        value = q.get(True)
        print(&apos;Get %s from queue.&apos; % value)

if __name__==&apos;__main__&apos;:
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target = write, args=(q, ))
    pr = Process(target=read, args=(q, ))
    #启动子进程pw，写入：
    pw.start()
    # 启动子进程pr，读取：
    pr.start()
    # 等待pw结束：
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止：
    pr.terminate()

    Process to write: 50563
    Put A to queue...
    Process to read: 50564
    Get A from queue.
    Put B to queue...
    Get B from queue.
    Put C to queue...
    Get C from queue.
</code></pre><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><code>_thread</code>:低级模块<br><code>threading</code>:高级模块，对<code>_thread</code>的封装</p>
<pre><code>import time, threading

# 新线程执行的代码：
def loop():
    print(&apos;thread %s is running...&apos; % threading.current_thread().name)
    n = 0
    while n &lt; 5:
        n = n + 1
        print(&apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name,n))
        time.sleep(1)
    print(&apos;thread %s ended.&apos; % threading.current_thread().name)

print(&apos;thread %s is running...&apos; % threading.current_thread().name)
t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)
t.start()
t.join()
print(&apos;thread %s ended.&apos; % threading.current_thread().name)


thread MainThread is running...
thread LoopThread is running...
thread LoopThread &gt;&gt;&gt; 1
thread LoopThread &gt;&gt;&gt; 2
thread LoopThread &gt;&gt;&gt; 3
thread LoopThread &gt;&gt;&gt; 4
thread LoopThread &gt;&gt;&gt; 5
thread LoopThread ended.
thread MainThread ended.
</code></pre><p>任何进程都有一个默认线程：主线程（MainThread）</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>多线程中，所有变量都由所有线程共享,并发问题解决：</p>
<pre><code>balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先获取锁
        lock.acquire()
        try:
           change_it(n)
        finally:
            lock.release()
</code></pre><h3 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h3><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p>
<pre><code>import threading
# 创建全局ThreadLocal对象
local_school = threading.local()

def process_student():
    # 获取当前线程关联的student
    std = local_school.student
    print(&apos;Hello, %s(in %s)&apos; % (std, threading.current_thread().name))
def process_thread(name):
    # 绑定ThreadLocal的student：
    local_school.student = name
    process_student()

t1 = threading.Thread(target=process_thread, args=(&apos;Alice&apos;,) name=&apos;Thread-A&apos;)
t2 = threading.Thread(target=process_thread, args=(&apos;Bob&apos;, ) name=&apos;Thread-B&apos;)
t1.start()
t2.start()
t1.join()
t2.join()

# 结果
Hello, Alice (in Thread-A)
Hello, Bob (in Thread-B)
</code></pre><h2 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs. 线程"></a>进程 vs. 线程</h2><p>Master-Worker模式，Master负责分配任务，Worker负责执行任务。</p>
<p>对进程模式：最大优点稳定性高，进程奔溃不回影响其他进程，但是性能消耗大</p>
<p>多线程模式：比多进程快一点，但是任何一个线程奔溃会影响整个进程</p>
<h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>线程或者进程过多，切换回耗时影响性能。</p>
<h2 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h2><h1 id="常用内建模块"><a href="#常用内建模块" class="headerlink" title="常用内建模块"></a>常用内建模块</h1><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(<span class="string">'The command line arguments are:'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python using_sys.py we are arguments</span></span><br><span class="line"><span class="comment"># result: using_sys.py   we are arguments 输入的参数</span></span><br></pre></td></tr></table></figure>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a><strong>name</strong> 属性</h2><p>每个模块都有一个名字，并且通过模块中的某些语句可以得到这个模块名。</p>
<p>在一些想要搞清模块是独立运行还是被导入的情况下，这会非常方便。</p>
<p>当模块第一次被导入时模块中的代码会被执行。</p>
<p>据此改变模块独立执行时的行为方式。（注：独立运行是指程序最开始运行的那个脚本文件(/模块)）</p>
<p>每个python模块都有自己的<strong>name</strong>定义，如果它是’<strong>main</strong>’则暗示模块为独立运行，我们可以进行一些适当的处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'This program is being run by itself'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'I am being imported form another module'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建自己的模块"><a href="#创建自己的模块" class="headerlink" title="创建自己的模块"></a>创建自己的模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Filename: mymodule.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Hi, this is mymodule speaking.'</span>)</span><br><span class="line"></span><br><span class="line">__version__ = <span class="string">'0.1'</span></span><br></pre></td></tr></table></figure>
<p>##</p>
<h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p>Python处理日期和时间的标准库</p>
<h3 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h3><pre><code>from datetime import datetime
now = datetime.now()
print(now) # 2015-05-18 16:28:07.198690
print(type(now)) # &lt;class &apos;datetime.datetime&apos;&gt;
</code></pre><p><code>datetime</code>模块还包有<code>datetime</code>类</p>
<h3 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h3><pre><code>from datetime import datetime
dt = datetime(2016, 8, 18, 12, 23)
print(dt) # 2016-08-18 12:23:00
</code></pre><h3 id="datetime-转换成-timestamp"><a href="#datetime-转换成-timestamp" class="headerlink" title="datetime 转换成 timestamp"></a>datetime 转换成 timestamp</h3><pre><code>from datetime import datetime
dt = datetime(2016, 8, 18, 23, 23)
dt.timestamp() # 14232323232.0
</code></pre><h3 id="timestamp-–-gt-datetime"><a href="#timestamp-–-gt-datetime" class="headerlink" title="timestamp –&gt; datetime"></a>timestamp –&gt; datetime</h3><pre><code>from datetime import datetime
t = 1429417200.0
print(datetime.fromtimestamp(t)) # 2015-04-19 12:20:00 local time
</code></pre><p>注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</p>
<pre><code>datetime.utcfromtimestamp(t) # UTC time
</code></pre><h3 id="str-–-gt-datetime"><a href="#str-–-gt-datetime" class="headerlink" title="str –&gt; datetime"></a>str –&gt; datetime</h3><pre><code>from datetime import datetime
cday = datetime.strptime(&apos;2015-6-1 18:19:23&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)
print(cday) #2015-6-1 18:19:23
</code></pre><h3 id="datetime-–-gt-str"><a href="#datetime-–-gt-str" class="headerlink" title="datetime –&gt; str"></a>datetime –&gt; str</h3><pre><code>form datetime import datetime
now = datetime.now()
print(now.strftime(&apos;%a, %b %d %H:%M&apos;)) # Mon, May 05 16:28
</code></pre><h3 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h3><pre><code>from datetime import datetime, timedelta
now = datetime.now()
now + timedelta(hours=10)
now - timedelta(days=1)
now + timedelta(days=2, hours=12)
</code></pre><h3 id="本地时间-–-gt-UTC"><a href="#本地时间-–-gt-UTC" class="headerlink" title="本地时间 –&gt; UTC"></a>本地时间 –&gt; UTC</h3><pre><code>from datetime import datetime, timedelta, timezone
tz_ut_8 = timezone(dimedelta(hours=8)) # 创建时区UTC＋8:00
</code></pre><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p>Python内建的一个集合模块，提供许多有用的集合类。</p>
<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>重命名一个<code>tuple</code>:</p>
<pre><code>from collections import namedtuple
Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])
p = Point(1, 2)
p.x # 1
p.y # 2
</code></pre><p><code>namedtuple</code>是一个函数，用来自定义<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，可以用属性而不是索引来引用<code>tuple</code>的某个元素</p>
<pre><code>isinstance(p, Point) # True
isinstance(p, tuple) # True
</code></pre><p>使用坐标和半径表示一个圆：</p>
<pre><code>Circle = namedtuple(&apos;Circle&apos;, [&apos;x&apos;, &apos;y&apos;, &apos;r&apos;])
</code></pre><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>使用<code>list</code>存储数据时，按索引查询访问元素很快，但是插入和删除元素就很慢。</p>
<p><code>deque</code>是为了实现高效插入和删除操作的双向列表，适合于队列和栈：</p>
<pre><code>from collections import deque
q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])
q.append(&apos;x&apos;)
q.appendleft(&apos;y&apos;)
# q.append(.) q.pop(.) q.appendleft(.) q.popleft(.)
</code></pre><h3 id="defalutdict"><a href="#defalutdict" class="headerlink" title="defalutdict"></a>defalutdict</h3><p>使用<code>dict</code>时，如果Key不存在就会报错<code>KeyError</code>,如果希望Key不存在的时候返回默认值：</p>
<pre><code>from collections import defalutdict
dd = defaultdict(lambda: &apos;N/A&apos;)
dd[&apos;Key1&apos;] = &apos;abc&apos;
dd[&apos;key1&apos;] # &apos;abc&apos;
dd[&apos;key2&apos;] # &apos;N/A&apos;
</code></pre><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>使用<code>dict</code>时，Key是无序的，在对<code>dict</code>作迭代的时候无法确定Key的顺序，如果要保持Key的顺序：</p>
<pre><code>from collections import OrderedDict
d = dict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])
d # dict key 是无序的
od = OrderedDict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])
# key 有序 按照插入的顺序排列
</code></pre><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>简单的计数器</p>
<p>统计字符出现的次数：</p>
<pre><code>from collections import Counter
c = Counter()
for ch in &apos;programming&apos;
    c[ch] = c[ch] +1
c # Counter({&apos;g&apos;: 2, &apos;m&apos;: 2, &apos;r&apos;: 2, &apos;a&apos;: 1, &apos;i&apos;: 1, &apos;o&apos;: 1, &apos;n&apos;: 1, &apos;p&apos;: 1})
</code></pre><p>实际是一个<code>dict</code>的子类</p>
<h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><p>Base64 编码：使用64个字符来表示任意二进制</p>
<pre><code>import base64
base64.b64encode(b&apos;binary\x00string&apos;)# b&apos;YmluYXJ5AHN0cmluZw==&apos;
base64.b64decode(b&apos;YmluYXJ5AHN0cmluZw==&apos;) #b&apos;binary\x00string&apos;
</code></pre><p>url safe 的base64编码：使用<code>-</code>,<code>_</code>代替<code>+</code>,<code>/</code></p>
<pre><code>base64.urlsafe_b64encode(b&apos;i\xb7\x1d\xfb\xef\xff&apos;)
base64.urlsafe_b64decode(&apos;abcd--__&apos;)
</code></pre><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>处理字节</p>
<pre><code>from struct import *

packed_data = pack(&apos;ii&apos;, 12, 43)
print(packed_data) # b&apos;.......&apos; 以字节存储数据
</code></pre><h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><p>提供常见的摘要算法：</p>
<pre><code>import hashlib
md5 = hashlib.md5()
md5.update(&apos;content........&apos;.encode(&apos;utf-8&apos;))
print(md5.hexdigest()) # d26a53750bc40b38b65a520292f69306
</code></pre><p>如果数据量大，可以分块调用<code>update()</code>,最后计算的结果是一样的</p>
<p>生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p>
<p>SHA1:使用方法一样</p>
<pre><code>import hashlib
sha1 = hashlib.sha1()
sha1.update(&apos;content,......&apos;.encode(&apos;utf-8&apos;))
sha1.hexdigest()
</code></pre><p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>保存用户的密码，保存的是密码的摘要算法</p>
<h2 id="iterrools"><a href="#iterrools" class="headerlink" title="iterrools"></a>iterrools</h2><p>操作迭代对象的函数</p>
<p>提供的<code>无限</code>迭代器：</p>
<pre><code>import itertools
natuals = itertools.count(1)
for n in natuals:
    print(n)
</code></pre><p><code>count()</code>会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按Ctrl+C退出。</p>
<pre><code>import itertools
cs = itertools.cycler(&apos;ABC&apos;)
for c incs:
    print(c)
</code></pre><p><code>cycler()</code>会循环遍历</p>
<p><code>repeat(&#39;A&#39;, 3)</code> 限定次数循环</p>
<p>使用<code>takewhile()</code>等函数可以截取无限序列：</p>
<pre><code>natuals = itertools.count(1)
ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)
list(ns) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre><h3 id="chain"><a href="#chain" class="headerlink" title="chain()"></a>chain()</h3><p>把一组迭代对象串联起来，形成一个更大的迭代器：</p>
<pre><code>for c in itertools.chain(&apos;ABC&apos;, &apos;XYZ&apos;) # 迭代效果：&apos;A&apos; &apos;B&apos; &apos;C&apos; &apos;X&apos; &apos;Y&apos; &apos;Z&apos;
</code></pre><h3 id="groupby"><a href="#groupby" class="headerlink" title="groupby()"></a>groupby()</h3><p>把迭代器中相邻的重复元素挑出来放在一起:</p>
<pre><code>for key, group in itertools.groupby(&apos;AAABBBCCAAA&apos;):
    print(key, list(group)) # A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;] B [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;] C [&apos;C&apos;, &apos;C&apos;] A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]
</code></pre><p>挑选规则是由一个函数完成的： 忽略大小写</p>
<pre><code>for key, group in itertools.groupby(&apos;AaaBBbcCAAa&apos;, lambda c: c.upper()):
    print(key, list(group))
</code></pre><p>模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是Iterator，只有用for循环迭代的时候才真正计算。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h2 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h2><h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><p>操作URL的功能</p>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p><code>request</code>模块抓取URL内容：</p>
<pre><code>from urllib import request

with request.urlopent(&apos;https://api.douban.com/v2/book/2129650&apos;) as f:
    data = f.read()
    print(&apos;Status:&apos;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&apos;%s: %s&apos; % (k, v))
    print(&apos;Data:&apos;, data.decode(&apos;utf-8&apos;))
</code></pre><p>结果：</p>
<pre><code>Status: 200 OK
Server: nginx
Date: Tue, 26 May 2015 10:02:27 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 2049
Connection: close
Expires: Sun, 1 Jan 2006 01:00:00 GMT
Pragma: no-cache
Cache-Control: must-revalidate, no-cache, private
X-DAE-Node: pidl1
Data: {&quot;rating&quot;:{&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0},&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,&quot;tags&quot;:[{&quot;count&quot;:20,&quot;name&quot;:&quot;spring&quot;,&quot;title&quot;:&quot;spring&quot;}...}
</code></pre><p>模拟游览器发送GET请求，使用<code>Request</code>对象，通过加请求头伪装成游览器:</p>
<pre><code>form urllib import request

req = request.Request(&apos;http://www.douban.com/&apos;)
req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)
with request.uelopen(req) as f:
    print(&apos;Status:&apos;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&apos;%s: %s&apos; % (k, v))
    print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;))

#  返回html
</code></pre><h3 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h3><p>把<code>data</code>以bytes形式传入：</p>
<pre><code>from urllib import request, parse

print(&apos;Login to weibo.cn...&apos;)
email = input(&apos;Email: &apos;)
passwd = input(&apos;Password: &apos;)
login_data = parse.urlencode([
    (&apos;username&apos;, email),
    (&apos;password&apos;, passwd),
    (&apos;entry&apos;, &apos;mweibo&apos;),
    (&apos;client_id&apos;, &apos;&apos;),
    (&apos;savestate&apos;, &apos;1&apos;),
    (&apos;ec&apos;, &apos;&apos;),
    (&apos;pagerefer&apos;, &apos;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)
])

req = request.Request(&apos;https://passport.weibo.cn/sso/login&apos;)
req.add_header(&apos;Origin&apos;, &apos;https://passport.weibo.cn&apos;)
req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)
req.add_header(&apos;Referer&apos;, &apos;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)

with request.urlopen(req, data=login_data.encode(&apos;utf-8&apos;)) as f:
    print(&apos;Status:&apos;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&apos;%s: %s&apos; % (k, v))
    print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;))
</code></pre><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>更复杂的控制</p>
<h1 id="常用第三方模块"><a href="#常用第三方模块" class="headerlink" title="常用第三方模块"></a>常用第三方模块</h1><h2 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h2><p>Python Imaging Library:Python平台上图像处理标准库</p>
<p>升级版：Pillow for python3</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>pip install pillow
</code></pre><h3 id="操作图像"><a href="#操作图像" class="headerlink" title="操作图像"></a>操作图像</h3><p>缩放操作：</p>
<pre><code>from PIL import Image

# 打开jpg图像文件
im = Image.open(&apos;test.jpg&apos;)
# 获取图像尺寸
w ,h = im.size
# 缩放
im.thumbnail((w//2, h//2))
# 把缩放后的图像保存
im.save(&apos;thumbnail.jpg, &apos;jpeg&apos;&apos;)

# 模糊
from PIL import Image, ImageFilter
im = Image.open(&apos;test.jpg&apos;)
im2 = im.filter(ImageFilter.BLUR)
im2.save(&apos;blur.jpg&apos;, &apos;jpeg&apos;)

# 使用 ImageDraw 提供一系列绘图方式， 比如生成字母验证
from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random

# 随机字母
def rndChar():
    return chr(rangdom.randint(65, 90))
# 随机颜色
def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))
# 随机颜色2
def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))
# 240 * 60
width = 60 * 4
height = 60
image = Image.new(&apos;RGB&apos;, (width, height), (255,255,255))
# 创建 Font 对象
font = ImageFont.truetype(&apos;Arial.ttf&apos;, 36)
# 创建 Draw 对象
draw = ImageDraw.Draw(image)
# 填充每个像素
for x in range(width):
    for y in range(height):
        draw.point((x, y), fill=rndColor())
# 输出文字
for t in range(4):
    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())
# 模糊
image = image.filter(ImageFilter.BLUR)
image.save(&apos;code.jpg&apos;, &apos;jpeg&apos;)
</code></pre><h3 id="crop"><a href="#crop" class="headerlink" title="crop"></a>crop</h3><pre><code>img = Image.open(&apos;demo.png&apos;)
area = (100, 100, 300, 300)
cropped_img = img.crop(area)
cropped_img.show()
</code></pre><h3 id="combine"><a href="#combine" class="headerlink" title="combine"></a>combine</h3><pre><code>one = Image.open(&apos;one.png&apos;)
 two = Image.open(&apos;two.png&apos;)
area = (100, 100, 300, 300)
one.paste(two, area)
</code></pre><h1 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h1><p>第三方库：</p>
<ul>
<li>TK</li>
<li>wxWidgets</li>
<li>QT</li>
<li>GTK</li>
</ul>
<h2 id="Tkinter"><a href="#Tkinter" class="headerlink" title="Tkinter"></a>Tkinter</h2><pre><code>from tkinter import *

class Application(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.pack()
        self.createWidgets()

    def createWidgets(self):
        self.helloLabel = Label(self, text=&apos;Hello, world!&apos;)
        self.helloLabel.pack()
        self.quitButton = Button(self, text=&apos;Quit&apos;, command=self.quit)
        self.quitButton.pack()

app = Application()
app.master.title(&apos;title&apos;)
app.mainloop() # 主消息循环主线程负责监听来自操作系统的消息，并依次处理每一条消息。因此，如果消息处理非常耗时，就需要在新线程中处理。
</code></pre><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="TCP-IP-简介"><a href="#TCP-IP-简介" class="headerlink" title="TCP/IP 简介"></a>TCP/IP 简介</h2><p>通讯：双方必须知道对方的标识</p>
<p>标识：IP地址</p>
<p>IP协议负责把数据从一台计算机通过网络发送给另一个计算机</p>
<p>TCP协议建立在IP协议之上：TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。</p>
<p>HTTP,SMTP协议建立在TCP协议之上</p>
<p>端口：指定程序</p>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>可靠连接TCP</p>
<pre><code>import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((&apos;www.baidu.com&apos;, 80))
</code></pre><p>创建<code>Socket</code>时：指定IPv4<code>AF_INET</code>协议，<code>SOCK_STREAM</code>指定使用面向流的TCP协议</p>
<p>80端口是Web服务的标准端口</p>
<p>SMTP服务是25端口</p>
<p>FTP服务是21端口</p>
<p>端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。</p>
<pre><code># 发送数据:
s.send(b&apos;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&apos;)
# 接收数据
    buffer = []
    while True:
        d = s.recv(1024)
        if d:
            buffer.append(d)
        else:
            break
    data = b&apos;&apos;.join(buffer)
    # 关闭连接:
    s.close()
</code></pre><p>接收到数据包括HTTP头和网页本身：</p>
<pre><code>header , html = data.split(b&apos;\r\n\r\n&apos;, 1)
print(header.devode(&apos;utf-8&apos;))
with open(&apos;sina.html&apos;, &apos;wb&apos;) as f:
    f.write(html)
</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。</p>
<p>一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p>
<p>但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</code></pre><p>绑定地址和端口，服务器上可能有多快网卡，绑定多有网络地址：<code>0.0.0.0</code>,绑定本机地址<code>127.0.0.1</code></p>
<pre><code>s.bind(&apos;127.0.0.1&apos;, 9999)
s.listen(5) # 传入的参数指定等待连接的最大数量
print(&apos;Waiting for connection...&apos;)
</code></pre><p>服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接</p>
<pre><code>while True:
    sock, addr = s.accept()
    t = threading.Thread(target=tcpling, args=(aock, addr))
    t.start()
</code></pre><p>每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：</p>
<pre><code>def tcpling(sock, addr):
    print(&apos;Accept new connection from %s:%s...&apos; % addr)
    sock.send(b&apos;Welcome!&apos;)
    while True:
        date = sock.recv(1024)
        time.sleep(1)
        if not data or data.decode(&apos;utf-8&apos;) == &apos;exit&apos;:
            break
        sock.send((&apos;Hello, %s!&apos; % data.decode(&apos;utf-8&apos;)).encode(&apos;utf-8&apos;))
    sock.close()
    print(&apos;Connection from %s:%s closed.&apos; % addr)
</code></pre><p>同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。</p>
<h2 id="UDP-编程"><a href="#UDP-编程" class="headerlink" title="UDP 编程"></a>UDP 编程</h2><p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。</p>
<p>速度快</p>
<p>服务器：</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind((&apos;127.0.0.1&apos;, 9999))

print(&apos;Bind UDP on 9999...&apos;)
while True:
    # 接收数据: 这里省掉了多线程
    data, addr = s.recvfrom(1024)
    print(&apos;Received from %s:%s.&apos; % addr)
    s.sendto(b&apos;Hello, %s!&apos; % data, addr)
</code></pre><p>客户端：</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]:
    # 发送数据:
    s.sendto(data, (&apos;127.0.0.1&apos;, 9999))
    # 接收数据:
    print(s.recv(1024).decode(&apos;utf-8&apos;))
s.close()
</code></pre><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h1 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h1><ul>
<li>Oracle，典型的高富帅；</li>
<li>SQL Server，微软自家产品，Windows定制专款；</li>
<li>DB2，IBM的产品，听起来挺高端；</li>
<li>Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡</li>
<li>MySQL，大家都在用，一般错不了；</li>
<li>PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；</li>
<li>sqlite，嵌入式数据库，适合桌面和移动应用</li>
</ul>
<h2 id="使用SQLite"><a href="#使用SQLite" class="headerlink" title="使用SQLite"></a>使用SQLite</h2><p>SQLite是一种嵌入式数据库，它的数据库就是一个文件。</p>
<p>SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中</p>
<p>Python就内置了SQLite3</p>
<p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection</p>
<p>连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。</p>
<pre><code>import sqlite3
# 连接到SQLite数据库 数据库文件 test.db 文件不存在会创建
conn = sqlites.connect(&apos;test.db&apos;)
# 创建一个 Cursor
cursor = conn.cursor()
# 执行 SQL语句
cursor.execute(&apos;create table user (id varchar(20) primary key, name varchar(20))&apos;)
# 继续执行一条SQL语句，插入一条记录:
cursor.execute(&apos;insert into user (id, name) values (\&apos;1\&apos;, \&apos;Michael\&apos;)&apos;)
# 通过rowcount获得插入的行数:
cursor.rowcount

cursor.close()
conn.commit()
conn.close()
</code></pre><p>查询：</p>
<pre><code>conn = sqlite3.connect(&apos;test.db&apos;)
cursor = conn.cursor()
cursor.execute(&apos;select * from user where id=?&apos;, (&apos;1&apos;,))
values = cursor.fetchall()
# 结果集

cursor.close()
conn.close()
</code></pre><p>一定要注意关闭<code>Connection</code>,<code>Cursor</code></p>
<p><code>Cursor</code>执行<code>insert</code>,<code>update</code>,<code>delete</code>语句，结果<code>rowcount</code>返回影响行数</p>
<p><code>Curosr</code>执行<code>select</code>,通过<code>featchall()</code>拿到结果集：list，每个元素是tuple对应一行纪录</p>
<pre><code>cursor.execute(&apos;select * from user where name=? and pwd=?&apos;, (&apos;abc&apos;, &apos;password&apos;))

try:...except:...finally:...
</code></pre><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于SQLite。</p>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>下载 安装</p>
<p>配置：<code>/etc/my.cnf</code>或者<code>/etc/mysql/my.cnf</code>:</p>
<pre><code>[client]
default-character-set = utf8
[mysqld]
default-storage-engine = INNODB
character-
-server = utf8
collation-server = utf8_general_ci
</code></pre><p>重启MySQL后，可以通过MySQL的客户端命令行检查编码：</p>
<pre><code>mysql -u root -p

mysql&gt; show variables like &apos;%char%&apos;;
</code></pre><h3 id="安装MySQL驱动"><a href="#安装MySQL驱动" class="headerlink" title="安装MySQL驱动"></a>安装MySQL驱动</h3><pre><code>pip install mysql-connector-python --allow-external mysql-connector-python
</code></pre><p>连接数据库：</p>
<pre><code>import mysql.connector
conn = mysql.connector.connect(user=&apos;root&apos;, password=&apos;password&apos;, database=&apos;test&apos;)
cursor = conn.cursor()
cursor.execute(&apos;create table user (id varchar(20) primary key, name varchar(20))&apos;)
cursor.execute(&apos;insert into user (id, name) values (%s, %s)&apos;, [&apos;1&apos;, &apos;Michael&apos;])
cursor.rowcount # 1
conn.commit()
curcor.close()
# select
cursor = conn.cursor()
cursor.execute(&apos;select * from user where id = %s&apos;, (&apos;1&apos;, ))
values = cursor.fetchall()
values #[(&apos;1&apos;, &apos;Michael&apos;)]
cursor.close()
conn.close()
</code></pre><h2 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h2><p>Object-Relational Mapping，把关系数据库的表结构映射到对象上</p>
<pre><code>pip install sqlalchemy
</code></pre><p>第一步，导入SQLAlchemy，并初始化DBSession：</p>
<pre><code># 导入:
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# 创建对象的基类:
Base = declarative_base()

# define User Object:
class User(Base):
    # table name:
    __tablename__ = &apos;user&apos;

    # table construct
    id = Column(String(20), primary_key=True)
    name = Column(String(20))

# create db connection
engine = create_engine(&apos;mysql+mysqlconnector://root:password@localhost:3306/test&apos;)
# create DBSession :
DBSession = sessionmaker(bind=engine)
</code></pre><p>以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如School：</p>
<pre><code>class School(Base):
    __tablename__ = &apos;school&apos;
    id = ...
    name = ...
</code></pre><p><code>create_engine()</code>用来初始化数据库连接，SQLAlchemy用一个字符串表示连接信息：</p>
<pre><code>&apos;数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名&apos;
</code></pre><p>如何添加纪录：</p>
<pre><code># create session object
session = DBSession()
# create User object
new_user = User(id=&apos;5&apos;, name=&apos;Bob&apos;)
# add to session:
session.add(new_user)
# commit to db
session.commit()
# close session
session.close()
</code></pre><p>DBSession对象可视为当前数据库连接。</p>
<p>查询数据：</p>
<pre><code># create Session:
session = DBSession()
# create Query,filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:
user = session.query(User).filter(User.id=&apos;5&apos;).one()
# print
print(&apos;type:&apos;, type(user))
print(&apos;name:&apos;, user.name)
# close
session.close()
</code></pre><p>ORM框架的作用就是把数据库表的一行记录与一个对象互相做自动转换。</p>
<pre><code>class User(Base):
    __tablename__ = &apos;user&apos;

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # 一对多:
    books = relationship(&apos;Book&apos;)

class Book(Base):
    __tablename__ = &apos;book&apos;

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # “多”的一方的book表是通过外键关联到user表的:
    user_id = Column(String(20), ForeignKey(&apos;user.id&apos;))
</code></pre><h1 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h1><h2 id="HTTP-协议简介"><a href="#HTTP-协议简介" class="headerlink" title="HTTP 协议简介"></a>HTTP 协议简介</h2><p>而浏览器和服务器之间的传输协议是HTTP</p>
<ul>
<li>HTML是一种用来定义网页的文本，会HTML，就可以编写网页；</li>
<li>HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信</li>
</ul>
<p>Chrome开发者工具：</p>
<ul>
<li>elements 显示网页结构</li>
<li>Netword 显示游览器和服务器的通信</li>
</ul>
<h3 id="HTTP-格式"><a href="#HTTP-格式" class="headerlink" title="HTTP 格式"></a>HTTP 格式</h3><p>文本协议</p>
<p>每个Header一行，换行符：<code>\r\n</code>:<br>    GET /path HTTP/1.1<br>    Header1: Value1<br>    Header2: Value2<br>    Header3: Value3</p>
<p>POST:</p>
<pre><code>POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre><p>两个换行符隔开请求头和请求体</p>
<h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><p>一套语法规则</p>
<h2 id="WSGI-接口"><a href="#WSGI-接口" class="headerlink" title="WSGI 接口"></a>WSGI 接口</h2><p>web 应用的本质：</p>
<ol>
<li>游览器发送一个HTTP请求</li>
<li>服务器收到请求生成一个HTML文档</li>
<li>服务器吧HTML文档作为HTTP响应的Body发送给游览器</li>
<li>游览器受到HTTP响应，从HTTP Body 取出HTML 文档并显示</li>
</ol>
<p>Web Server Gateway Interface</p>
<pre><code>def application(eviron, start_response):
    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html&apos;)])
    return [b&apos;&lt;h1&gt; Hello, web!&lt;/h&gt;&apos;]
</code></pre><p>上面定义的函数<code>application</code>就是符合WSGI标准的一个HTTP处理函数，参数：</p>
<ol>
<li>environ: 一个包含所有HTTP请求信息的<code>dict</code>对象</li>
<li>start_response:一个发送HTTP响应的函数， 调用就是发送了HTTP响应的Header（Header只能发送一次）</li>
<li>返回的内容就是Body</li>
<li>这个函数由WSGI服务器调用</li>
</ol>
<p>Python内置的WSGI服务器，wsgirefwsgi</p>
<pre><code>from wsgiref.simple_server import make_server
httpd = make_server(&apos;&apos;, 8000, application)
print(&apos;serving Http on port 8000&apos;)

httpd.serve_forever()
</code></pre><h2 id="使用Web框架"><a href="#使用Web框架" class="headerlink" title="使用Web框架"></a>使用Web框架</h2><p>其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。</p>
<p>使用WSGI提供的接口来实现实际的项目代码无法维护，需要使用Web框架来处理URL到函数的映射</p>
<p>这里使用<code>Flash</code>:</p>
<p>安装：</p>
<pre><code>pip install flaskla
</code></pre><p><code>flash</code>同欧Python的装饰器在内部自动把URL和函数关联在一起</p>
<h2 id="使用模版"><a href="#使用模版" class="headerlink" title="使用模版"></a>使用模版</h2><p>有了Web框架，我们只需不断编写函数带上URL就可以Web App的开发了</p>
<p>那么HTML页面如何生成？ 可以使用模版来生成HTML页面</p>
<p>MVC：模型，视图，控制器</p>
<p>Python处理URL的函数就是C：负责业务逻辑，比如检查用户名是否存在，取出用户信息等</p>
<p>模版就是V：复制界面展示</p>
<p>Model就是C处理完成的数据，C将M传给V：一般是个<code>dict</code>，因为Python支持关键字参数，很多Web框架允许传入关键字参数，然后，在框架内部组装出一个dict作为Model。</p>
<p>有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。</p>
<h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><p>异步IO模型需要一个消息循环，在消息循环中，主线程不断重复“读取消息－处理消息”这一过程：</p>
<pre><code>loop = get_event_loop()
while True:
    event = loop.get_event()
    process_event(event)
</code></pre><p>这样的消息模型最早应用在桌面应用程序中，一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘和鼠标等消息都被发送到GUI程序的消息队列中，由GUI程序的主线程处理</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>微线程，Coroutine</p>
<p>协程和线程比：</p>
<ol>
<li>协程切换没有线程切换的开销，性能优势明显。</li>
<li>不需要多线程的锁机制，因为只有一个线程</li>
</ol>
<p>利用多核CPU：多进程＋协程</p>
<p>Python对协程的支持通过generator实现</p>
<p>生产者消费者模型：</p>
<pre><code>def consumer():
    r = &apos;&apos;
    while True:
        n = yield r
        if not n:
            return
        print(&apos;[CONSUMER] Consuming %s...&apos; % n)
        r = &apos;200 OK&apos;

def produce(c):
    c.send(None)
    n = 0
    while n &lt; 5
        n = n + 1
        print(&apos;[PRODUCER] Producing %s...&apos; % n)
        r = c.send(n)
        print(&apos;[PRODUCER] Consumer return: %S&apos; % r)
    c.close()

c = consumer()
produce(c)
</code></pre><ol>
<li><code>consumer</code> 是一个 <code>generator</code> ，把<code>consumer</code> 传入<code>produce</code></li>
<li>调用<code>c.send(None)</code> 启动生成器</li>
<li>一旦生产了东西后，通过<code>c.send(n)</code>切换到<code>consumer</code>执行</li>
<li><code>consumer</code>通过<code>yield</code>拿到消息，处理，又通过<code>yield</code>把结果传回</li>
<li><code>produce</code>拿到<code>consumer</code>处理结果后，继续生产下一条消息</li>
<li><code>produce</code>决定不生产后，通过<code>c.close()</code>关闭<code>consumer</code>，结束整个过程</li>
</ol>
<p>子线程就是协程的一种特例。</p>
<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>Python 3.4 版本引入的标准库，内置了对异步IO的支持</p>
<p>它的编程模型就是一个消息循环，直接从<code>asyncio</code>模块获取一个<code>EventLoop</code>的引用，然后把需要执行的协程传入执行就可以实现异步IO</p>
<pre><code>import asyncio

@asyncio.coroutine
def hello():
    print(&apos;Hello world!&apos;)
    # 异步调用 asyncio.sleep(i):
    r = yield from asyncio.sleep(1)
    print(&apos;Hello again!&apos;)

# gaint EventLoop
loop = asyncio.get_evet_loop()
# execute coroutine
loop.run_until_complete(hello())
loop.close()
</code></pre><p>使用<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>把一个</code>generator<code>标记为一个</code>coroutine<code>类型，然后把</code>coroutine<code>放到</code>EventLoop`中执行</p>
<p>还可以使用task把多个<code>coroutine</code>大包并发执行</p>
<pre><code>tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(takse))
</code></pre><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p><code>asyncio</code>提供<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>把一个generator标记为coroutine类型,然后在coroutine内部用</code>yield from<code>调用另一个coroutine实现异步操作，Python3.5 引入新语法</code>async<code>,</code>await`</p>
<ol>
<li><a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>替换成</code>async`</li>
<li><p><code>yield from</code>–&gt;<code>await</code></p>
<pre><code>async def hello():
    print(&apos;Hello world&apos;)
    r = await asyncio.sleep(1)
    print(&apos;Hello again!&apos;)
</code></pre></li>
</ol>
<h2 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h2><p>实现单线程并发IO操作，基于<code>asyncio</code>实现的http框架</p>
<p>安装：</p>
<pre><code>pip install aiohttp
</code></pre><p>编写Http服务器：</p>
<pre><code>import asyncio

from aiohttp import web

async def index(request):
    await asyncio.sleep(0.5)
    text = &apos;&lt;h&gt;Index&lt;/h&gt;&apos;
    return web.Response(body=text.encode(&apos;utf-8&apos;))

async def hello(request):
    await asyncio.sleep(0.5)
    text = &apos;&lt;h&gt;hello, %s!&lt;/h1&gt;&apos; % request.math_info(&apos;name&apos;)
    return web.response(body=text.encode(&apos;utf-8&apos;))

async def init(loop):
    app = web.Application(loop=loop)
    app.router.add_route(&apos;GET&apos;, &apos;/&apos;, index)
    app.router.add_route(&apos;GET&apos;, &apos;/hello/{name}&apos;, hello )
    srv = await loop.create_server(app.make_handler(), &apos;127.0.0.1&apos;, 8000)
    print(&apos;Server started at http://127.0.0.1:8000...&apos;)
    return srv

loop = asyncio.get_event_loop()
loop.run_until_complete(init(loop))
loop.run_forever()
</code></pre><p>注意aiohttp的初始化函数init()也是一个coroutine，loop.create_server()则利用asyncio创建TCP服务。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
            <a href="/tags/廖雪峰笔记/" rel="tag"># 廖雪峰笔记</a>
          
            <a href="/tags/简明Python/" rel="tag"># 简明Python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/07/Android/UI/贝塞尔曲线/" rel="next" title="贝塞尔曲线">
                <i class="fa fa-chevron-left"></i> 贝塞尔曲线
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/27/ReadNote/head_first_python/" rel="prev" title="Head First Python">
                Head First Python <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/head1.jpg" alt="Double">
          <p class="site-author-name" itemprop="name">Double</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">548</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">260</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一个Python程序"><span class="nav-number">1.</span> <span class="nav-text">第一个Python程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-脚本运行-传入参数"><span class="nav-number">1.1.</span> <span class="nav-text">Python 脚本运行 传入参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-获取控制台的输入"><span class="nav-number">1.2.</span> <span class="nav-text">Python 获取控制台的输入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python基础"><span class="nav-number">2.</span> <span class="nav-text">Python基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符"><span class="nav-number">2.1.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据"><span class="nav-number">2.2.</span> <span class="nav-text">基本数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#numbers-数字"><span class="nav-number">2.2.1.</span> <span class="nav-text">numbers 数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Strings"><span class="nav-number">2.2.2.</span> <span class="nav-text">Strings</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#format"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">format</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#format-是如何工作的"><span class="nav-number">2.2.2.1.1.</span> <span class="nav-text">format 是如何工作的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-concatenate"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">String concatenate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string-index"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">string index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#截取-slicing"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">截取 slicing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#built-in-function"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">built-in function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lean-from-koans"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">lean from koans</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#boolean"><span class="nav-number">2.2.3.</span> <span class="nav-text">boolean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#None"><span class="nav-number">2.2.4.</span> <span class="nav-text">None</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空值"><span class="nav-number">2.2.5.</span> <span class="nav-text">空值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">2.2.6.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量"><span class="nav-number">2.2.7.</span> <span class="nav-text">常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串和编码"><span class="nav-number">2.3.</span> <span class="nav-text">字符串和编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符编码"><span class="nav-number">2.3.1.</span> <span class="nav-text">字符编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-的字符串"><span class="nav-number">2.3.2.</span> <span class="nav-text">Python 的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化字符串"><span class="nav-number">2.3.3.</span> <span class="nav-text">格式化字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#list-列表"><span class="nav-number">3.1.</span> <span class="nav-text">list 列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#利用切片增-删-改"><span class="nav-number">3.1.1.</span> <span class="nav-text">利用切片增 删 改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配合-range-生成-list"><span class="nav-number">3.1.2.</span> <span class="nav-text">配合 range 生成 list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list-一些方法"><span class="nav-number">3.1.3.</span> <span class="nav-text">list 一些方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list-assignments"><span class="nav-number">3.1.4.</span> <span class="nav-text">list assignments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换两个数"><span class="nav-number">3.1.5.</span> <span class="nav-text">交换两个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Lists-as-Stacks-堆栈"><span class="nav-number">3.1.6.</span> <span class="nav-text">Using Lists as Stacks 堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Lists-as-Queues-队列"><span class="nav-number">3.1.7.</span> <span class="nav-text">Using Lists as Queues 队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-Comprehensions-列表解析"><span class="nav-number">3.1.8.</span> <span class="nav-text">List Comprehensions 列表解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nested-List-Comprehensions"><span class="nav-number">3.1.9.</span> <span class="nav-text">Nested List Comprehensions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-del-statement-删除语句"><span class="nav-number">3.1.10.</span> <span class="nav-text">The del statement 删除语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tuple"><span class="nav-number">3.2.</span> <span class="nav-text">tuple</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unpack-list-tuple"><span class="nav-number">3.3.</span> <span class="nav-text">unpack list tuple</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-number">3.4.</span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set-Comprehensions"><span class="nav-number">3.4.1.</span> <span class="nav-text">set Comprehensions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#amp-operate"><span class="nav-number">3.4.2.</span> <span class="nav-text">&amp; | ^ - operate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other"><span class="nav-number">3.4.3.</span> <span class="nav-text">other</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dict"><span class="nav-number">3.4.4.</span> <span class="nav-text">dict</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dict-sort"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">dict sort</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件判断-More-Control-Flow-Tools"><span class="nav-number">3.5.</span> <span class="nav-text">条件判断 More Control Flow Tools</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input"><span class="nav-number">3.6.</span> <span class="nav-text">input</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zip"><span class="nav-number">3.7.</span> <span class="nav-text">zip</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环"><span class="nav-number">3.8.</span> <span class="nav-text">循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#循环-1"><span class="nav-number">3.8.1.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range"><span class="nav-number">3.8.2.</span> <span class="nav-text">range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break"><span class="nav-number">3.8.3.</span> <span class="nav-text">break</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#continue"><span class="nav-number">3.8.4.</span> <span class="nav-text">continue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Modules"><span class="nav-number">4.</span> <span class="nav-text">Modules</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#More-on-Modules"><span class="nav-number">4.1.</span> <span class="nav-text">More on Modules</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executing-modules-as-scripts"><span class="nav-number">4.1.1.</span> <span class="nav-text">Executing modules as scripts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Module-Search-Path"><span class="nav-number">4.1.2.</span> <span class="nav-text">The Module Search Path</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Packages"><span class="nav-number">4.2.</span> <span class="nav-text">Packages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给模块创建发布"><span class="nav-number">4.3.</span> <span class="nav-text">给模块创建发布</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#调用函数"><span class="nav-number">5.1.</span> <span class="nav-text">调用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型转换"><span class="nav-number">5.1.1.</span> <span class="nav-text">数据类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义函数"><span class="nav-number">5.2.</span> <span class="nav-text">定义函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空函数"><span class="nav-number">5.2.1.</span> <span class="nav-text">空函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数检查"><span class="nav-number">5.2.2.</span> <span class="nav-text">参数检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回多个值"><span class="nav-number">5.2.3.</span> <span class="nav-text">返回多个值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的参数"><span class="nav-number">5.3.</span> <span class="nav-text">函数的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#位置参数"><span class="nav-number">5.3.1.</span> <span class="nav-text">位置参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认参数"><span class="nav-number">5.3.2.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数-Arbitrary-Arguments-Lists"><span class="nav-number">5.3.3.</span> <span class="nav-text">可变参数 Arbitrary Arguments Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字参数-Keyword-Arguments"><span class="nav-number">5.3.4.</span> <span class="nav-text">关键字参数 Keyword Arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名关键字参数"><span class="nav-number">5.3.5.</span> <span class="nav-text">命名关键字参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unpacking-arguments"><span class="nav-number">5.3.6.</span> <span class="nav-text">unpacking arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数组合"><span class="nav-number">5.3.7.</span> <span class="nav-text">参数组合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#return-语句"><span class="nav-number">5.4.</span> <span class="nav-text">return 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归函数"><span class="nav-number">5.5.</span> <span class="nav-text">递归函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-Expressions"><span class="nav-number">5.5.1.</span> <span class="nav-text">Lambda Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法文档-DocStrings"><span class="nav-number">5.5.2.</span> <span class="nav-text">方法文档 DocStrings</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高级特征"><span class="nav-number">6.</span> <span class="nav-text">高级特征</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#切片-slice"><span class="nav-number">6.1.</span> <span class="nav-text">切片 slice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代-iteration"><span class="nav-number">6.2.</span> <span class="nav-text">迭代 iteration</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表生成式-List-Comprehensions"><span class="nav-number">6.3.</span> <span class="nav-text">列表生成式 List Comprehensions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器"><span class="nav-number">6.4.</span> <span class="nav-text">生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建generator"><span class="nav-number">6.4.1.</span> <span class="nav-text">创建generator:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">6.5.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数式编程"><span class="nav-number">7.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数-Higher-order-funciton"><span class="nav-number">7.1.</span> <span class="nav-text">高阶函数 Higher-order funciton</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量可以指向函数"><span class="nav-number">7.1.1.</span> <span class="nav-text">变量可以指向函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数名也是变量"><span class="nav-number">7.1.2.</span> <span class="nav-text">函数名也是变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传入函数"><span class="nav-number">7.1.3.</span> <span class="nav-text">传入函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-reduce"><span class="nav-number">7.1.4.</span> <span class="nav-text">map/reduce</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-number">7.1.4.1.</span> <span class="nav-text">map()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-number">7.1.4.2.</span> <span class="nav-text">reduce()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-number">7.1.5.</span> <span class="nav-text">filter()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用fliter求素数"><span class="nav-number">7.1.5.1.</span> <span class="nav-text">用fliter求素数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sorted"><span class="nav-number">7.1.6.</span> <span class="nav-text">sorted</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法"><span class="nav-number">7.1.6.1.</span> <span class="nav-text">排序算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回函数"><span class="nav-number">7.2.</span> <span class="nav-text">返回函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数作为返回值"><span class="nav-number">7.2.1.</span> <span class="nav-text">函数作为返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包-Closure"><span class="nav-number">7.2.2.</span> <span class="nav-text">闭包 Closure</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名函数"><span class="nav-number">7.3.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器"><span class="nav-number">7.4.</span> <span class="nav-text">装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#偏函数-Partial-function"><span class="nav-number">7.5.</span> <span class="nav-text">偏函数 Partial function</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块"><span class="nav-number">8.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用模块"><span class="nav-number">8.1.</span> <span class="nav-text">使用模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">8.1.1.</span> <span class="nav-text">作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装第三方模块"><span class="nav-number">8.2.</span> <span class="nav-text">安装第三方模块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象编程-oop"><span class="nav-number">9.</span> <span class="nav-text">面向对象编程 oop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类和实例"><span class="nav-number">9.1.</span> <span class="nav-text">类和实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据封装"><span class="nav-number">9.1.1.</span> <span class="nav-text">数据封装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问限制"><span class="nav-number">9.2.</span> <span class="nav-text">访问限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承和多态"><span class="nav-number">9.3.</span> <span class="nav-text">继承和多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取对象信息"><span class="nav-number">9.4.</span> <span class="nav-text">获取对象信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-type"><span class="nav-number">9.4.1.</span> <span class="nav-text">使用 type()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用isinstance"><span class="nav-number">9.4.2.</span> <span class="nav-text">使用isinstance()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dir"><span class="nav-number">9.4.3.</span> <span class="nav-text">dir()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例属性和类属性"><span class="nav-number">9.5.</span> <span class="nav-text">实例属性和类属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象高级编程"><span class="nav-number">10.</span> <span class="nav-text">面向对象高级编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-slots"><span class="nav-number">10.1.</span> <span class="nav-text">使用 __slots</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-slots-1"><span class="nav-number">10.1.1.</span> <span class="nav-text">使用 slots</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-property"><span class="nav-number">10.2.</span> <span class="nav-text">使用@property</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承"><span class="nav-number">10.3.</span> <span class="nav-text">多重继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MixIn"><span class="nav-number">10.3.1.</span> <span class="nav-text">MixIn</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定制类"><span class="nav-number">10.4.</span> <span class="nav-text">定制类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用枚举类"><span class="nav-number">10.5.</span> <span class="nav-text">使用枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用元类"><span class="nav-number">10.6.</span> <span class="nav-text">使用元类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#metaclass"><span class="nav-number">10.6.1.</span> <span class="nav-text">metaclass</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误和调试"><span class="nav-number">11.</span> <span class="nav-text">错误和调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理"><span class="nav-number">11.1.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取错误信息"><span class="nav-number">11.1.1.</span> <span class="nav-text">获取错误信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常类-Exception"><span class="nav-number">11.1.2.</span> <span class="nav-text">异常类 Exception</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用堆栈"><span class="nav-number">11.1.3.</span> <span class="nav-text">调用堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误记录"><span class="nav-number">11.1.4.</span> <span class="nav-text">错误记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抛出错误"><span class="nav-number">11.1.5.</span> <span class="nav-text">抛出错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试"><span class="nav-number">11.2.</span> <span class="nav-text">调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#断言"><span class="nav-number">11.2.1.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loggin"><span class="nav-number">11.2.2.</span> <span class="nav-text">loggin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pdb"><span class="nav-number">11.2.3.</span> <span class="nav-text">pdb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pdb-set-trace"><span class="nav-number">11.2.4.</span> <span class="nav-text">pdb.set_trace()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单元测试"><span class="nav-number">11.3.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档测试"><span class="nav-number">11.4.</span> <span class="nav-text">文档测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO编程"><span class="nav-number">12.</span> <span class="nav-text">IO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件读写"><span class="nav-number">12.1.</span> <span class="nav-text">文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读文件"><span class="nav-number">12.1.1.</span> <span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#file-like-Object"><span class="nav-number">12.1.2.</span> <span class="nav-text">file-like Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制文件"><span class="nav-number">12.1.3.</span> <span class="nav-text">二进制文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符编码-1"><span class="nav-number">12.1.4.</span> <span class="nav-text">字符编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写文件"><span class="nav-number">12.1.5.</span> <span class="nav-text">写文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringIO和BytesIO"><span class="nav-number">12.2.</span> <span class="nav-text">StringIO和BytesIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#StringIO"><span class="nav-number">12.2.1.</span> <span class="nav-text">StringIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BytesIO"><span class="nav-number">12.2.2.</span> <span class="nav-text">BytesIO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作文件盒目录"><span class="nav-number">12.3.</span> <span class="nav-text">操作文件盒目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量"><span class="nav-number">12.3.1.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作文件和目录"><span class="nav-number">12.3.2.</span> <span class="nav-text">操作文件和目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化"><span class="nav-number">12.4.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON"><span class="nav-number">12.4.1.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-进阶"><span class="nav-number">12.4.2.</span> <span class="nav-text">JSON 进阶</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程和线程"><span class="nav-number">13.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多进程"><span class="nav-number">13.1.</span> <span class="nav-text">多进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#multiprocessing"><span class="nav-number">13.1.1.</span> <span class="nav-text">multiprocessing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pool"><span class="nav-number">13.1.2.</span> <span class="nav-text">Pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子进程"><span class="nav-number">13.1.3.</span> <span class="nav-text">子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通讯"><span class="nav-number">13.1.4.</span> <span class="nav-text">进程间通讯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">13.2.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock"><span class="nav-number">13.2.1.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多核CPU"><span class="nav-number">13.2.2.</span> <span class="nav-text">多核CPU</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">13.3.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程-vs-线程"><span class="nav-number">13.4.</span> <span class="nav-text">进程 vs. 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程切换"><span class="nav-number">13.4.1.</span> <span class="nav-text">线程切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式进程"><span class="nav-number">13.5.</span> <span class="nav-text">分布式进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用内建模块"><span class="nav-number">14.</span> <span class="nav-text">常用内建模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sys"><span class="nav-number">14.1.</span> <span class="nav-text">sys</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#name-属性"><span class="nav-number">14.2.</span> <span class="nav-text">name 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建自己的模块"><span class="nav-number">14.3.</span> <span class="nav-text">创建自己的模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#datetime"><span class="nav-number">14.4.</span> <span class="nav-text">datetime</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前日期和时间"><span class="nav-number">14.4.1.</span> <span class="nav-text">获取当前日期和时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取指定日期和时间"><span class="nav-number">14.4.2.</span> <span class="nav-text">获取指定日期和时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#datetime-转换成-timestamp"><span class="nav-number">14.4.3.</span> <span class="nav-text">datetime 转换成 timestamp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timestamp-–-gt-datetime"><span class="nav-number">14.4.4.</span> <span class="nav-text">timestamp –&gt; datetime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#str-–-gt-datetime"><span class="nav-number">14.4.5.</span> <span class="nav-text">str –&gt; datetime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#datetime-–-gt-str"><span class="nav-number">14.4.6.</span> <span class="nav-text">datetime –&gt; str</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#datetime加减"><span class="nav-number">14.4.7.</span> <span class="nav-text">datetime加减</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地时间-–-gt-UTC"><span class="nav-number">14.4.8.</span> <span class="nav-text">本地时间 –&gt; UTC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections"><span class="nav-number">14.5.</span> <span class="nav-text">collections</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namedtuple"><span class="nav-number">14.5.1.</span> <span class="nav-text">namedtuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">14.5.2.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defalutdict"><span class="nav-number">14.5.3.</span> <span class="nav-text">defalutdict</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OrderedDict"><span class="nav-number">14.5.4.</span> <span class="nav-text">OrderedDict</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Counter"><span class="nav-number">14.5.5.</span> <span class="nav-text">Counter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#base64"><span class="nav-number">14.6.</span> <span class="nav-text">base64</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct"><span class="nav-number">14.7.</span> <span class="nav-text">struct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashlib"><span class="nav-number">14.8.</span> <span class="nav-text">hashlib</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用"><span class="nav-number">14.8.1.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterrools"><span class="nav-number">14.9.</span> <span class="nav-text">iterrools</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#chain"><span class="nav-number">14.9.1.</span> <span class="nav-text">chain()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#groupby"><span class="nav-number">14.9.2.</span> <span class="nav-text">groupby()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XML"><span class="nav-number">14.10.</span> <span class="nav-text">XML</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTMLParser"><span class="nav-number">14.11.</span> <span class="nav-text">HTMLParser</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#urllib"><span class="nav-number">14.12.</span> <span class="nav-text">urllib</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Get"><span class="nav-number">14.12.1.</span> <span class="nav-text">Get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Post"><span class="nav-number">14.12.2.</span> <span class="nav-text">Post</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler"><span class="nav-number">14.12.3.</span> <span class="nav-text">Handler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用第三方模块"><span class="nav-number">15.</span> <span class="nav-text">常用第三方模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PIL"><span class="nav-number">15.1.</span> <span class="nav-text">PIL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装"><span class="nav-number">15.1.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作图像"><span class="nav-number">15.1.2.</span> <span class="nav-text">操作图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#crop"><span class="nav-number">15.1.3.</span> <span class="nav-text">crop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#combine"><span class="nav-number">15.1.4.</span> <span class="nav-text">combine</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图形界面"><span class="nav-number">16.</span> <span class="nav-text">图形界面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Tkinter"><span class="nav-number">16.1.</span> <span class="nav-text">Tkinter</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程"><span class="nav-number">17.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP-简介"><span class="nav-number">17.1.</span> <span class="nav-text">TCP/IP 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP编程"><span class="nav-number">17.2.</span> <span class="nav-text">TCP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端"><span class="nav-number">17.2.1.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器"><span class="nav-number">17.2.2.</span> <span class="nav-text">服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-编程"><span class="nav-number">17.3.</span> <span class="nav-text">UDP 编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#电子邮件"><span class="nav-number">18.</span> <span class="nav-text">电子邮件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#访问数据库"><span class="nav-number">19.</span> <span class="nav-text">访问数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用SQLite"><span class="nav-number">19.1.</span> <span class="nav-text">使用SQLite</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">19.2.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装MySQL"><span class="nav-number">19.2.1.</span> <span class="nav-text">安装MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装MySQL驱动"><span class="nav-number">19.2.2.</span> <span class="nav-text">安装MySQL驱动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQLAlchemy"><span class="nav-number">19.3.</span> <span class="nav-text">SQLAlchemy</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Web-开发"><span class="nav-number">20.</span> <span class="nav-text">Web 开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-协议简介"><span class="nav-number">20.1.</span> <span class="nav-text">HTTP 协议简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-格式"><span class="nav-number">20.1.1.</span> <span class="nav-text">HTTP 格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML简介"><span class="nav-number">20.2.</span> <span class="nav-text">HTML简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WSGI-接口"><span class="nav-number">20.3.</span> <span class="nav-text">WSGI 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Web框架"><span class="nav-number">20.4.</span> <span class="nav-text">使用Web框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用模版"><span class="nav-number">20.5.</span> <span class="nav-text">使用模版</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步IO"><span class="nav-number">21.</span> <span class="nav-text">异步IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#协程"><span class="nav-number">21.1.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#asyncio"><span class="nav-number">21.2.</span> <span class="nav-text">asyncio</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-await"><span class="nav-number">21.3.</span> <span class="nav-text">async/await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aiohttp"><span class="nav-number">21.4.</span> <span class="nav-text">aiohttp</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Double</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
