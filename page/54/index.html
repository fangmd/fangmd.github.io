<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta property="og:type" content="website">
<meta property="og:title" content="Double">
<meta property="og:url" content="http://yoursite.com/page/54/index.html">
<meta property="og:site_name" content="Double">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Double">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/54/">





  <title>Double</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Double</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/01/ReadNote/深入理解java虚拟机读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/01/ReadNote/深入理解java虚拟机读书笔记/" itemprop="url">深入理解java虚拟机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-01T21:38:14+08:00">
                2016-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="《深入理解java虚拟机》读书笔记"><a href="#《深入理解java虚拟机》读书笔记" class="headerlink" title="《深入理解java虚拟机》读书笔记"></a>《深入理解java虚拟机》读书笔记</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>java的优点；认清java运行的本质；</p>
<h3 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h3><p>Sun官方定义的Java技术体系包括了：</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机</li>
<li>Class文件格式</li>
<li>Java API类库</li>
<li>来自商业机构和开源社区的第三方类库</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/01/01/ReadNote/深入理解java虚拟机读书笔记/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/Day2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/Day2/" itemprop="url">java -- day2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><hr>
<h2 id="什么是JAVA语句的执行结构"><a href="#什么是JAVA语句的执行结构" class="headerlink" title="什么是JAVA语句的执行结构"></a>什么是JAVA语句的执行结构</h2><p><strong>&gt;JAVA语句的执行结构：运行在jvm中的字节码文件代码执行的路径。</strong></p>
<h2 id="JAVA语句有哪些结构"><a href="#JAVA语句有哪些结构" class="headerlink" title="JAVA语句有哪些结构"></a>JAVA语句有哪些结构</h2><ul>
<li>顺序语句：程序遵循从上往下，从左往右。</li>
<li>分支语句：程序执行时，满足某个条件，执行相应的语句块，否则，执行其余的代码块。</li>
<li><p>循环语句：程序执行时，对于某段反复或者是多次执行的语句。</p>
<h2 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h2><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p>  if分支语句的分类：<br>  ①单分支<br>  if(取值为boolean型的表达式){</p>
<pre><code>//语句块
</code></pre><p>  }<br>  ②双分支<br>  if(取值为boolean型的表达式){</p>
<pre><code>//语句块
</code></pre><p>  }else{</p>
<pre><code>//语句块
</code></pre><p>  }<br>  ③多分支<br>  if(取值为boolean型的表达式1){</p>
<pre><code>//语句块1
</code></pre><p>  }else if(取值为boolean型的表达式2){</p>
<pre><code>//语句块2
</code></pre><p>  }<br>   ….<br>  else{</p>
<pre><code>//语句块
</code></pre><p>  }<br>  拓展：嵌套if分支语句：在分支语句中，可以继续书写if分支语句。<br>  注意：从语法的角度而言，嵌套的层数没有限制，但是，为了提高程序的可读性和可维护性，建议层数&lt;= 3。<br><strong>switch语句的语法：**</strong>没有longfloatdouble**</p>
<p>  switch(表达式){//表达式值的类型是byte,short,char,int,<strong>枚举</strong>（jdk &gt;= 1.5），String(jdk &gt;= 1.7)</p>
<pre><code>case 常量值1:
  语句1
  break;
case 常量值2:
  语句2
  break;
case 常量值3:
   语句3
  break;
...
default:
 xxx
</code></pre><p>   }<br><strong>说明：</strong>若表达式的值与case分支后常量值相匹配，就会执行该<code>case</code>分支.</p>
</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li>1、case分支后常量值不允许重复</li>
<li>2、多个case分支，若处理方式一样，可以简写。（将多个<code>case</code>叠加在一起）</li>
<li>3、每个case分支，建议都书写break.</li>
<li>4、从语法的角度而言，default语句可以书写在switch分支语句的任意地方，但是，<strong>若不书写在最后，需要添加“<code>break;</code>”,书写在最后，不需要添加。</strong></li>
</ul>
<p><strong>switch语句与if语句的异同点:</strong></p>
<pre><code>同：都是选择分支语句。
异：1、语法不同。
    2、语句后表达式值的类型不同，if语句表达式值的类型是`boolean,switch`分支表达式值的类型是`byte,short,char,int,**枚举**，String`。
    3、适用场景
       if:变量的值在某个区间之内。
       switch:变量的值是某个定值。
</code></pre><p>##循环语句</p>
<blockquote>
<p>程序在执行时，某段反复或者是多次执行的逻辑。</p>
</blockquote>
<p><strong>for循环</strong>    </p>
<pre><code>语法：for(表达式1;表达式2;表达式3){
    //循环体
      }

说明：表达式1一般用于给循环变量进行初始化(只能执行一次)
     表达式2取值是一个boolean值，用于判定循环的条件满足与否，满足，继续执行循环体，否则，退出循环体的执行（至少执行一次）
     表达式3一般用来修改循环变量的值（有可能一次都不执行）
     **循环（有可能一次都不执行)**
</code></pre><p><strong>for循环拓展：</strong></p>
<pre><code>1、嵌套for循环
    循环体中代码继续使用for循环，从语法的角度而言，没有限制，建议层数&lt;=3.
  案例：使用嵌套for循环打印九九乘法表。    
2、for循环中各个表达式奇葩的写法（笔试）
    2.1 死循环：for(;;){}
    2.2 注意表达式1中的循环变量的作用域范围；
    2.3 表达式用于修改循环变量的值，步长默认是1也可以改变。
    2.4 倒序输出：for(int i=10;i&gt;=1;i--){}
    2.5 表达式3可以是**复合语句**：for(i=1;i&lt;5;System.out.println(&quot;i=&quot;+i)){}
</code></pre><p><strong><em>**</em></strong>while循环<strong><em>**</em></strong></p>
<pre><code>语法：while(取值类型位boolean的表达式){
         //循环体
      }
说明：先判断，再执行。满足条件，执行循环体，否则，跳出循环体的执行，执行循环体后续的语句。
     有可能一次都不执行

案例：使用while循环，求出任意给定的数各个位上的数字之和。
分析： 1234
  从低位开始，每位上的数字对10求余，将语句累加起来；
然后，将商赋值给当前分析的数字。以此类推，直到商为0，
退出。
</code></pre><p><strong>do-while循环</strong></p>
<pre><code>语法：do{
    //循环体
      }while(取值类型为boolean的表达式);
说明：先执行，再判断。若满足条件，继续执行循环体，否则，跳出循环体的执行，执行循环体后续的语句。
      至少会执行一次

案例：使用do...while...循环，完成一个猜数的游戏。
分析：1,在1～10区间内，任意产生一个随机数（根据某个算法，产生的随机数），Math类有方法random()工具方法，Math.random();//[0,1)double型的值
      2,从控制台接收用户猜的数
      3、将用户猜的数与随机数进行比较
        &gt;随机数，提示，大了
        &lt;随机数，提示，小了哦
     直到用户猜中为止
</code></pre><p><strong>跳转语句</strong></p>
<blockquote>
<p>会对程序的执行轨迹产生变更的语句。<br>注意：return其实，也是跳转语句。</p>
</blockquote>
<p><strong>break语句的使用：</strong></p>
<ul>
<li>使用在switch分支语句中，含义是：跳出switch语句块。</li>
<li>使用在循环体中，含义：跳出当前循环。（注意：与break相隔最近的循环）<br>案例：使用break语句，模拟一个场景，学校举行4000长跑比赛，选手跑到第4圈时，腿抽筋，有队医搀扶着退出比赛的情形。</li>
</ul>
<p><strong>break拓展：</strong></p>
<ul>
<li>在多重循环体中，最内层中的break语句，<strong>跳出的是当前循环</strong>。</li>
<li>如何在内循环中，直接退出外循环，实现方式有<strong>几</strong>种。3种：1.连续跳出2.做标记3.满足条件跳出</li>
</ul>
<p><strong>continue语句的使用：</strong></p>
<blockquote>
<p>只能使用在循环体中，含义：结束本次循环，继续下一次循环。==》特点：<strong>没有退出当前循环</strong>，依然在循环体中。</p>
<p>需求：使用continue，打印输出1～10以内所有的奇数。</p>
</blockquote>
<p><strong>for,while和do-while三种循环的异同点。</strong></p>
<pre><code>同：都是循环语句。
异：1、语法不同
    2、适用场景不同
      1）for:直到循环开始和结束的条件。
      2）while:不知道循环的次数；且，需要先判断，再执行的场合。
      3）do...while...：不知道循环的次数；且，需要执行，再判断的场合;循环体至少会执行一次。

拓展开来：其实三个循环语句可以混用，关键点在于根据相应循环语句的特点，选用最为合适的循环。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/Day15总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/Day15总结/" itemprop="url">Day15 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day15-总结"><a href="#Day15-总结" class="headerlink" title="Day15 总结"></a>Day15 总结</h1><h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><h3 id="使用System-in获取键盘数据"><a href="#使用System-in获取键盘数据" class="headerlink" title="使用System.in获取键盘数据"></a>使用System.in获取键盘数据</h3><blockquote>
<p>标准输入流System.in,类型是InputStream,只有将该流的对象作为System类的静态属性时。（静态最终属性）</p>
</blockquote>
<p>含义：获取用户从控制台录入的数据，将其通过InputStream字节输入流读如到内存中。<br>例如：<code>Scanner input = new Scanner(System.in);</code></p>
<h3 id="使用System-out输出数据"><a href="#使用System-out输出数据" class="headerlink" title="使用System.out输出数据"></a>使用System.out输出数据</h3><blockquote>
<p>标准输出流System.out,类型是PrintStream，只有将该流的对象作为System类的静态属性时。</p>
</blockquote>
<p>含义：将内存中的数据写入到打印字节输出流中，然后，输出到控制台。（默认的目的地）</p>
<p>两个重要的<code>System</code>静态方法：</p>
<ol>
<li>static void setIn(InputStream in) ：定制标准输入流的源。（默认源是：控制台）</li>
<li>static void setOut(PrintStream out) ：定制标准输出流的目的地。（默认目的地是：控制台）<br>##转换流<br>###InputStreamReader的构造方法<br><code>InputStreamReader</code>–&gt;将字节流转换成字符流（设计者说：<code>InputStreamReader</code> 是字节流通向字符流的桥梁）</li>
</ol>
<blockquote>
<p><code>InputStreamReader(InputStream in)</code> ：将参数指定的一个字节输入流封装成一个字节字符转换流。</p>
</blockquote>
<p><code>InputStreamReader(InputStream in, Charset cs)</code>：将参数指定的一个字节输入流以指定的字符集封装成一个字节字符转换流。</p>
<blockquote>
<p><code>InputStreamReader(InputStream in, String charsetName)</code>：xxx</p>
</blockquote>
<p>###InputStreamReader的使用    </p>
<blockquote>
<p><code>String getEncoding()</code> ：获得转换流使用的字符集名称。</p>
</blockquote>
<p>InputStreamReader设计的本质：</p>
<ol>
<li>操作文本文件时，将字节流转换成字符流，便于操作。</li>
<li>可以解决字符集乱码的问题：<ol>
<li>若是字节输入流，读取文本文件时，文本文件中若存在中文，字节数组的长度很小的场合（比如1），所有的汉字都变成了乱码！若转换成字符流，就没有乱码了！</li>
<li>若是源的字符集与默认的字符集不吻合，也有乱码。解决方案：读取源时，指定与之匹配的字符集，保证读取到流中的数据没有乱码的。</li>
</ol>
</li>
</ol>
<p>###OutputStreamWriter的构造方法    </p>
<blockquote>
<p>OutputStreamWriter–》将字符流转换成字节流输出到存储介质上去（设计者说：OutputStreamWriter 是字符流通向字节流的桥梁）</p>
</blockquote>
<blockquote>
<p><code>OutputStreamWriter(OutputStream out)</code> ：通过参数指定的字节流构建字符流的对象</p>
<p><code>OutputStreamWriter(OutputStream out, Charset cs)</code> ：xxx</p>
<p><code>OutputStreamWriter(OutputStream out, String charsetName)</code>:创建使用指定字符集的 OutputStreamWriter。</p>
</blockquote>
<p>###OutputStreamWriter的使用    </p>
<blockquote>
<p>String getEncoding()  返回此流使用的字符编码的名称。</p>
</blockquote>
<pre><code>需求：
1、使用字节字符转换输入流，结合字符字节转换输出流，实现文件的拷贝。

要求：①源文件的字符集是UTF-8
     ②目标文件的字符集是GBK

--------------------------------
要求：①源文件的字符集是GBK
     ②目标文件的字符集是UTF-8

--------------------------------
要求：①源文件的字符集是UTF-8
     ②目标文件的字符集是UTF-8
</code></pre><p>思路：</p>
<ol>
<li>通过<code>FileInputStream</code>的对象构建<code>InputStreamReader</code>的对象</li>
<li>通过<code>FileOutputStream</code>的对象构建<code>OutputStreamWriter</code>的实例</li>
<li>循环读写</li>
<li>释放资源<br>###将键盘数据转成字符流写入文本<br>##字节缓存流    <blockquote>
<p>在操作数据时，先将数据读入内部的缓冲区（字节数组），然后，程序操作的是缓冲区中的数据，最大的优点：可以提高数据在流中传输的速度。在项目中建议多使用。</p>
</blockquote>
###字节缓存流的构造方法    <blockquote>
<p>BufferedInputStream(InputStream in) xx</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>BufferedOutputStream(OutputStream out) </p>
</blockquote>
<p>###使用字节缓存流对文件进行读写    </p>
<blockquote>
<p>BufferedInputStream 为另一个输入流添加一些功能，即缓冲输入以及支持 mark 和 reset 方法的能力</p>
</blockquote>
<p><strong>常用方法：</strong></p>
<ol>
<li>void mark(int readlimit) ：在流中相应的位置添加一个标记。</li>
<li>boolean markSupported() ：判断此种类型的流是否支持添加标记</li>
<li><p>void reset()  ：让流出数据回滚到流中，实现：覆水可收的效果。</p>
<p> 需求：<br> 使用带缓存的字节流实现：将用户从控制台录入的数据，写入到磁盘上另外一个文件中，与此同时，将用户录入的数据显示到控制台上。<br> 直到用户录入886，就退出程序。</p>
<p> 思路：</p>
<ol>
<li>通过标准输入流Sytem.in构建缓冲字节输入流</li>
<li>通过定制标准输出流的目的地，封装一个打印输出流，据此，构建一个缓存字节输出流</li>
<li>循环读取用户从控制台的录入，写入到缓存字节输出流中，同时，打印到控制台上，直至886<br>##字符缓存流    <blockquote>
<p>流中的数据先存储在内部的缓冲区中（字符数组），然后程序与该缓冲区中的数据进行交互。可以提高数据在流中传输的效率。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>官方对BufferedReader的说明：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 </p>
</blockquote>
<p>###字符缓存流构造方法    </p>
<blockquote>
<p>BufferedReader(Reader in) </p>
</blockquote>
<blockquote>
<p>BufferedWriter(Writer out) </p>
</blockquote>
<p>###字符缓存流的常用方法:readLine()，  newLine()      </p>
<blockquote>
<p>String readLine() ：从流中读取一行数据（注意：此处换行符读取不进来的）</p>
</blockquote>
<blockquote>
<p>void newLine() 写入一个行分隔符。（就是换行符，根据底层os的不同，动态生成与之匹配的换行符） </p>
</blockquote>
<p>###字符缓存流对文件进行读写</p>
<pre><code>需求：使用缓冲字符输入、输出流，实现文本文件的拷贝。
要求：设计一个工具类，设计一个拷贝的工具方法。
验证：①拷贝文本文件，ok
      ②拷贝可执行文件，如：*.exe,执行不了的。

思路：
1、通过FileReader构建BufferedReader的对象
2、通过FileWriter构建BufferedWriter的对象
3、循环读写
  分别使用两种方式：传统方式（借助字符数组）
   新潮方式（借助：readLine()，newLine()）
xxx 

---&gt;拓展：
需求：使用缓冲字符输入、输出流，实现文本文件的拷贝。
要求：源的字符集是UTF-8,目的地的字符集是UTF-8.
</code></pre><p>###Properties资源文件操作类与io流如何结合</p>
<p>结合步骤：</p>
<p>①在项目中相应目录下准备资源文件（.properties）<br> 文件中以键值对的形式，将项目中一些共通的信息记录起来</p>
<p>②设计工具类，工具方法<br>  使用将资源文件装载进内存，具体装载到Properties实例中，<br>  从实例中读取配置信息</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/Day1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/Day1/" itemprop="url">java -- day1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><h2 id="基础常识"><a href="#基础常识" class="headerlink" title="基础常识"></a>基础常识</h2><h3 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h3><blockquote>
<p>软件是一系列按照特定顺序组织的计算机数据和指令的集合。</p>
<p>数据是用于描述事物的信息。</p>
</blockquote>
<blockquote>
<p>指令就是告诉计算机如何处理数据</p>
</blockquote>
<h3 id="软件开发的步骤"><a href="#软件开发的步骤" class="headerlink" title="软件开发的步骤"></a>软件开发的步骤</h3><ol>
<li>需求分析 </li>
<li>设计<ul>
<li>概要设计</li>
<li>详细设计 </li>
</ul>
</li>
<li>编码</li>
<li>测试：单元测试（黑盒测试、白盒测试）</li>
<li>上线：试运行、正式交付</li>
</ol>
<h3 id="常用的DOS命令"><a href="#常用的DOS命令" class="headerlink" title="常用的DOS命令"></a>常用的DOS命令</h3><p>dos命令含义</p>
<ul>
<li>cd 目录：  将当前目录修改为指定的目录</li>
<li>cd..：退回到上一级目录</li>
<li>cd\：退回到根目录</li>
<li>盘符：  切换为当前的盘符</li>
<li>cls：将当前命令行屏幕内容清空</li>
<li>dir:列出当前目录下的文件及文件夹</li>
<li>md：创建目录</li>
<li>rd： 删除目录</li>
<li>del:删除文件</li>
<li>exit：退出dos命令行</li>
</ul>
<h3 id="java简介"><a href="#java简介" class="headerlink" title="java简介"></a>java简介</h3><blockquote>
<p>Java语言是SUN公司(Sranford University NetWork,斯坦福大学网络公司)1995年推出的一门高级编程语言。PS：被Oracle公司收购</p>
</blockquote>
<p><strong>java语言的含义：</strong>面向对象的编程语言。</p>
<p>java包括：</p>
<ul>
<li>javase：Java2 Platform Enterprise Edition 企业版</li>
<li>javaee: Java2 Platform Standerd Edition 标准版</li>
<li>javame: Java2 Platform Micro Edition 小型版</li>
</ul>
<p>java的版本：jdk 1.0、jdk 1.5、jdk 1.7</p>
<p>java语言的特点：</p>
<ul>
<li>安全的</li>
<li>跨平台：java在不同的操作系统中都能运行。原理：在需要运行java应用程序的操作系统中安装java虚拟机(jvm:java virtual machine)，由jvm来调用操作系统底层指令解析、执行java程序，从而在改操作系统中运行。（jvm不是跨平台的，不同的操作系统有不同版本的jvm）</li>
<li>健壮</li>
<li>开源、免费<h2 id="JAVA环境的搭建"><a href="#JAVA环境的搭建" class="headerlink" title="JAVA环境的搭建"></a>JAVA环境的搭建</h2></li>
<li>环境变量：供os使用的变量。<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3></li>
<li>环境变量的划分：<ul>
<li>用户变量</li>
<li>系统变量</li>
</ul>
</li>
<li>配置环境变量的目的何在？<blockquote>
<p>为了在任意盘符任意目录下调用环境变量值指定目录下的所有可执行文件。</p>
</blockquote>
<h3 id="什么是JRE，什么是JDK"><a href="#什么是JRE，什么是JDK" class="headerlink" title="什么是JRE，什么是JDK"></a>什么是JRE，什么是JDK</h3><blockquote>
<p>jre:java runtime enviroment:java运行环境:包括java虚拟机和java程序所需的核心类库等，如果要运行一个开发好的java程序，计算机中只需安装jre即可。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>jdk:java Development Kit:java开发工具包：提供给java开发人员使用的，其中包含了java的开发工具，也包括了jre.所以安装了jdk，就不用再单独安装jre了，其中的开发工具有编译工具（javac.exe），打包工具（jar.exe）等。</p>
</blockquote>
<blockquote>
<p><strong>为什么jdk中包含一个jre呢？</strong>其一：开发完的程序，需要运行一下看看效果，就像exe文件需要在windows环境下运行一样。其二：也是最重要的，jdk中的开发工具（如javac.exe、java.exe等）其实都是java语言编写的应用程序，为了方便使用才打包成exe文件，如果没有jre那么这些工具是运行不了的。</p>
</blockquote>
<blockquote>
<p><strong>总结：</strong>jre：jvm+类库（java librery）。jdk：jre+java的开发工具。</p>
</blockquote>
<h2 id="第一个Java程序HelloWord"><a href="#第一个Java程序HelloWord" class="headerlink" title="第一个Java程序HelloWord"></a>第一个Java程序HelloWord</h2><h3 id="在记事本编写程序"><a href="#在记事本编写程序" class="headerlink" title="在记事本编写程序"></a>在记事本编写程序</h3><pre><code>在记事本编写程序:创建一个后缀为.java的源程序，编写代码。
</code></pre><h3 id="在DOS命令窗口编译执行"><a href="#在DOS命令窗口编译执行" class="headerlink" title="在DOS命令窗口编译执行"></a>在DOS命令窗口编译执行</h3><blockquote>
<p>在DOS命令窗口编译执行:</p>
<p>javac java源程序名.java   &lt;–编译生成字节码文件，也就是可执行的java程序。 </p>
<p>java  编译生成的字节码文件名(.class)</p>
</blockquote>
<h3 id="讲解源程序的编译执行"><a href="#讲解源程序的编译执行" class="headerlink" title="讲解源程序的编译执行"></a>讲解源程序的编译执行</h3><p><strong>java源程序的构成</strong> </p>
<pre><code>如何编译一个带了包名的java源程序?
 javac -d .  源程序名
 含义：在当前目录下创建以包名命名的目录，层次结构与包名的顺序一致，将生成的字节码文件置于最内层目录。

如何运行一个带了包名的字节码文件？
 1）退到最外层目录
 2）通过java 类的全限定名
    类的全限定名：带了包名的类名，如： com.l000phone.day01.JavaCodeIncludeDemo

源程序的构成：1）包 2）导入语句 3)类（主方法：程序执行的入口）
</code></pre><p><strong>注释:</strong></p>
<pre><code>当行:语法：//xxx
多行:语法：/*  xxxx  */
文档:/**
     xxxxx
     */
    文档注释的作用：生成程序使用说明书。
    注释的作用：用来给程序员阅读代码看的。
</code></pre><p><strong>classpath环境变量的设置以及环境变量的临时设置</strong></p>
<pre><code>classpath的作用：类似于path环境变量，高数jvm去哪里找class文件。

jvm查找类文件的顺序：
  1.如果没有配置classpath环境变量，jvm只在当前目录下查找要运行的类文件。
2、如果配置了classpath环境变量，jvm会先在classpath环境变量值得目录中查找要运行的类文件。
classpath环境变量配置语法？
 环境变量名：classpath
 环境变量值：字节码文件所在的目录，值一般是jar文件
 达到效果:在任意的盘符，任意的目录下可以运行classpath环境变量值该目录下所有的字节码文件。

环境变量的临时设置:
语法： set 环境变量名=环境变量值
如何查看环境变量的值？
语法： set 环境变量名
特点：只针对当前命令行窗口有效，关闭之后，失效。
</code></pre><p><strong>java源程序深度剖析：</strong></p>
<ul>
<li>一个源文件可以书写n个类，只有一个类可以使用public修饰符来修饰，此时，该类的类名必须与源程序名保持一致。</li>
<li>每个类都可以有入口（main方法）</li>
<li>一个源程序中有几个类，编译后，就会生成几个字节码文件。</li>
</ul>
<h2 id="关键字、标识符"><a href="#关键字、标识符" class="headerlink" title="关键字、标识符"></a>关键字、标识符</h2><h3 id="什么是标识符"><a href="#什么是标识符" class="headerlink" title="什么是标识符"></a>什么是标识符</h3><blockquote>
<p>标识符：由字母、数字、下划线、<strong>$符合</strong>组合而成的字符序列。</p>
</blockquote>
<h3 id="标识符的命名规范"><a href="#标识符的命名规范" class="headerlink" title="标识符的命名规范"></a>标识符的命名规范</h3><blockquote>
<p>合法的java标识符的命名规范：<br>不能以数字开头</p>
<ul>
<li>不能是关键字、保留字</li>
</ul>
<p>推荐合法的标识符的写法：<br>1、遵循“驼峰命名法”<br>  a)类名、接口名<br>  b)变量名、参数名、方法名<br>2、长度&lt;= 15 如：stuName<br>3、见名知意</p>
<p>合法的标识符的用途何在？<br>类名、接口名、包名、方法名、参数名、变量名等等。</p>
<p>包名的命名规范：1）所有包小写，各个包之间以.隔开。<br>             2）客户公司网站名的倒写，除去“www”   <a href="http://www.lenovo.com--&gt;com.lenovo.项目名的缩&gt;写.模块名" target="_blank" rel="noopener">www.lenovo.com--&gt;com.lenovo.项目名的缩&gt;写.模块名</a></p>
</blockquote>
<h3 id="JAVA关键字"><a href="#JAVA关键字" class="headerlink" title="JAVA关键字"></a>JAVA关键字</h3><p>JAVA关键字：java语言的设计者赋予了特殊含义的英文单词。如：class int public package import 等等<br>保留字：预备关键字  如：goto byValue, cast, false, future, generic, inner, operator, outer, rest, true, var const,null</p>
<h2 id="常量、进制转换"><a href="#常量、进制转换" class="headerlink" title="常量、进制转换"></a>常量、进制转换</h2><h3 id="什么是常量"><a href="#什么是常量" class="headerlink" title="什么是常量"></a>什么是常量</h3><pre><code>固定不变的量
语法：final 类型 标识符;
</code></pre><h3 id="二进制转换十进制"><a href="#二进制转换十进制" class="headerlink" title="二进制转换十进制"></a>二进制转换十进制</h3><pre><code>特点：
1、常量只能赋值一次。
2、赋值的方式分类：
    ①声明的同时直接赋值；
    ②声明与赋予初始值分开。
</code></pre><p><strong>常量的命名规范</strong>：</p>
<pre><code>全部大写，遇到不同的单词，使用下划线分割。如：final CIRCLE_PI = 3.1415;
二进制转换十进制: 从低位开始，对应的基数乘以进制的n次幂之和。（n：0～n-1）.
如：101 --》1*2（0） + 0*2（1） + 1*2（2） = 5
</code></pre><p><strong>算法：</strong></p>
<pre><code>软件前辈们总结出来解决某类问题最有效的方法。
</code></pre><p><strong>十进制转换成二进制：</strong></p>
<pre><code>要转换的数对进制求余数，然后，对应的商继续对进制求余，直到商为0。
然后，将所有的余数从下往上拼接起来，即为最终的结果。
</code></pre><h2 id="变量、数据类型、类型转换"><a href="#变量、数据类型、类型转换" class="headerlink" title="变量、数据类型、类型转换"></a>变量、数据类型、类型转换</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><blockquote>
<p>用来存储变动的值的合法的java标识符。</p>
<p>类型 变量名;</p>
<p>特点：1、局部变量使用之前一定要进行初始化。2、变量的值是变动的。</p>
</blockquote>
<h3 id="变量的声明和初始化"><a href="#变量的声明和初始化" class="headerlink" title="变量的声明和初始化"></a>变量的声明和初始化</h3><h3 id="变量的分类-及作用域"><a href="#变量的分类-及作用域" class="headerlink" title="变量的分类    及作用域"></a>变量的分类    及作用域</h3><pre><code>①全局变量：定义在类体中，与方法平级的变量。
     特点：a）作用域范围在整个类体中都有效。
          b）全局变量有分为：
               非静态的全局变量，只能使用在普通方法中，静态方法不能使用。
               静态的全局变量，既可以使用在普通方法中，可以使用在静态方法中。
          c)全局变量都有一个默认的初始值。
②局部变量：定义在方法体中或者是代码块中的变量。
        特点：a）作用域范围仅仅限于其所在的方法体或者是代码块。
          b）子块可以访问其之前父块中的变量，反之，父块不能使用子块特有的变量。
          c)局部变量使用之前一定要进行初始化
</code></pre><h2 id="变量名的命名规范"><a href="#变量名的命名规范" class="headerlink" title="变量名的命名规范"></a>变量名的命名规范</h2><h3 id="JAVA中的数据类型"><a href="#JAVA中的数据类型" class="headerlink" title="JAVA中的数据类型"></a>JAVA中的数据类型</h3><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>数值型（整型&lt;byte,short,int,long&gt;</li>
<li>浮点型&lt;float,double&gt;）</li>
<li>字符型(char)</li>
<li>布尔型(boolean)。<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3></li>
<li>类</li>
<li>接口</li>
<li><p><strong>数组</strong></p>
<h2 id="数据类型的取值范围"><a href="#数据类型的取值范围" class="headerlink" title="数据类型的取值范围"></a>数据类型的取值范围</h2><pre><code>类型名    关键字    占用的字节数    取值范围        规律
</code></pre><p>  整型     字节    byte    1            -128～127   </p>
<pre><code>短整型    short    2                    -2（15）～　2（15）-1   
整型    int        4                        2（31）～　2（31）-1 
长整型    long    8                    -2（63）～　2（63）-1 
</code></pre><p>  浮点型      单精度    float    4</p>
<pre><code>双精度    double    8 
字符型    char    2             0～65535
布尔型    boolean    1             false,true
</code></pre><p><strong>java中数据类型特别说明：</strong></p>
</li>
<li><p>浮点型在计算机底层，使用的是科学计数法来进行存储的。<br>1234.89–》1.23489*10(3)(书本上)–》1.23489E3<br><strong>注意：</strong></p>
<ul>
<li>小数默认是double型</li>
<li>显示的结果分为：①数据小，显示本身的数值 ②数据大，显示科学计数法的结果。</li>
<li>浮点数在底层，使用近似值来表示，不适用于在银行、电信领域存储金额。（使用BigDecimal来存储小数，小数点后精确到的位数可以任意定制）</li>
<li>同字节的浮点数较之于同字节的整数或者是比起字节数多的整数，能够存储更多更大的数值。</li>
</ul>
</li>
<li><p>字符型说明：</p>
<blockquote>
<p><em>语法</em>：char 变量 = ‘单个字符’;</p>
<p><em>特点</em>：1、单个字符:个数是1，包括：汉字，英文字母，特殊的符号；<br>2、不允许什么都没有3、采用的字符集是unicode,该字符集的特点是：任何字符都占用2个字节。</p>
<p><em>字符集</em>：将语言文字与计算机底层表示的数值建立映射关系的二维表。(‘\U0000’～’\UFFFF’)</p>
<p>常用的字符集：ascii:a～ｚ　A～Z 0～9 ‘a’–&gt;97 ‘A’–&gt;65 ‘0’–&gt;48</p>
</blockquote>
</li>
<li><p>gb2312:简体中文</p>
</li>
<li>gbk:简体、繁体中文</li>
<li>gb18030:简体、繁体、生僻的汉字</li>
<li>iso-8859-1:西文字符集</li>
</ul>
<h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><blockquote>
<p>相兼容的数据类型之间，将取值范围较小的数值和变量赋值给取值范围较大的类型对应的变量。</p>
</blockquote>
<p>如：<code>int age = 34;long age2 = age;//long age2 = 45;</code></p>
<p><strong>注意：</strong></p>
<ul>
<li>byte、short、char类型的变量进行运算时，首先会自动提升为int型，然后，参与运算。</li>
<li>整型数值默认的类型是int。</li>
<li>单精度的浮点数进行运算时，不会自动提升为double。<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><blockquote>
<p>相兼容的数据类型之间，将取值范围较大的数值和变量赋值给取值范围较小的类型对应的变量。</p>
<p>语法：取值范围较小的类型  变量名 = (取值范围较小的类型)取值范围较大的变量或者是值;如：<code>int age = 56;byte ageTmp = (byte)age;</code></p>
</blockquote>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="常用运算符八类"><a href="#常用运算符八类" class="headerlink" title="常用运算符八类"></a>常用运算符八类</h3></li>
<li>算术运算符：<code>= - * / %  ++ --</code></li>
<li>赋值运算符：<code>= -= += *= /= %=</code>    </li>
<li>关系运算符：<code>&gt; &gt;= &lt; &lt;= !=</code></li>
<li>逻辑运算符：<code>&amp;    | ^  !  &amp;&amp;  ||</code>    </li>
<li>三目运算符：<code>与值相同的类型 变量名=取值为boolean型的表达式?值1：值2;</code>    </li>
<li>字符串连接运算符：<code>+</code>    </li>
<li>位运算符：<code>&amp; | ^ ~</code></li>
<li>移位运算符：<code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code>    <h2 id="表达式的值和类型"><a href="#表达式的值和类型" class="headerlink" title="表达式的值和类型"></a>表达式的值和类型</h2>表达式：由操作符和操作数组合而成的式子。如：int a = b+3;<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><blockquote>
<p>使用在字符串中，用来定制字符串输出格式的特殊符号。</p>
</blockquote>
</li>
</ul>
<h3 id="常用的转义字符介绍"><a href="#常用的转义字符介绍" class="headerlink" title="常用的转义字符介绍"></a>常用的转义字符介绍</h3><pre><code>\t                  一个退格键
\n                  换行（linux,unix）
\r                  回车(window中的换行\r\n)
\&apos;                  将&apos;当成一个普通的字符显示出来(&apos;--&gt;特殊含义：字符值)
\&quot;                  将&quot;当成一个普通的字符显示出来（&quot;--&gt;特殊含义：字符串的值）
\u                  unicode码值
\\                  将\当成一个普通的字符显示出来(\--&gt;特殊含义：指定一个字符属于转义字符)
</code></pre><p>案例：使用一个打印语句，将字符串“哥们，最近还好吗？有没有看”刚囧”？’男’主角啥名？”以下述格式输出</p>
<p>哥们，<br>最近还好吗？    有没有看<br>“刚囧”？’男’\主角啥名？`</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><ul>
<li>先乘除，后加减；</li>
<li>若需要提升优先级，添加括号；</li>
<li>.，++，–运算符的优先级很高，赋值运算符的优先级最低的。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/Day12总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/Day12总结/" itemprop="url">java -- day12</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h1><h2 id="集合的概念以及集合框架介绍"><a href="#集合的概念以及集合框架介绍" class="headerlink" title="集合的概念以及集合框架介绍"></a>集合的概念以及集合框架介绍</h2><h3 id="集合的概念"><a href="#集合的概念" class="headerlink" title="集合的概念"></a>集合的概念</h3><blockquote>
<p>存储引用数据对象的变长的容器。</p>
</blockquote>
<p>特点：</p>
<ol>
<li>存储的数据是引用类型；</li>
<li><p>长度可变；</p>
<h3 id="集合的框架结构介绍"><a href="#集合的框架结构介绍" class="headerlink" title="集合的框架结构介绍"></a>集合的框架结构介绍</h3><p>Collection接口</p>
</li>
<li><p>list接口</p>
<ol>
<li>ArrayList类：</li>
<li>LinkedList类</li>
<li>Vector类</li>
<li><p>Strck类:继承Vector，栈结构</p>
<pre><code>常用方法：
 E peek() 查看堆栈顶部的对象，但不从堆栈中移除它。 
 E pop()  移除堆栈顶部的对象，并作为此函数的值返回该对象。 
 E push(E item) 把项压入堆栈顶部。 
 int search(Object o) 返回对象在堆栈中的位置，以 1 为基数。
</code></pre></li>
</ol>
</li>
</ol>
<p>list中特有的方法：</p>
<pre><code>E get(int index) ：根据索引值取出元素
int indexOf(Object o) ：返回一个元素在集合中的索引值
ListIterator&lt;E&gt; listIterator()  ：返回一个列表迭代器对象
E set(int index, E element) ：使用指定的元素替换集合中相应位置的元素
List&lt;E&gt; subList(int fromIndex, int toIndex)：返回指定区间的子集合，子集合中不存在结束索引对应的元素        
</code></pre><ol start="2">
<li>set接口    <ol>
<li>HashSet类</li>
<li>LinkedHashSet</li>
<li>TreeSet<h3 id="集合与数组的对比"><a href="#集合与数组的对比" class="headerlink" title="集合与数组的对比"></a>集合与数组的对比</h3></li>
</ol>
</li>
<li>存储的元素不同：数值存储的是基本数据类型或者引用类型，而集合只能存储引用类型；</li>
<li>长度是否可变；<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><blockquote>
<p>语法：Collection 对象名 = new Collection 接口实现类的构造方法；</p>
</blockquote>
<h3 id="集合对象的创建"><a href="#集合对象的创建" class="headerlink" title="集合对象的创建"></a>集合对象的创建</h3><h3 id="Collection中常用的方法"><a href="#Collection中常用的方法" class="headerlink" title="Collection中常用的方法"></a>Collection中常用的方法</h3></li>
</ol>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><h3 id="泛型应用在集合上"><a href="#泛型应用在集合上" class="headerlink" title="泛型应用在集合上"></a>泛型应用在集合上</h3><h3 id="泛型应用在类上"><a href="#泛型应用在类上" class="headerlink" title="泛型应用在类上"></a>泛型应用在类上</h3><h3 id="泛型应用在方法上"><a href="#泛型应用在方法上" class="headerlink" title="泛型应用在方法上"></a>泛型应用在方法上</h3><p>泛型：泛指的类型，指的是：将类型可以当成参数，在子类和父类，实现类和接口之间进行传递。<br>泛型的本质：类型的传递。</p>
<p>泛型的分类：<br>①泛型接口<br>语法：访问权限修饰符 interface 接口名&lt;类型1,类型2,…,类型n&gt;{<br>      }</p>
<p>注意：1、此处，类型1等等与接口之间不存在实现的关系，关系仅限于：<br>      将明示出来的类型当成一个普通的类型，在整个接口体中可以使用。<br>      2、泛型参数的名字是合法的java标识符<br>      3、至于泛型到底指的是何种具体类型，由调用处来决定，来传入具体的类型。</p>
<p>②泛型类<br>语法：访问权限修饰符 class 类名&lt;类型1,类型2,…,类型n&gt;{<br>      }</p>
<p>注意：1、此处，类型1等等与类之间不存在继承关系，关系仅限于：<br>      将明示出来的类型当成一个普通的类型，在整个类体中都可以使用。<br>      2、泛型参数的名字是合法的java标识符<br>      3、至于泛型到底指的是何种具体类型，由调用处来决定，来传入具体的类型。</p>
<p>③泛型方法</p>
<p>语法：访问权限修饰符 &lt;类型1,类型2,…,类型n&gt; 返回值类型 方法名(..){<br>      }</p>
<p>注意：1、此处，类型1等等与方法的关系是：<br>      将明示出来的类型当成一个普通的类型，在整个方法体中以及方法的声明部分都可以使用。<br>      2、泛型参数的名字是合法的java标识符<br>      3、至于泛型到底指的是何种具体类型，由调用处来决定，来传入具体的类型。</p>
<p>泛型语法设计的目的：<br>  ①最大限度提高代码的复用性。<br>  ②将运行时的异常提前到编译时。</p>
<p>需求：通过一个集合，存储班级学生的分数，求总成绩。</p>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><h3 id="迭代器的工作原理"><a href="#迭代器的工作原理" class="headerlink" title="迭代器的工作原理"></a>迭代器的工作原理</h3><h3 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h3><p>作用：遍历集合；</p>
<p>集合中有一个方法的返回值是Iterator，赋值给Iterator对象，然后用Iterator的方法来处理集合；</p>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="List接口的存储特点"><a href="#List接口的存储特点" class="headerlink" title="List接口的存储特点"></a>List接口的存储特点</h3><ol>
<li>可重复；</li>
<li>有序；<h3 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h3></li>
<li>ArrayList：底层的数据结构是数值，查询和修改元素的效率高，增删元素的效率低。    </li>
<li>LinkedList：底层的数据结构是“双向链表”（可以从链表的两头对数据进行处理，里面的每个节点不仅保存了数据也保存的该节点前后对象的地址），查询、修改的效率低，增删的效率高；</li>
<li>ArrayList与LinkedList存储的比较    </li>
</ol>
<p>特有的方法：</p>
<ol>
<li>void addFirst(E e) ：将参数指定的元素添加到集合的开始位置</li>
<li>void addLast(E e) ：将参数指定的元素添加到集合的最后的位置</li>
<li>Iterator<e> descendingIterator()：将集合中的元素反转存入迭代器</e></li>
<li>E getFirst() ：取出集合中第一个元素           </li>
<li>E getLast() ：取出集合中最后一个元素  </li>
<li>E pop()：取出集合中的元素（栈顶）<br>void push(E e) ：将参数指定的元素入栈<h2 id="Set集合的存储特点"><a href="#Set集合的存储特点" class="headerlink" title="Set集合的存储特点"></a>Set集合的存储特点</h2></li>
<li>不能重复</li>
<li>无序<h3 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h3></li>
<li>底层数据结构是哈希表</li>
<li>无序（存储的顺序和输入顺序无关，但是在数据存储的时候按照底层算法实现）    <h4 id="重写equals"><a href="#重写equals" class="headerlink" title="重写equals()"></a>重写equals()</h4><h4 id="重写equals-1"><a href="#重写equals-1" class="headerlink" title="重写equals()"></a>重写equals()</h4><h3 id="TreeSet的实现原理"><a href="#TreeSet的实现原理" class="headerlink" title="TreeSet的实现原理"></a>TreeSet的实现原理</h3><h4 id="Comparable接口的使用"><a href="#Comparable接口的使用" class="headerlink" title="Comparable接口的使用"></a>Comparable接口的使用</h4><h4 id="Comparator接口的使用"><a href="#Comparator接口的使用" class="headerlink" title="Comparator接口的使用"></a>Comparator接口的使用</h4><h3 id="LinkedHashSet-继承hashSet，没有特别的方法"><a href="#LinkedHashSet-继承hashSet，没有特别的方法" class="headerlink" title="LinkedHashSet 继承hashSet，没有特别的方法"></a>LinkedHashSet 继承hashSet，没有特别的方法</h3></li>
<li>底层是链表</li>
<li>有序：元素的顺序和添加顺序一样</li>
</ol>
<p><strong>遍历List集</strong>合时，可以使用四种：</p>
<ol>
<li>迭代器</li>
<li>增强for —》只能取出集合中的元素，不能修改。</li>
<li>普通for —&gt;可以取出集合中的元素，同时还可以修改</li>
<li>转换为数组</li>
</ol>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet实现类的特点：<br>①排序的 （集合中的元素根据指定的顺序进行升序排列后，存入集合）<br>②无序的 （元素添加的顺序与底层存储的顺序不一致，特例：添加时是排好序的）<br>③底层存储元素时采用的数据结构是二叉树</p>
<p>深度挖掘TreeSet集合：<br>存储在该种集合中的元素为什么能够排序呢？<br>就对象本质而言，不具备可比性。但是，程序是用来描述现实世界，需求要求对象<br>能进行比较。所以，必须人为给定一个比较规则。</p>
<p>如何给定规则：<br>方式①：让需要进行比较的实例所对应的类实现Comparable接口，实现其中的copareTo（）方法，在该方法中指定比较规则。（让实例具备可比性）<br>    compareToz（xxx）方法，有三个返回值：0  –》当前对象与参数指定的对象相等<br>                                        &gt;0 –&gt; 当前对象大于参数指定的对象<br>                                        &lt;0 –》当前对象小于参数指定的对象</p>
<p>方式②：构建TreeSet集合对象时，传入一个比较器对象，让容器具备可比性。<br>   比较器： 设计一个类，让该类实现Comparator接口,实现接口中的compare方法，在该方法中定制比较规则。</p>
<p>需求：定义一个TreeSet的集合，存储班级学生的信息，根据学生的年龄来排序，若年龄相同，根据身高来排序，若身高相同，根据体重来排序，若<br>      体重也相同，根据名字来排序。</p>
<p>思路：①设计一个Student实例类<br>      ②测试类，main–》构建容器对象，存储学生实例，遍历，观察结果</p>
<p>注意：<br>1、TreeSet集合中的元素要进行比较，有两种实现方式，在真实项目中选择其一即可，不要“双管齐下”。<br>   效果：对象的比较会优先选择Comparable方式；那么，Comparator方式就成了冗余的代码。</p>
<p>2、向一个TreeSet集合中的存入元素，元素一般要具备可比性，否则抛出ClassCastException。除非：是让容器具备可比性（Comprator方式）。</p>
<p>–》拓展：一般TreeSet中存放的是同一个类的对象，让同类对象之间进行比较，然后排序。但是，现实需求是变动的，让不同种类的对象进行比较，<br>         现实中也有很多。如何实现呢？<br>需求：让人、老虎、狮子赛跑，看那个物种速度快，速度升序，若速度一样，根据体重来比较，体重降序。</p>
<p>分析：<br>1）设计三个实体类：人，老虎，狮子，且类要实现Comparable接口。<br>2）测试类 main：构建不同物种的对象，存入集合，打印，观察结果。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/Day11总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/Day11总结/" itemprop="url">java -- day11</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h1><h2 id="基本数据类型的包装类"><a href="#基本数据类型的包装类" class="headerlink" title="基本数据类型的包装类"></a>基本数据类型的包装类</h2><blockquote>
<p>char – Charactor<br>int – integer</p>
</blockquote>
<h3 id="基本数据类型与其包装类"><a href="#基本数据类型与其包装类" class="headerlink" title="基本数据类型与其包装类"></a>基本数据类型与其包装类</h3><h3 id="数据的装箱和拆箱"><a href="#数据的装箱和拆箱" class="headerlink" title="数据的装箱和拆箱"></a>数据的装箱和拆箱</h3><p>在Jdk1.5以后java加入了自动装箱和拆箱功能；    </p>
<p>装箱:将基本数据类型封装为对应的包装类型对象的过程。</p>
<pre><code>语法：①若jdk的版本&gt;= 1.5,会自动装箱
  包装类型 对象 = 基本数据类型的数据（变量或者是值）;  
如：int age = 12;
Integer ageObj = age;

 ②若jdk的版本&lt;1.5,必须手动装箱
   包装类型 对象 = new  包装类型(基本数据类型（变量或者值）); 
如：int age = 3;
Integer ageObj = new Integer(age);
</code></pre><p>拆箱:将包装类型的对象转换为对应的基本数据类型的过程。</p>
<pre><code>语法：①若jdk的版本&gt;= 1.5,会自动拆箱
  基本数据类型 变量 = 包装类型的对象;
如：Integer ageObj = new Integer(&quot;88&quot;);
int age = ageObj;

 ②若jdk的版本&lt;1.5,必须手动装箱
  基本数据类型 变量 = 包装类型的对象.方法（实参）;
如：Integer ageObj = new Integer(&quot;88&quot;);
int age = ageObj.intValue();
</code></pre><p>基本数据类型：byte,short,int ,long ,char,float,double –&gt;兼容关系</p>
<p>对应的包装类型：Byte，Integer –&gt;不兼容，不存在继承关系，有一点点关系：都是Number的子类型。</p>
<p><strong>Arrays工具类</strong>：负责对数组进行排序、查询、填充等等操作。（主要是用来操作一维数组）</p>
<p>常用方法：</p>
<ol>
<li>static int binarySearch(int[] a, int key)  使用二分法从一个排好序的数组中查询指定的元素，若存在，返回索引值；否则，返回负数。</li>
<li>static int[] copyOf(int[] original, int newLength)：是创建一个当前数组的备份(全新的数组)，且指定了长度（从旧数组中复制元素的个数） ，若长度&gt;旧数组的长度，不足的部分使用默认值填充。</li>
<li>static int[] copyOfRange(int[] original, int from, int to)  ：同copyOf（xxx）,指定了索引范围，但是拷贝后的数组中不包含结束索引对应的元素。</li>
<li>static boolean equals(int[] a, int[] a2) ：比较两个数组的元素值是否完全相同，与元素的位置有关系。</li>
<li>static void fill(int[] a, int val) ：使用指定值对数组中的每一个元素进行初始化（或者是覆盖）。<br>6 .static void sort(int[] a) ：对应数组中的元素进行升序排列。</li>
<li>static String toString(int[] a)：以指定的格式将数组遍历输出。<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3>常用方法：</li>
</ol>
<p>构造方法：</p>
<ol>
<li>String(byte[] bytes)：将参数指定的字节数组转换为String 的对象。</li>
<li>String(byte[] bytes, Charset charset) 将指定了字符集的字节数组转换为String 的对象。</li>
</ol>
<p>普通方法：</p>
<ol>
<li>char charAt(int index) –》取出字符串中对应索引的字符 index从0开始</li>
<li>int compareTo(String anotherString)–》比较两个字符串的大小（根据字典顺序）</li>
<li>String concat(String str)–&gt;拼接两个字符串为一个新的字符串，等价于连接符“+”</li>
<li>boolean contains(CharSequence s)–》判断字符串对象中是否包含参数所指定的字符串</li>
<li>boolean endsWith(String suffix) –&gt;判断字符串是否以指定的后缀结束</li>
<li>boolean equals(Object anObject) –》比较两个字符串对象的内容是否完全相同</li>
<li>static String format(String format,Object… args) –》使用指定的格式格式变长参数值。</li>
<li>byte[] getBytes() –&gt;将一个字符串转换为字节数组</li>
<li>byte[] getBytes(Charset charset) –》将一个使用参数指定的字符集编号码的字符串转换为字节数组。</li>
<li>indexOf(int ch)–》从当前字符串中查找参数指定的字符，找到一个与之匹配的返回该字符在字符串中对应的索引值<br>11.int indexOf(int ch, int fromIndex)  –》从当前字符串中指定索引处往后查找参数指定的字符，找到一个与之匹配的返回该字符在字符串中对应的索引值</li>
<li>int indexOf(String str) –》从当前字符串中查找参数指定的字符串，找到一个与之匹配的返回该字符串第一个字符在字符串中对应的索引值 </li>
<li>boolean isEmpty()：判断字符串是否为空，就是其中不包含元素 ，与null是不等价。null-&gt;一个对象在堆中尚未开辟存储空间</li>
<li>int lastIndexOf(int ch)： 从当前字符串中从后往前查找参数指定的字符，找到一个与之匹配的返回该字符在字符串中对应的索引值 （索引：永远是从前往后计数）</li>
<li>int length() ：返回字符串中所包含的字符个数（无论是半角还是全角都占用一个字符）</li>
<li>***boolean matches(String regex) ：用户判定当前字符串对象其格式是否与参数所指定的正则表达式相吻合</li>
<li>String replace(char oldChar, char newChar) ：使用新的字符替换字符串中旧的字符</li>
<li>String replace(CharSequence target, CharSequence replacement) ：使用新的字符序列替换字符串中旧的字符序列</li>
<li>String[] split(String regex) ：使用参数指定的正则表达式将字符串分割为一个字符串数组。（分割后的数组中元素不包含分隔符）</li>
<li>boolean startsWith(String prefix)：判断字符串对象是否以参数指定的前缀开始</li>
<li>String substring(int beginIndex) ：返回一个从参数指定的索引开始一直到结束的子串</li>
<li>String substring(int beginIndex, int endIndex) ：返回一个从参数指定的索引开始，指定的索引结束的子串，子串中不包含结束索引对应的字符</li>
<li>char[] toCharArray()：将一个字符串转换为字符数组</li>
<li>String toLowerCase()  ：将大写字符串转换为小写。（针对半角的英文字符有效）</li>
<li>String toUpperCase() ：将小写字符串转换为大写。（针对半角的英文字符有效）</li>
<li>String trim() :去掉字符串前后的半角空格。</li>
<li>static String valueOf(int i) ：将参数指定的int型的数据封装成字符串对象。<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3>常用方法：</li>
</ol>
<p>构造方法：</p>
<ol>
<li>StringBuffer() </li>
<li>StringBuffer(String str)</li>
</ol>
<p>普通方法：</p>
<ol>
<li>StringBuffer append(int i) ：将参数指定的int型的数据追加到字符串构建器的末尾。</li>
<li>int capacity() ：返回字符串构建器的容量</li>
<li>StringBuffer delete(int start, int end)：从字符串构建器中删除指定区间的字符序列。结束索引对应的字符不删除。</li>
<li>StringBuffer deleteCharAt(int index) ：将指定索引处的字符从 字符串构建器中删除</li>
<li>StringBuffer insert(int offset, int i) ：将参数指定的数值i插入指定的索引offset处，之后的元素自动后移。</li>
<li>int length() ：字符串构建器中字符的个数</li>
<li>StringBuffer replace(int start, int end, String str) ：使用指定的字符串替换指定区间的字符串。</li>
<li>StringBuffer reverse() ：将字符串中的字符反转。</li>
<li>void setCharAt(int index, char ch) ：使用指定的字符替换相应索引处的字符。</li>
</ol>
<p><strong>StringBuffer与String的异同点：</strong></p>
<p>同：都是用来操作字符串的。</p>
<p>异：</p>
<ol>
<li>从生成对象个数的角度考虑，在拼接多个字符串为一个新的字符串的时候，String每拼接一个字符串，会生成一个全新的String字符串对象（堆，字符串串池）；StringBuffer每次追加一个数据时，操作的是同一块堆内存空间，只会生成一个对象。</li>
<li>从效率来看，在拼接多个字符串时，StringBuffer的速度远远高于String.</li>
<li>从消耗内存的角度看，在拼接多个字符串时，StringBuffer占用的内存要远远小于String.<h3 id="StringBuilder类-与-StringBuffer基本一样"><a href="#StringBuilder类-与-StringBuffer基本一样" class="headerlink" title="StringBuilder类 与 StringBuffer基本一样"></a>StringBuilder类 与 StringBuffer基本一样</h3><strong>StringBuffer与StringBuilder异同点说明：</strong></li>
</ol>
<p>同：都是字符串构建器，都是用来操作字符串的。</p>
<p>异：StringBuffer 线程安全的。（说明：在多线程并发访问该类相应方法时，同一时刻，只有一个线程能访问，该线程执行完后，别的线程才有可能执行该方法。）StringBuilder 线程不安全的。（说明：在多线程并发访问该类相应方法时，同一时刻，多个线程都有机会执行该方法，会造成临界资源访问的冲突）</p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>  max(x)</p>
<p>  min（）</p>
<p>  abs()</p>
<p>  sqrt()</p>
<p>  pow()</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><blockquote>
<p>静态导入:为了方便使用工具类中的工具方法，导入时，将该方法直接引入，类体中只需要书写方法名即可。</p>
<p>语法：import 类的全限定名.工具方法名；</p>
<p>使用：在类体中直接–&gt; 方法名(实参)</p>
</blockquote>
<h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><blockquote>
<p>Random：随机数生成器类，其中的方法nextInt(1)与Math类中的 random()工具方法作用一样。</p>
</blockquote>
<p>常用方法：</p>
<p>构造方法：</p>
<ol>
<li>Random(long seed)  –》使用的不多，注意：使用同一个种子生成的Random类对象，生成的随机数也相同。</li>
<li>Random() </li>
</ol>
<p>普通方法：</p>
<ol>
<li>int nextInt()  –》随机产生一个int取值范围之内的数</li>
<li>int nextInt(int n) –》等价于Math.random()*n,取值范围是[0,n)，不同之处在于：返回值类型不同，Math.random()返回double<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><blockquote>
<p>封装了一些与当前os进行信息交互的工具方法。</p>
</blockquote>
</li>
</ol>
<p>常用的属性：</p>
<ol>
<li>System.in –&gt;InputStream,“标准”输入流。</li>
<li>System.out –&gt;PrintStream, “标准”输出流。</li>
<li>System.out.println(“xx”);</li>
</ol>
<p>常用的方法：</p>
<ol>
<li>static long currentTimeMillis() –》以毫秒值返回的系统当前时间</li>
<li>static long nanoTime()  –》以纳秒值返回的系统当前时间</li>
<li>static void exit(int status)  –》无条件终止jvm的执行</li>
<li>static void gc() –》调用该方法，给垃圾回收器一个暗示，至于垃圾回收器是否会立即执行，完全取决于其底层的算法。</li>
<li>static String getenv(String name)  –》根据参数指定的环境变量名获得其对应的环境变量值。<h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><blockquote>
<p>对时间的抽取和封装，类 Date 表示特定的瞬间，精确到毫秒。</p>
</blockquote>
</li>
</ol>
<p>常用方法：</p>
<p>构造方法：</p>
<ol>
<li>Date() ：表示系统当前时间。</li>
</ol>
<p>普通方法：</p>
<ol>
<li>boolean after(Date when)  测试此日期是否在指定日期之后。 </li>
<li>boolean before(Date when) 测试此日期是否在指定日期之前。  </li>
<li>int compareTo(Date anotherDate) 比较两个日期的顺序。 </li>
<li>boolean equals(Object obj) 比较两个日期的相等性。<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2></li>
<li>Calendar类：Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。<br><strong>Calendar类中封装了一些操作日历的方法。</strong></li>
</ol>
<p>常用方法：</p>
<ol>
<li>int get(int field)  –》根据参数指定的日历字段，获得值。</li>
<li>static Calendar getInstance() –》返回Calendar类对象。</li>
<li>void set(int field, int value)–》设置日历实例某个属性的值。</li>
<li>void set(int year, int month, int date)—》定制当前日历对象中封装的具体时间  <h2 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h2><blockquote>
<p>使用来将一个Date型的对象格式化输出，或者是将一个日&gt;期格式的字符串封装成一个Date型的实例。    </p>
</blockquote>
</li>
</ol>
<p>SimpleDateFormat类常用的方法：</p>
<ol>
<li>Date parse(String source) 从给定字符串的开始解析文本，以生成一个日期。</li>
<li>String format(Date date) 将一个 Date 格式化为日期/时间字符串。  </li>
</ol>
<p><strong>过时：</strong>某个类中的方法或者是属性不推荐使用了，目前有更好的替代方案。<br>如何达到让方法过时的目的？<br>语法：在方法之前添加注解：<code>@Deprecated</code></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>是一个特殊的字符串，用于验证别的字符串格式的合法性。</p>
</blockquote>
<p>分类：</p>
<ol>
<li>字符类：[abc] a、b 或 c（简单类） –》当前字符串中的内部是a是b或者是c，是就匹配；否则，不匹配。</li>
<li><p>预定义字符类</p>
<p> . –&gt;任何字符任何字符</p>
<p> \d 数字：[0-9] </p>
<p> \D 非数字： [^0-9] </p>
<p> \s 空白字符：[ \t\n\x0B\f\r] </p>
<p> \S 非空白字符：[^\s] </p>
<p> \w 单词字符：[a-zA-Z_0-9] </p>
<p> \W 非单词字符：[^\w] </p>
</li>
<li><p>边界匹配器 </p>
<p> ^ 行的开头 </p>
<p> $ 行的结尾 </p>
</li>
<li><p>Greedy 数量词</p>
<p> +：一个或者多个</p>
<p> ?：一次或0次</p>
<p> *：0次或多次</p>
<p> {n}:出现的次数恰好是n次</p>
<p> {n,}:出现的次数至少是n次</p>
<p> {n,m}:出现的次数至少是n次,最多是m次</p>
</li>
</ol>
<h3 id="枚举的简单使用"><a href="#枚举的简单使用" class="headerlink" title="枚举的简单使用"></a>枚举的简单使用</h3><p>枚举：也是引用类型，用法与类类似。有七种用法。</p>
<p>在实际项目中使用最多是：<strong>枚举常量</strong>。</p>
<p>语法：访问权限修饰符 enum 枚举名{ 枚举常量1,枚举常量2,枚举常量3,…,枚举常量n</p>
<p>访问方式：枚举名.枚举常量</p>
<p>需求：定义一个封装了各个季节的枚举类，再测试（某人根据不同的季节进行相应的活动）</p>
<p>使用枚举的本质原因：提高代码的可读性。</p>
<p>使用时注意：switch分支语句的case分支后，是枚举常量值，直接书写即可。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/Day8总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/Day8总结/" itemprop="url">java -- day8</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><blockquote>
<p>父类或者接口的引用指向子类或者实现类的对象</p>
</blockquote>
<h3 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h3><h3 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h3><h2 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h2><p>实例 instanceof 类或者是接口<br>若是类:表示实例是否是属于类的对象<br>若是接口:表示实例是否是实现类的对象    </p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类概念"><a href="#内部类概念" class="headerlink" title="内部类概念"></a>内部类概念</h3><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h2 id="设计模式-23种"><a href="#设计模式-23种" class="headerlink" title="设计模式 23种"></a>设计模式 23种</h2><blockquote>
<p>总结出来用于解决一类问题最为有效的变成方法</p>
<p>框架:做项目总结的经验:javaee:ssh, spring strus, hibernate.在作项目的时候把共通的代码抽取出来做成一个模板.</p>
<p>框架与设计模式的关系:框架底层使用了多种设计模式,使用框架来做项目,就潜移默化的使用了很多设计模式.</p>
</blockquote>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><blockquote>
<p>让一个类只能有一个实例对象.</p>
</blockquote>
<p>饿汉式:</p>
<ol>
<li>设计一个本类类型的静态私有属性</li>
<li>无参的构造方法私有化</li>
<li>对外暴露一个获取本类对象的方法.</li>
</ol>
<p>懒汉式：</p>
<p>①设计一个本类类型的静态私有属性</p>
<p>②无参的构造方法要私有化</p>
<p>③对外暴露一个获取本类对象的静态方法<br>  判断属性值是否为null，不为null，就new<br>  否则，就直接返回(这里的代码注意简化if没有else)</p>
<h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><blockquote>
<p>构建一个对象的时候,不是手动new一个对象,而是通过一个实例工厂中工具方法获得的.</p>
</blockquote>
<p>自己总结的特点:<br>工厂类相当于是工具类,类中的方法定义成静态方法,用类.方法(实参列表)直接调用,方法的作用是构造对象.</p>
<p>例子:花店作为工厂构建是对花对象,花是独立类</p>
<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><p>设计一个个方法时,将固定部分的设计成为一个模板,将动态的部分酬取出来,封装成一个抽象的方法,然后具体的子类去重写抽象父类的方法.</p>
<p>自己的总结:</p>
<p>模板类是一个抽象类,其中的抽象方法是变化的代码由子类来实现( <code>System.currentTimeMillis()</code> ).有一个final方法来调用抽象方法(当子类使用这个方法时即是调用变化的代码)———-所以一个模板类中一般至少有两个方法,一个会不变的方法(final)一个是抽象方法.</p>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="接口回调"><a href="#接口回调" class="headerlink" title="接口回调"></a>接口回调</h2><h3 id="接口回调的原理"><a href="#接口回调的原理" class="headerlink" title="接口回调的原理"></a>接口回调的原理</h3><h3 id="接口回调的简单使用"><a href="#接口回调的简单使用" class="headerlink" title="接口回调的简单使用"></a>接口回调的简单使用</h3><h2 id="内部类的应用场景"><a href="#内部类的应用场景" class="headerlink" title="内部类的应用场景"></a>内部类的应用场景</h2><h3 id="实例内部类应用场景——Button按钮事件监听器"><a href="#实例内部类应用场景——Button按钮事件监听器" class="headerlink" title="实例内部类应用场景——Button按钮事件监听器"></a>实例内部类应用场景——Button按钮事件监听器</h3><p>–&gt;成员内部类：与外部类的成员属性和成员方法平级的类。</p>
<p>语法：访问权限修饰符 class 外部类类名{<br>            //外部类的属性和方法</p>
<pre><code>      //成员内部类
      访问权限修饰符 class 内部类类名{
         //属性和方法
      }      
}
</code></pre><p>特点:</p>
<ol>
<li>与外类的属性和方法平级;</li>
<li>外部类的属性和方法属于对象,所以与之类似的,成员内部类属于外部类对象.–&gt;成员内部类的构建方式:外部类.内部类 实例名 = 外部类对象.new 内部类的构造器</li>
<li><p>如何在成员内部类方法中访问同名的变量（外部类的属性、内部类的属性，内部类方法中的局部变量）</p>
<p> 外部类的属性–》  访问方式：外部类类名.this.属性</p>
<p>  内部类的属性–》  访问方式：this.属性</p>
<p>   内部类方法中的局部变量–》访问方式：局部变量名</p>
</li>
<li><p>成员内部类可以使 private,default,protected,public等等访问权限修饰符来修饰。</p>
</li>
<li><p>包含了成员内部类的源码，编译时会生成的字节码文件的个数与class的个数相同</p>
<p>  注意：成员内部类生成的字节码文件的名字:外部类    类名$内部类类名.class    如：Outer2$Inner.class   </p>
</li>
</ol>
<p>自己的总结:<br>对老师代码的分析:定义了一个接口,接口中抽象类为clickApp. 在测试类中定义成员内部类,这些类实现接口并且重写了抽象方法,在外部类的方法中可以通过<code>new 内部类名()</code> 或者<code>this.new 内部类名()</code>来直接创建内部类对象 </p>
<p>–&gt;成员内部类在真实android项目中的适用场景：</p>
<p>实例内部类应用场景——Button按钮事件监听器<br>需求：用户在手机上安装了不同的应用（qq，支付宝），点击app启动使用的情形。</p>
<p>分析：</p>
<p>1、设计一个监听器接口，用来监听用户点击某个应用的事件</p>
<p>2、在测试类中，准备几个成员内部类（对应的app类）</p>
<p>3、main方法：xxx</p>
<pre><code>-------------------------------------  
</code></pre><h3 id="匿名内部类应用场景——Button按钮事件监听器"><a href="#匿名内部类应用场景——Button按钮事件监听器" class="headerlink" title="匿名内部类应用场景——Button按钮事件监听器"></a>匿名内部类应用场景——Button按钮事件监听器</h3><p>—》匿名内部类：书写在外部类中，与外部类的属性或方法平级的没有名字的内部类；<br>                 或者是：书写在外部类的方法体中，与方法中局部变量平级的没有名字的内部类。<br>分成：<br>①成员匿名内部类<br>语法：访问权限修饰符 class 外部类类名{<br>            //外部类的属性和方法</p>
<pre><code>  //接口类型的属性
      接口 引用 = new 接口(){
           //匿名内部类的类体
      };     
}
</code></pre><p>②局部匿名内部类</p>
<p>语法：访问权限修饰符 class 外部类类名{<br>            //外部类的属性和方法</p>
<pre><code>  访问权限修饰符 返回值类型 方法名（形参列表）{            

      //接口类型的局部变量（使用匿名内部类进行初始化）
          接口 引用 = new 接口(){
                //匿名内部类的类体    
           };   
      }  
}
</code></pre><p>匿名内部类的特点：</p>
<p>1、匿名内部类类体中，可以书写任意的属性和方法，但是：建议只书写实现接口中的方法，<br>  书写别的方法和属性通过多态的方式是调用不了的，就成为了“垃圾代码”。除非：匿名<br>  内部类中的属性和方法供实现了接口中的方法来调用。</p>
<p>2、匿名内部类只能使用一次。（类比：现实中的一次性筷子）</p>
<p>3、包含了匿名内部类的外部类，编译后，生成的字节码文件的个数 = class的个数 + 匿名内部类的个数<br>  匿名内部类编译后的字节码文件名：外部类类名$编号.class ( 编号从1开始) 如：Outer$1.class</p>
<p>4、局部匿名内部类访问与之平级的局部变量，那么该局部变量必须声明为final。</p>
<p>匿名内部类拓展： 匿名内部类中的接口，从语法的角度而言，也可以是普通类和抽象类。</p>
<p>–》匿名内部类的适用场景：<br>匿名内部类应用场景——Button按钮事件监听器</p>
<p>实现方式：</p>
<p>①匿名成员内部类来实现<br>②匿名局部内部类来实现</p>
<h3 id="局部内部类应用场景——Button按钮事件监听器"><a href="#局部内部类应用场景——Button按钮事件监听器" class="headerlink" title="局部内部类应用场景——Button按钮事件监听器"></a>局部内部类应用场景——Button按钮事件监听器</h3><p>–&gt;局部内部类：与外部类中成员方法中的局部变量平级的内部类。<br>语法：访问权限修饰符 class 外部类类名{<br>            //外部类的属性</p>
<pre><code>      访问权限修饰符 返回值类型 方法名（形式参数列表）{
          //局部变量

          //局部内部类
          class 内部类类名{
             //属性和方法
          } 
  }         
}
</code></pre><p>特点：<br>1、与外部类方法体中的局部变量同一个级别，且使用方式类似。<br>2、局部变量只能使用final来修饰，不能使用可见性修饰符来修饰，据此，推理出：<br>   局部内部类也是如此。<br>3、局部内部类访问与之平级的局部变量，该局部变量必须是局部常量<br>4、如何构建局部内部类的对象<br>   与局部变量类似，局部变量的使用范围仅限于其所在的方法体或者代码块<br>    同理，局部内部类只能在其所在的方法体中构建对象。<br>   –》如何调用局部内部类中的方法<br>   <strong>不能直接调用</strong>，只能间接调用（调用局部内部类所在的方法,这个方法中实现了类的实例化和类使用类中的方法）<br>5、包含了局部内部类的外部类，编译时，有几个class就会生成几个字节码文件<br>   注意：局部内部类的字节码文件名是：外部类类名.序号+内部类类名.class 如：Outer.1Inner.class</p>
<p>–&gt;应用场景：10.6.3局部内部类应用场景——Button按钮事件监听器<br>需求：用户在手机上安装了不同的应用（qq，支付宝），点击app启动使用的情形。<br>分析：<br>1、设计一个监听器接口，用来监听用户点击某个应用的事件<br>2、在测试类中，准备几个方法，每个方法表示用户安装、启动并使用app应用<br>3、main方法：xxx</p>
<h3 id="静态内部类应用场景——Builder构建器"><a href="#静态内部类应用场景——Builder构建器" class="headerlink" title="静态内部类应用场景——Builder构建器"></a>静态内部类应用场景——Builder构建器</h3><p>—》静态内部类：与外部类的静态属性和静态方法平级的内部类。</p>
<p>语法：访问权限修饰符 class 外部类类名{<br>            //外部类的属性和方法</p>
<pre><code>      //外部类的静态属性和静态方法

      //静态内部类
      访问权限修饰符 static class 内部类类名{
         //属性和方法
      }      
}
</code></pre><p>特点：</p>
<ol>
<li>静态内部类与静态属性和静态方法使用方式类似</li>
<li>如何构建静态内部类对象<br>因为静态内部类与外部类中的静态属性和静态方法平级，使用方式也类似，据此<br>外部类调用外部类中的静态方法：外部类类名.静态方法（实参）<br>–&gt;推导：外部类类名.静态内部类类名 实例名 = new 外部类.内部类构造方法；</li>
<li>静态内部类中的普通方法和静态方法只能访问外部类中的静态属性和静态方法，不能访问<br>外部类的普通属性和普通方法。(特别指出：内部类中静态方法可以访问外部类的构造方法，不能访问普通方法)</li>
<li>如何调用静态内部类中的静态方法呢？<br>语法：外部类.静态内部类.静态方法(实际参数列表);    (<strong>静态内部类中能不能有普通方法</strong>)</li>
<li>包含了静态内部类的外部类，编译时，字节码文件的个数与class相同，静态内部类编译后<br>的字节码文件名格式为：外部类$静态内部类类名.class</li>
</ol>
<p>—》静态内部类的适用场景：</p>
<p>1）静态内部类应用场景——Builder构建器      <strong> 链式编程??</strong></p>
<p>分析：<br>设计一个包含了静态内部类的外部类，静态内部类中有一个构建外部类对象的静态方法，<br>      外部类中的setter访问器设计返回值类型为外部类本身。（Builder构建器：本质：通过<br>      静态内部类构建外部类对象）</p>
<p>注意：api中，使用了builder构建器，如：字符串构建器类StringBuffer,StringBuilder</p>
<p>2）静态内部类应用场景——Button按钮事件监听器<br>需求：用户在手机上安装了不同的应用（qq，支付宝），点击app启动使用的情形。<br><strong>为什么接口的引用指向实现接口的类时,接口引用不用向下转型就能直接使用实现类的方法;;;;;;;;;继承关系的类是否可以(是否抽象??还是和是否重写有关????)</strong><br>分析：<br>1、设计一个监听器接口，用来监听用户点击某个应用的事件<br>2、在测试类中，准备几个静态内部类，让每个静态内部类实现监听器接口<br>3、main方法：xxx    </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/File操作大全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/File操作大全/" itemprop="url">File操作大全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<pre><code> //1.创建文件夹 
//import java.io.*; 
File myFolderPath = new File(str1); 
try { 
    if (!myFolderPath.exists()) { 
       myFolderPath.mkdir(); 
    } 
} 
catch (Exception e) { 
    System.out.println(&quot;新建目录操作出错&quot;); 
    e.printStackTrace(); 
}  

//2.创建文件 
//import java.io.*; 
File myFilePath = new File(str1); 
try { 
    if (!myFilePath.exists()) { 
        myFilePath.createNewFile(); 
    } 
    FileWriter resultFile = new FileWriter(myFilePath); 
    PrintWriter myFile = new PrintWriter(resultFile); 
    myFile.println(str2); 
    resultFile.close(); 
} 
catch (Exception e) { 
    System.out.println(&quot;新建文件操作出错&quot;); 
    e.printStackTrace(); 
}  

//3.删除文件 
//import java.io.*; 
File myDelFile = new File(str1); 
try { 
    myDelFile.delete(); 
} 
catch (Exception e) { 
    System.out.println(&quot;删除文件操作出错&quot;); 
    e.printStackTrace(); 
}  

//4.删除文件夹 
//import java.io.*; 
File delFolderPath = new File(str1); 
try { 
    delFolderPath.delete(); //删除空文件夹 
} 
catch (Exception e) { 
    System.out.println(&quot;删除文件夹操作出错&quot;); 
    e.printStackTrace(); 
}  

//5.删除一个文件下夹所有的文件夹 
//import java.io.*; 
File delfile=new File(str1); 
File[] files=delfile.listFiles(); 
for(int i=0;i&lt;files.length;i++){ 
    if(files[i].isDirectory()){ 
        files[i].delete(); 
    } 
}   

//6.清空文件夹 
//import java.io.*; 
File delfilefolder=new File(str1); 
try { 
    if (!delfilefolder.exists()) { 
        delfilefolder.delete(); 
    } 
    delfilefolder.mkdir(); 
} 
catch (Exception e) { 
    System.out.println(&quot;清空目录操作出错&quot;); 
    e.printStackTrace(); 
}  

//7.读取文件 
//import java.io.*; 
// 逐行读取数据 
FileReader fr = new FileReader(str1); 
BufferedReader br = new BufferedReader(fr); 
String str2 = br.readLine(); 
while (str2 != null) { 
    str3 
    str2 = br.readLine(); 
} 
br.close(); 
fr.close();  

//8.写入文件 
//import java.io.*; 
// 将数据写入文件 
try { 
    FileWriter fw = new FileWriter(str1); 
    fw.write(str2); 
    fw.flush(); 
    fw.close();  
} catch (IOException e) { 
    e.printStackTrace(); 
} 

//9.写入随机文件 
//import java.io.*; 
try { 
    RandomAcessFile logFile=new RandomAcessFile(str1,&quot;rw&quot;); 
    long lg=logFile.length(); 
    logFile.seek(str2); 
    logFile.writeByte(str3); 
}catch(IOException ioe){ 
    System.out.println(&quot;无法写入文件：&quot;+ioe.getMessage()); 
}  

//10.读取文件属性 
//import java.io.*; 
// 文件属性的取得 
File f = new File(str1); 
if (af.exists()) { 
    System.out.println(f.getName() + &quot;的属性如下： 文件长度为：&quot; + f.length()); 
    System.out.println(f.isFile() ? &quot;是文件&quot; : &quot;不是文件&quot;); 
    System.out.println(f.isDirectory() ? &quot;是目录&quot; : &quot;不是目录&quot;); 
    System.out.println(f.canRead() ? &quot;可读取&quot; : &quot;不&quot;); 
    System.out.println(f.canWrite() ? &quot;是隐藏文件&quot; : &quot;&quot;); 
    System.out.println(&quot;文件夹的最后修改日期为：&quot; + new Date(f.lastModified())); 
    } else { 
    System.out.println(f.getName() + &quot;的属性如下：&quot;); 
    System.out.println(f.isFile() ? &quot;是文件&quot; : &quot;不是文件&quot;); 
    System.out.println(f.isDirectory() ? &quot;是目录&quot; : &quot;不是目录&quot;); 
    System.out.println(f.canRead() ? &quot;可读取&quot; : &quot;不&quot;); 
    System.out.println(f.canWrite() ? &quot;是隐藏文件&quot; : &quot;&quot;); 
    System.out.println(&quot;文件的最后修改日期为：&quot; + new Date(f.lastModified())); 
} 
if(f.canRead()){ 
    str2 
} 
if(f.canWrite()){ 
    str3 
} 

//11.写入属性 
//import java.io.*; 
File filereadonly=new File(str1); 
try { 
    boolean b=filereadonly.setReadOnly(); 
} 
catch (Exception e) { 
    System.out.println(&quot;拒绝写访问：&quot;+e.printStackTrace()); 
}  

//12.枚举一个文件夹中的所有文件 
//import java.io.*; 
//import java.util.*; 
LinkedList&lt;String&gt; folderList = new LinkedList&lt;String&gt;(); 
folderList.add(str1); 
while (folderList.size() &gt; 0) { 
    File file = new File(folderList.peek()); 
    folderList.removeLast(); 
    File[] files = file.listFiles(); 
    ArrayList&lt;File&gt; fileList = new ArrayList&lt;File&gt;(); 
    for (int i = 0; i &lt; files.length; i++) { 
        if (files[i].isDirectory()) { 
            folderList.add(files[i].getPath()); 
        } else { 
            fileList.add(files[i]); 
        } 
    } 
    for (File f : fileList) { 
        str2=f.getAbsoluteFile(); 
        str3 
    } 
} 

//13.复制文件夹  
//import java.io.*; 
//import java.util.*; 
LinkedList&lt;String&gt; folderList = new LinkedList&lt;String&gt;(); 
folderList.add(str1); 
LinkedList&lt;String&gt; folderList2 = new LinkedList&lt;String&gt;(); 
folderList2.add(str2+ str1.substring(str1.lastIndexOf(&quot;\\&quot;))); 
while (folderList.size() &gt; 0) { 
    (new File(folderList2.peek())).mkdirs(); // 如果文件夹不存在 则建立新文件夹 
    File folders = new File(folderList.peek()); 
    String[] file = folders.list(); 
    File temp = null; 
    try { 
        for (int i = 0; i &lt; file.length; i++) { 
            if (folderList.peek().endsWith(File.separator)) { 
                temp = new File(folderList.peek() + File.separator 
                + file[i]); 
            } else { 
                temp = new File(folderList.peek() + File.separator + file[i]); 
            } 
            if (temp.isFile()) { 
                FileInputStream input = new FileInputStream(temp); 
                FileOutputStream output = new FileOutputStream( 
                folderList2.peek() + File.separator + (temp.getName()).toString()); 
                byte[] b = new byte[5120]; 
                int len; 
                while ((len = input.read(b)) != -1) { 
                    output.write(b, 0, len); 
                } 
                output.flush(); 
                output.close(); 
                input.close(); 
            } 
            if (temp.isDirectory()) {// 如果是子文件夹 
                for (File f : temp.listFiles()) { 
                    if (f.isDirectory()) { 
                        folderList.add(f.getPath()); 
                        folderList2.add(folderList2.peek() 
                        + File.separator + f.getName()); 
                    } 
                } 
            } 
        } 
    } catch (Exception e) { 
    //System.out.println(&quot;复制整个文件夹内容操作出错&quot;); 
        e.printStackTrace(); 
    } 
    folderList.removeFirst(); 
    folderList2.removeFirst(); 
} 

//14.复制一个文件夹下所有的文件夹到另一个文件夹下 
//import java.io.*; 
//import java.util.*; 
File copyfolders=new File(str1); 
File[] copyfoldersList=copyfolders.listFiles(); 
for(int k=0;k&lt;copyfoldersList.length;k++){ 
    if(copyfoldersList[k].isDirectory()){ 
        ArrayList&lt;String&gt;folderList=new ArrayList&lt;String&gt;(); 
        folderList.add(copyfoldersList[k].getPath()); 
        ArrayList&lt;String&gt;folderList2=new ArrayList&lt;String&gt;(); 
        folderList2.add(str2+&quot;/&quot;+copyfoldersList[k].getName()); 
        for(int j=0;j&lt;folderList.length;j++){ 
             (new File(folderList2.get(j))).mkdirs(); //如果文件夹不存在 则建立新文件夹 
             File folders=new File(folderList.get(j)); 
             String[] file=folders.list(); 
             File temp=null; 
             try { 
                 for (int i = 0; i &lt; file.length; i++) { 
                     if(folderList.get(j).endsWith(File.separator)){ 
                         temp=new File(folderList.get(j)+&quot;/&quot;+file[i]); 
                     } else { 
                         temp=new File(folderList.get(j)+&quot;/&quot;+File.separator+file[i]); 
                     } 
                     FileInputStream input = new FileInputStream(temp); 
                     if(temp.isFile()){ 
                         FileInputStream input = new FileInputStream(temp); 
                         FileOutputStream output = new FileOutputStream(folderList2.get(j) + &quot;/&quot; + (temp.getName()).toString()); 
                         byte[] b = new byte[5120]; 
                         int len; 
                         while ( (len = input.read(b)) != -1) { 
                             output.write(b, 0, len); 
                         } 
                         output.flush(); 
                         output.close(); 
                         input.close(); 
                     } 
                     if(temp.isDirectory()){//如果是子文件夹 
                         folderList.add(folderList.get(j)+&quot;/&quot;+file[i]); 
                         folderList2.add(folderList2.get(j)+&quot;/&quot;+file[i]); 
                     } 
                 } 
             } 
             catch (Exception e) { 
                 System.out.println(&quot;复制整个文件夹内容操作出错&quot;); 
                 e.printStackTrace(); 
             } 
        } 
    } 
} 

//15.移动文件夹 
//import java.io.*; 
//import java.util.*; 
LinkedList&lt;String&gt; folderList = new LinkedList&lt;String&gt;(); 
folderList.add(str1); 
LinkedList&lt;String&gt; folderList2 = new LinkedList&lt;String&gt;(); 
folderList2.add(str2 + str1.substring(str1.lastIndexOf(&quot;\\&quot;))); 
while (folderList.size() &gt; 0) { 
    (new File(folderList2.peek())).mkdirs(); // 如果文件夹不存在 则建立新文件夹 
    File folders = new File(folderList.peek()); 
    String[] file = folders.list(); 
    File temp = null; 
    try { 
        for (int i = 0; i &lt; file.length; i++) { 
            if (folderList.peek().endsWith(File.separator)) { 
                temp = new File(folderList.peek() + File.separator + file[i]); 
            } else { 
                temp = new File(folderList.peek() + File.separator + file[i]); 
            } 
            if (temp.isFile()) { 
                FileInputStream input = new FileInputStream(temp); 
                FileOutputStream output = new FileOutputStream( 
                folderList2.peek() + File.separator + (temp.getName()).toString()); 
                byte[] b = new byte[5120]; 
                int len; 
                while ((len = input.read(b)) != -1) { 
                    output.write(b, 0, len); 
                } 
                output.flush(); 
                output.close(); 
                input.close(); 
                if (!temp.delete()) 
                System.out.println(&quot;删除单个文件操作出错!&quot;); 
            } 
            if (temp.isDirectory()) {// 如果是子文件夹 
                for (File f : temp.listFiles()) { 
                    if (f.isDirectory()) { 
                        folderList.add(f.getPath()); 
                        folderList2.add(folderList2.peek() + File.separator + f.getName()); 
                    } 
                } 
            } 
        } 
    } catch (Exception e) { 
        // System.out.println(&quot;复制整个文件夹内容操作出错&quot;); 
        e.printStackTrace(); 
    } 
    folderList.removeFirst(); 
    folderList2.removeFirst(); 
} 
File f = new File(str1); 
if (!f.delete()) { 
    for (File file : f.listFiles()) { 
        if (file.list().length == 0) { 
            System.out.println(file.getPath()); 
            file.delete(); 
        } 
    } 
} 
//16.移动一个文件夹下所有的文件夹到另一个目录下 
//import java.io.*; 
//import java.util.*; 
File movefolders=new File(str1); 
File[] movefoldersList=movefolders.listFiles(); 
for(int k=0;k&lt;movefoldersList.length;k++){ 
    if(movefoldersList[k].isDirectory()){ 
        ArrayList&lt;String&gt;folderList=new ArrayList&lt;String&gt;(); 
        folderList.add(movefoldersList[k].getPath()); 
        ArrayList&lt;String&gt;folderList2=new ArrayList&lt;String&gt;(); 
        folderList2.add(str2+&quot;/&quot;+movefoldersList[k].getName()); 
        for(int j=0;j&lt;folderList.length;j++){ 
             (new File(folderList2.get(j))).mkdirs(); //如果文件夹不存在 则建立新文件夹 
             File folders=new File(folderList.get(j)); 
             String[] file=folders.list(); 
             File temp=null; 
             try { 
                 for (int i = 0; i &lt; file.length; i++) { 
                     if(folderList.get(j).endsWith(File.separator)){ 
                         temp=new File(folderList.get(j)+&quot;/&quot;+file[i]); 
                     } 
                     else{ 
                         temp=new File(folderList.get(j)+&quot;/&quot;+File.separator+file[i]); 
                     } 
                     FileInputStream input = new FileInputStream(temp); 
                     if(temp.isFile()){ 
                         FileInputStream input = new FileInputStream(temp); 
                         FileOutputStream output = new FileOutputStream(folderList2.get(j) + &quot;/&quot; + (temp.getName()).toString()); 
                         byte[] b = new byte[5120]; 
                         int len; 
                         while ( (len = input.read(b)) != -1) { 
                             output.write(b, 0, len); 
                         } 
                         output.flush(); 
                         output.close(); 
                         input.close(); 
                         temp.delete(); 
                     } 
                     if(temp.isDirectory()){//如果是子文件夹 
                         folderList.add(folderList.get(j)+&quot;/&quot;+file[i]); 
                         folderList2.add(folderList2.get(j)+&quot;/&quot;+file[i]); 
                     } 
                 } 
             } 
             catch (Exception e) { 
                 System.out.println(&quot;复制整个文件夹内容操作出错&quot;); 
                 e.printStackTrace(); 
             } 
        } 
        movefoldersList[k].delete(); 
    } 
} 

//17.以一个文件夹的框架在另一个目录创建文件夹和空文件 
//import java.io.*; 
//import java.util.*; 
boolean b=false;//不创建空文件 
ArrayList&lt;String&gt;folderList=new ArrayList&lt;String&gt;(); 
folderList.add(str1); 
ArrayList&lt;String&gt;folderList2=new ArrayList&lt;String&gt;(); 
folderList2.add(str2); 
for(int j=0;j&lt;folderList.length;j++){ 
    (new File(folderList2.get(j))).mkdirs(); //如果文件夹不存在 则建立新文件夹 
    File folders=new File(folderList.get(j)); 
    String[] file=folders.list(); 
    File temp=null; 
    try { 
        for (int i = 0; i &lt; file.length; i++) { 
            if(folderList.get(j).endsWith(File.separator)){ 
                temp=new File(folderList.get(j)+&quot;/&quot;+file[i]); 
            } 
            else{ 
                temp=new File(folderList.get(j)+&quot;/&quot;+File.separator+file[i]); 
            } 
            FileInputStream input = new FileInputStream(temp); 
            if(temp.isFile()){ 
                if (b) temp.createNewFile(); 
            } 
            if(temp.isDirectory()){//如果是子文件夹 
                folderList.add(folderList.get(j)+&quot;/&quot;+file[i]); 
                folderList2.add(folderList2.get(j)+&quot;/&quot;+file[i]); 
            } 
        } 
    } 
    catch (Exception e) { 
        System.out.println(&quot;复制整个文件夹内容操作出错&quot;); 
        e.printStackTrace(); 
    } 
} 

//18.复制文件 
//import java.io.*; 
 int bytesum = 0; 
 int byteread = 0; 
 File oldfile = new File(str1); 
 try { 
 if (oldfile.exists()) { //文件存在时 
 FileInputStream inStream = new FileInputStream(oldfile); //读入原文件 
 FileOutputStream fs = new FileOutputStream(new File(str2,oldfile.getName())); 
 byte[] buffer = new byte[5120]; 
 int length; 
 while ( (byteread = inStream.read(buffer)) != -1) { 
 bytesum += byteread; //字节数 文件大小 
 System.out.println(bytesum); 
 fs.write(buffer, 0, byteread); 
 } 
 inStream.close(); 
 } 
 } 
 catch (Exception e) { 
 System.out.println(&quot;复制单个文件操作出错&quot;); 
 e.printStackTrace(); 
 }  

//19.复制一个文件夹下所有的文件到另一个目录 
//import java.io.*; 
File copyfiles=new File(str1); 
File[] files=copyfiles.listFiles(); 
for(int i=0;i&lt;files.length;i++){ 
    if(!files[i].isDirectory()){ 
        int bytesum = 0; 
        int byteread = 0; 
        try { 
            InputStream inStream = new FileInputStream(files[i]); //读入原文件 
            FileOutputStream fs = new FileOutputStream(new File(str2,files[i].getName()); 
            byte[] buffer = new byte[5120]; 
            int length; 
            while ( (byteread = inStream.read(buffer)) != -1) { 
                bytesum += byteread; //字节数 文件大小 
                System.out.println(bytesum); 
                fs.write(buffer, 0, byteread); 
            } 
            inStream.close(); 
        } catch (Exception e) { 
            System.out.println(&quot;复制单个文件操作出错&quot;); 
            e.printStackTrace(); 
        } 
    } 
}  

//20.提取扩展名 
String str2=str1.substring(str1.lastIndexOf(&quot;.&quot;)+1);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/Day3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/Day3/" itemprop="url">java -- day3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h2 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h2><p><strong>方法：</strong>是对一段用于特定解决特定问题的代码块的封装。<br><strong>语法：</strong>访问权限修饰符【其他修饰符如static】 返回值类型 方法名（参数类型1 形参类型1，参数类型2 形参类型2。。。）{方法体}<br><strong>特点：</strong></p>
<ul>
<li>静态的方法只能访问静态的方法，不能访问非静态的方法。（静态方法：使用static修饰符修饰的方法）</li>
<li><ol>
<li>方法的返回值类型若不为void（没有返回值），那么，在方法的调用点，一般要定义一个与返回值类型相兼容的数据的类型变量接收；从语法角度上也可以不用接收。 2.若方法的返回值类型是void，此时，方法的调用点不能定义变量接收，只能调用方法。</li>
</ol>
</li>
<li>实参和形参的数据类型要相互兼容，且：实参的取值范围要小于等于形参类型的取值范围。<strong>实参：</strong>传入的参数值。<strong>形参</strong>接收实参传过来的值。<strong>注意</strong>实参与形参名可以相同也可以不同。</li>
<li>程序运行到某行代码时，改代码调用某个方法，此时：程序进入该方法体执行，执行完毕后程序返回到方法的调用点。继续执行后续的代码。</li>
<li>方法若有一个不为void的返回值类型，那么：方法中必须有return语句，且return语句的返回值类型与方法的返回值类型相兼容，且只对应的类型的取值范围小于等于返回值的类型。</li>
<li><p>方法设计需要注意：1.方法需不需要传入值，需要则有形参，不需要就不需要形参 2.方法有无返回值，void。</p>
<p>  注意：</p>
<ol>
<li>为了提高代码的可读性和维护性，一个方法体中，代码的最大行数建议《=30行，超过的部分，抽取成方法。</li>
<li>方法的精髓在于：可以对复杂的问题进行分解，便于各个击破，直到求到最后的结果。</li>
</ol>
</li>
</ul>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><pre><code>在同一个类中，用于解决类似问题的两个或者两个以上的方法。
1. 方法名相同
2. 形参列表不同（类型、个数、顺序）
3. 与返回值类型没有关系
</code></pre><h2 id="重载的好处"><a href="#重载的好处" class="headerlink" title="重载的好处"></a>重载的好处</h2><pre><code>设计重载的目的是，减少方法名的个数，便于程序员掌握；程序在运行的过程中，通过传递不同的参数，动态调用与之匹配的方法区执行。
</code></pre><p><strong>方法的扩展</strong>：</p>
<ul>
<li>若在一个类中，存在重载的方法，与方法的调用点传递的实参，没有完全匹配时，在运行过程总，会自动选择一个最为合适的方法执行；若多个方法均匹配，就会编译报错。</li>
</ul>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>算法：解决某类问题总结出来的方法。（由软件前辈们总结出来）</p>
<p>递归算法：方法体中，调用自身的代码编写方式。</p>
<p>案例：使用递归算法，求出任意指定位上的斐波拉契数。</p>
<p>斐波拉契数：第1位数是1，第2位数也是1，从第3位数开始，每一位上的数字是前两位数之和。<br>组合而成的数字序列，称之为“斐波拉契数列”。<br>如：1 1 2 3 5 8 13 21 …</p>
<p>总结：<br>1、使用递归算法，一定要有出口，否则，程序会陷入死循环，直至内存溢出。<br>2、若递归的层数较少的场合，可以使用递归算法；若递归的层数很大，使用递归算法，<br>   会消耗大量的内存空间，不建议使用递归，可以选用别的解决方案。</p>
<p>课堂作业：<br>   使用递归算法，计算1！+2！+3！+…+20!。<br> 思路：<br> 1、设计一个方法，求出指定数的阶乘值<br> 2、在main方法中，使用for循环求出循环变量的阶乘和</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/28/java/language/java_day/Day14总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/head1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/java/language/java_day/Day14总结/" itemprop="url">Day14 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-28T21:18:12+08:00">
                2015-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day14-总结"><a href="#Day14-总结" class="headerlink" title="Day14 总结"></a>Day14 总结</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><blockquote>
<p>File类：对存储在磁盘上的文件和目录的抽取和封装。</p>
</blockquote>
<h3 id="File类作用"><a href="#File类作用" class="headerlink" title="File类作用"></a>File类作用</h3><blockquote>
<p>常用的字段：<code>static String separator</code>：会根据底层平台，动态生成一个分隔符（目录之间的分隔符）windows –&gt;\ ;linux –&gt; /</p>
</blockquote>
<h3 id="File类的构造方法"><a href="#File类的构造方法" class="headerlink" title="File类的构造方法"></a>File类的构造方法</h3><blockquote>
<p><code>File(File parent, String child)</code>：根据父目录对应的文件对象和该目录下的文件</p>
<p><code>File(String pathname)</code> ：将参数指定的目录封装成一个file对象（绝对路径和相对路径）</p>
<p><code>File(String parent, String child)</code> ：根据父目录对应的路径，和该目录下的文件或目录<br>xxx</p>
</blockquote>
<h3 id="File类文件属性方法"><a href="#File类文件属性方法" class="headerlink" title="File类文件属性方法"></a>File类文件属性方法</h3><h3 id="使用File类对文件进行操作"><a href="#使用File类对文件进行操作" class="headerlink" title="使用File类对文件进行操作"></a>使用File类对文件进行操作</h3><h3 id="使用File类浏览目录中的文件和子目录"><a href="#使用File类浏览目录中的文件和子目录" class="headerlink" title="使用File类浏览目录中的文件和子目录"></a>使用File类浏览目录中的文件和子目录</h3><h2 id="IO概念和种类"><a href="#IO概念和种类" class="headerlink" title="IO概念和种类:"></a>IO概念和种类:</h2><h3 id="什么是IO流？"><a href="#什么是IO流？" class="headerlink" title="什么是IO流？"></a>什么是IO流？</h3><blockquote>
<p>IO流：磁盘上的文件与内存进行数据传递的管道（通路、媒介）。</p>
</blockquote>
<p>###流的作用和原理？    </p>
<h2 id="IO流的种类"><a href="#IO流的种类" class="headerlink" title="IO流的种类:"></a>IO流的种类:</h2><h3 id="输入流、输出流-相对于内存而言"><a href="#输入流、输出流-相对于内存而言" class="headerlink" title="输入流、输出流    (相对于内存而言)"></a>输入流、输出流    (<strong>相对于内存而言</strong>)</h3><h3 id="字符流、字节流"><a href="#字符流、字节流" class="headerlink" title="字符流、字节流"></a>字符流、字节流</h3><h3 id="节点流、处理流"><a href="#节点流、处理流" class="headerlink" title="节点流、处理流"></a>节点流、处理流</h3><ol>
<li><strong>节点流：</strong>与具体的存储介质直接进行交互的流。（API中涉及到的类：FileInputStream –&gt;文件字节输入流，FileOutputStream–&gt;文件字节输出流FileReader–&gt;文件字符输入流，FileWriter–&gt;文件字符输出流）</li>
<li><strong>处理流：</strong>不与具体的存储介质直接进行交互的流。（API中涉及到的类：    <ol>
<li>BufferedInputStream –&gt;带缓存的字节输入流，</li>
<li>BufferedOutputStream–&gt;带缓存的字节输出流；                 3. BufferedReader –&gt;带缓存的字符输入流</li>
<li>BufferedWriter –&gt;带缓存的字符输出流）</li>
</ol>
</li>
</ol>
<p>##字节输入流:    </p>
<p>###InputStream类的常用方法    </p>
<ol>
<li>int available() ：返回的是流中所有数据的长度（单位：字节）。</li>
<li>void close()：关闭此输入流并释放与该流关联的所有系统资源。 </li>
</ol>
<p>###InputStream类的子类:文件输入流FileInputStream    </p>
<p>###FileInputStream构造方法和常用方法    </p>
<p>##字节输出流:    </p>
<p>###OutputStream类的常用方法</p>
<ol>
<li>void close() 关闭此输出流并释放与此流有关的所有系统资源。 </li>
<li>void flush() 将输出流中的数据刷新。</li>
<li>void write(byte[] b)：将参数指定的字节数组写入到输出流中。</li>
<li>void write(byte[] b, int off, int len) ：将参数指定的字节数组的一部分写入到输出流中。</li>
<li><p>abstract  void write(int b) ：将参数指定的字节写入到字节输出流中。</p>
<p> 需求：使用InputStream,OutputStream,实现文件的拷贝。将指定目录下的文件，拷贝到另外一个目录中去。</p>
<p> 思路：<br> 1、构建文件字节输入流对象（理解：建立了一条磁盘文件到内存的通路）<br> 2、构建文件字节输出流对象（理解：建立了一条内存到磁盘存储介质的通路）<br> 3、通过循环从输入流中读取数据，与此同时，将数据写入到输出流中，直到数据处理完毕。<br> 4、释放资源</p>
<p> 字节流的适用场景：</p>
<pre><code>拷贝具有特定格式的源文件（声音、图像、视频、压缩包、doc、excel、exe文件表格等等）时，要使用字节流，
</code></pre><p> 不会破坏源的格式，否则，拷贝后，文件无法打开、运行等等。</p>
<p> 路径：<br>  绝对路径：从盘符开始的路径。  如：c:/temp.txt<br>  相对路径：不从盘符开始的路径。如： ../../tmp/test.txt</p>
<p> 目录和目录、目录和文件之间的分隔符：<br> windows:  c:\temp\test.txt<br> linux :   temp/test.txt</p>
<p> File.seperator; —&gt;根据系统运行的平台，动态生成一个分隔符<br>###OuputStream类的子类:文件输出类FileOutputStream<br>###FileOutputStream构造方法和常用方法<br>##字符输入流:<br>###Reader类的常用方法<br>###Reader类的子类:FileReader<br>###FileReader构造方法和常用方法<br>##字符输出流<br>###Writer类的常用方法    </p>
</li>
<li>Writer append(char c) ：将字符追加到字符输出流的末尾。</li>
<li>Writer append(CharSequence csq) ：将字符追加到字符输出流的末尾。</li>
<li>void write(char[] cbuf) ：将参数指定的字符数组中的数据写入到字符输出流中。(字符流中的read(char[]cbuf)，作用是：将流中的数据读取出来填充字符数组)</li>
<li><p>void write(String str) ：直接将字符串写入到字符输出流中。<br>###Writer类的子类:FileWriter    </p>
<p> 需求：使用Writer，将内存中的数据写入到磁盘一个文件中。</p>
<p> 案例：使用字符流，实现文件的拷贝。</p>
<p> 字符流的适用场景：操作文本文件时，建议使用。若操作一些带有特殊格式（声音、图像、视频、压缩包等等）的文件，不要使用。</p>
</li>
</ol>
<p>###FileWriter构造方法和常用方法</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/53/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><span class="page-number current">54</span><a class="page-number" href="/page/55/">55</a><a class="extend next" rel="next" href="/page/55/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/head1.jpg" alt="Double">
          <p class="site-author-name" itemprop="name">Double</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">548</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">260</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Double</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
